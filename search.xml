<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Google调参笔记</title>
    <url>/link/7b0c9bac.html</url>
    <content><![CDATA[<h1 id="Deep-Learning-Tuning-Playbook"><a href="#Deep-Learning-Tuning-Playbook" class="headerlink" title="Deep Learning Tuning Playbook"></a>Deep Learning Tuning Playbook</h1><p><em>This is not an officially supported Google product.</em></p>
<p><strong>Varun Godbole<sup>&dagger;</sup>, George E. Dahl<sup>&dagger;</sup>, Justin Gilmer<sup>&dagger;</sup>, Christopher J. Shallue<sup>&Dagger;</sup>, Zachary Nado<sup>&dagger;</sup></strong></p>
<p>&dagger; Google Research, Brain Team</p>
<p>&Dagger; Harvard University</p>
<h2 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h2><ul>
<li><a href="#who-is-this-document-for">这个文件是给谁看的?</a></li>
<li><a href="#why-a-tuning-playbook">为什么会有这篇调优文档?</a></li>
<li><a href="#guide-for-starting-a-new-project">开始一个新项目的指南</a><ul>
<li><a href="#choosing-a-model-architecture">选择一个模型架构</a></li>
<li><a href="#choosing-the-optimizer">选择优化器</a></li>
<li><a href="#choosing-the-batch-size">选择批量大小</a></li>
<li><a href="#choosing-the-initial-configuration">选择初始配置</a></li>
</ul>
</li>
<li><a href="#a-scientific-approach-to-improving-model-performance">改进模型性能的科学方法</a><ul>
<li><a href="#the-incremental-tuning-strategy">增量调优策略</a></li>
<li><a href="#exploration-vs-exploitation">探索未知 vs 利用已知</a></li>
<li><a href="#choosing-the-goal-for-the-next-round-of-experiments">选择下一轮实验的目标</a></li>
<li><a href="#Designing-the-next-round-of-experiments">设计下一轮实验</a></li>
<li><a href="#Determining-whether-to-adopt-a-training-pipeline-change-or-hyperparameter-configuration">决定是否采用训练通道变更或超参数配置</a></li>
<li><a href="#After-exploration-concludes">探索结束后</a></li>
</ul>
</li>
<li><a href="#Determining-the-number-of-steps-for-each-training-run">确定每次训练的步数</a><ul>
<li><a href="#Deciding-how-long-to-train-when-training-is-not-compute-bound">决定训练不受计算限制时训练多长时间</a></li>
<li><a href="#Deciding-how-long-to-train-when-training-is-compute-bound">决定训练受计算限制时训练多长时间</a></li>
</ul>
</li>
<li><a href="#Additional-guidance-for-the-training-pipeline">训练通道的附加指南</a><ul>
<li><a href="#Optimizing-the-input-pipeline">优化输入通道</a></li>
<li><a href="Evaluating-model-performance">评估模型性能</a></li>
<li><a href="#Saving-checkpoints-and-retrospectively-selecting-the-best-checkpoint">保存检查点并回顾性的选择最佳检查点</a></li>
<li><a href="#Setting-up-experiment-tracking">设置实验跟踪</a></li>
<li><a href="#Batch-normalization-implementation-details">批量归一化实现细节</a></li>
<li><a href="#Considerations-for-multi-host-pipelines">多主机通道考虑</a></li>
</ul>
</li>
<li><a href="#faqs">常见问题</a></li>
<li><a href="#acknowledgments">Acknowledgments</a></li>
<li><a href="#citing">Citing</a></li>
<li><a href="#contributing">Contributing</a></li>
</ul>
<h2 id="Who-is-this-document-for"><a href="#Who-is-this-document-for" class="headerlink" title="Who is this document for?"></a>Who is this document for?</h2><p>​        本文档适用于有兴趣<strong>最大化深度学习模型的性能</strong>的工程师和研究人员(个人和团队)。我们假设机器学习和深度学习概念的基本知识。</p>
<p>​        我们的重点是<strong>超参数调优的过程</strong>。我们谈到了其他深度学习训练方面，如管道实现和优化，但我们对这些方面的处理并不打算是完整的。</p>
<p>​        我们假设机器学习问题是一个监督学习问题或者看起来很像的东西(例如自我监督)。也就是说，有些本文件中的规定也可以适用于其他类型的问题。</p>
<h2 id="Why-a-tuning-playbook"><a href="#Why-a-tuning-playbook" class="headerlink" title="Why a tuning playbook?"></a>Why a tuning playbook?</h2><p>​        目前，要让深度神经网络在实践中很好地工作，需要进行大量的辛劳和猜测。更糟糕的是，人们使用深度学习来获得良好结果的实际方法很少被记录下来。论文掩盖了导致最终结果的过程，以呈现一个更清晰的故事，而研究商业问题的机器学习工程师很少有时间退一步，概括他们的过程。教科书倾向于回避实际指导，优先考虑基本原则，即使它们的作者在应用工作中有必要的经验，可以提供有用的建议。在准备创建本文档时，我们找不到任何全面的尝试来真正解释“如何使用深度学习获得良好的结果”。相反，我们在博客文章和社交媒体上找到了一些建议的片段，在研究论文的附录中发现了一些技巧，偶尔会有关于某个特定项目或管道的案例研究，还有很多困惑。深度学习专家和不太熟练的从业者使用表面上相似的方法所取得的结果之间存在着巨大的鸿沟。与此同时，这些专家欣然承认，他们所做的一些事情可能并不完全合理。随着深度学习的成熟并对世界产生更大的影响，社区需要更多的资源来涵盖有用的配方，包括所有对获得良好结果至关重要的实际细节。</p>
<p>​        我们是一个由五名研究人员和工程师组成的团队，他们在深度学习领域工作了多年，其中一些人早在2006年就开始了。我们已经将深度学习应用于从语音识别到天文学的所有问题，并在此过程中学到了很多东西。这份文档源于我们自己训练神经网络的经验，教授新的机器学习工程师，并就深度学习的实践为我们的同事提供建议。尽管看到深度学习从少数学术实验室实践的机器学习方法发展为数十亿人使用的产品技术是令人欣慰的，但深度学习作为一门工程学科仍处于起步阶段，我们希望这份文件鼓励其他人帮助系统化该领域的实验协议。</p>
<p>​        这份文件的出现是为了明确我们自己的深度学习方法，因此它代表了作者在写作时的观点，而不是任何形式的客观事实。我们自己在超参数调优方面的挣扎使它成为我们指南的一个特别重点，但我们也涵盖了我们在工作中遇到的其他重要问题(或看到的错误)。我们的意图是让这项工作成为一份活的文件，随着我们信念的改变而成长和发展。例如，关于调试和减轻训练失败的材料在两年前是不可能写出来的，因为它是基于最近的结果和正在进行的调查。不可避免地，我们的一些建议将需要更新，以说明新的结果和改进的工作流程。我们不知道“最佳”的深度学习配方，但在社区开始写下并讨论不同的过程之前，我们无法指望找到它。为此，我们鼓励那些对我们的建议有异议的读者提出替代建议，并提供令人信服的证据，这样我们就可以更新剧本。我们也很乐意看到可能有不同建议的替代指南和剧本，这样我们就可以作为一个社区努力实现最佳实践。最后，任何标有🤖表情符号的区域都是我们想做更多研究的地方。只有在尝试写完这本剧本之后，我才完全清楚在深度学习从业者的工作流程中可以找到多少有趣而被忽视的研究问题。</p>
<h2 id="指导开始一个新项目"><a href="#指导开始一个新项目" class="headerlink" title="指导开始一个新项目"></a><strong>指导开始一个新项目</strong></h2><p>我们在调优过程中所做的许多决定可以在项目开始时一次性做出，只有在环境发生变化时才会偶尔重新进行。</p>
<p>我们的指导原则基于以下假设:</p>
<ul>
<li>已经完成了足够多的问题制定、数据清理等基本工作，因此在模型架构和训练配置上花费时间是有意义的。</li>
<li>已经建立了一个进行训练和评估的流程，且很容易为各种感兴趣的模型执行训练和预测工作。</li>
<li>已经选择并实现了适当的度量。这些应该尽可能代表在部署环境中将要度量的内容。</li>
</ul>
<h3 id="选择模型结构"><a href="#选择模型结构" class="headerlink" title="选择模型结构"></a><strong>选择模型结构</strong></h3><p><strong><em>总结:</em></strong> <em>当开始一个新项目时，尝试重用一个已经工作的模型</em></p>
<ul>
<li>选择一个建立良好的、常用的模型体系结构来开始工作。以后总是可以构建自定义模型。</li>
<li>模型架构通常具有各种超参数，它们决定模型的大小和其他细节(例如层数、层宽度、激活函数类型)。<ul>
<li>因此，选择架构实际上意味着选择一系列不同的模型(每个模型超参数设置对应一个模型)。</li>
<li>我们将在<a href="#选择初始配置">选择初始配置</a>和<a href="# 提高模型性能的科学方法">提高模型性能的科学方法</a>中考虑模型超参数的选择问题。</li>
</ul>
</li>
<li>如果可能的话，试着找到一篇论文，尽可能地解决手头的问题，并重现该模型作为起点。</li>
</ul>
<h3 id="选择优化器"><a href="#选择优化器" class="headerlink" title="选择优化器"></a><strong>选择优化器</strong></h3><p><strong><em>总结:</em></strong> <em>从针对当前问题类型的最流行的优化器开始</em></p>
<ul>
<li>在所有类型的机器学习问题和模型架构中，没有优化器是“最好的”。即使只是<a href="https://arxiv.org/abs/1910.05446">比较优化器的性能是一项艰巨的任务</a>。🤖</li>
<li>我们建议坚持使用成熟的、流行的优化器，尤其是在开始一个新项目的时候。<ul>
<li>理想情况下，选择用于同一类型问题的最流行的优化器。</li>
</ul>
</li>
<li>准备好关注所选优化器的<strong>所有</strong>超参数。<ul>
<li>具有更多超参数的优化器可能需要更多的调优工作来找到最佳配置。</li>
<li>在项目的开始阶段，当我们试图找到各种其他超参数的最佳值(例如架构超参数)，同时将优化器超参数视为<a href="# identifying-scientific-nuisance-and-fixed-hyperparameters">麻烦的参数</a>时，这一点尤其相关。</li>
<li>从一个更简单的优化器开始可能更好(例如，具有固定动量的SGD或具有固定$\epsilon$， $\beta<em>{1}$的Adam $\beta</em>{2}$)在项目的初始阶段，然后切换到更通用的优化器。</li>
</ul>
</li>
<li>我们喜欢的完善的优化器包括(但不限于):<ul>
<li><a href="#所有流行的优化算法的更新规则是什么?">SGD with momentum</a>(我们喜欢Nesterov变体)</li>
<li><a href="#所有流行的优化算法的更新规则是什么?">Adam和NAdam</a>，这比有动量的SGD更通用。注意Adam有4个可调超参数<a href="https://arxiv.org/abs/1910.05446">它们都很重要</a>!<ul>
<li>参见<a href="#如何调优Adam的超参数">如何调优Adam的超参数?</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="选择批次大小"><a href="#选择批次大小" class="headerlink" title="选择批次大小"></a>选择批次大小</h3><p><strong><em>总结:</em></strong> <em>批大小决定了训练速度，不应用于直接调优验证集性能。通常，理想的批大小将是可用硬件支持的最大批大小</em></p>
<ul>
<li>批处理大小是决定<em>训练时间</em>和<em>计算资源消耗</em>的关键因素。</li>
<li>增加批大小通常会减少训练时间。这是非常有益的，因为它:<ul>
<li>允许在固定的时间间隔内更彻底地调整超参数，可能会产生更好的最终模型。</li>
<li>减少开发周期的延迟，允许更频繁地测试新想法。</li>
</ul>
</li>
<li>增加批处理大小可以减少、增加或不改变资源消耗。</li>
<li>批大小不应该被当作验证集性能的可调超参数。<ul>
<li>只要所有超参数都经过了良好的调优(特别是学习率和正则化超参数)，并且训练步骤的数量足够多，使用任何批处理大小都应该可以获得相同的最终性能(参见<a href="https://arxiv.org/abs/1811.03600">Shallue et al. 2018</a>)。</li>
<li>请参阅<a href="#为什么不调整批大小以直接提高验证集性能?">为什么不调整批大小以直接提高验证集性能?</a></li>
</ul>
</li>
</ul>
<h4 id="确定可行的批大小和估计训练吞吐量"><a href="#确定可行的批大小和估计训练吞吐量" class="headerlink" title="确定可行的批大小和估计训练吞吐量"></a>确定可行的批大小和估计训练吞吐量</h4><details><summary><em>[Click to expand]</em></summary>
<br>

-   对于给定的模型和优化器，可用硬件通常会支持一定范围的批处理大小。限制因素通常是显存。
-   不幸的是，如果不运行或至少编译完整的训练程序，就很难计算出哪些批处理大小适合内存。
-   最简单的解决方案通常是以不同的批处理大小(例如增加2的幂)运行少量步骤的训练作业，直到其中一个作业超过可用内存。
-   对于每个批次大小，我们应该训练足够长的时间，以获得*训练吞吐量*的可靠估计

<p align="center">训练吞吐量(training throughput)=(每秒处理的示例数量)</p>

<p align="center">或者，等价每一个step的时间(time per step)</p>

<p align="center">time per step = (batch size) / (training throughput)</p>

-   当显存尚未饱和时，如果批量大小翻倍，训练吞吐量也应该翻倍(或至少接近翻倍)。同样，随着批处理大小的增加，每个步骤的时间应该是恒定的(或至少接近恒定)。
-   如果不是这种情况，则训练流程存在瓶颈，例如计算节点之间的I/O或同步。在继续之前，这可能值得诊断和纠正。
-   如果训练吞吐量只增加到某个最大批处理大小，那么我们应该只考虑最大批处理大小，即使硬件支持更大的批处理大小。也就是说选择CPU和GPU的短板来作为上限，能更快的处理。
    -   使用更大批量的所有好处都假定训练吞吐量增加。如果不能，修复瓶颈或使用较小的批处理大小。
    -   **梯度累积**模拟的批处理大小大于硬件所能支持的批处理大小，因此不提供任何吞吐量优势。在实际工作中一般应避免使用。
-   这些步骤可能需要在每次模型或优化器更改时重复执行(例如，不同的模型架构可能允许更大的批处理大小以适应显存)。

</details>

<h4 id="选择批的大小以减少训练时间"><a href="#选择批的大小以减少训练时间" class="headerlink" title="选择批的大小以减少训练时间"></a><strong>选择批的大小以减少训练时间</strong></h4><p align="center">Training time = (time per step) x (total number of steps)</p>

<ul>
<li>对于所有可行的批量大小，我们通常可以认为每一步的时间近似恒定。当没有并行计算的开销，并且所有的训练瓶颈都已经被诊断和纠正时，这是正确的(关于如何识别训练瓶颈，请参阅<a href="#确定可行的批大小和估计训练吞吐量">前一节</a>。在实践中，增加批处理大小通常至少会产生一些开销。</li>
<li>随着批处理大小的增加，达到固定性能目标所需的总步骤数通常会减少(当批处理大小改变时，所有相关的超参数都被重新调优;<a href="https://arxiv.org/abs/1811.03600">Shallue et al. 2018</a>)。<ul>
<li>例如，批处理大小加倍可能会使所需的总步骤数减半。这被称为完美缩放。</li>
<li>完美的缩放适用于所有批量大小，直到一个关键批量大小，超过这个批量大小，就会实现收益递减。</li>
<li>最终，增加批大小不再减少训练步骤的数量(但不会增加它)。</li>
</ul>
</li>
<li>因此，使训练时间最小化的批处理大小通常是最大的批处理大小，但仍然可以减少所需的训练步骤数。<ul>
<li>批处理大小取决于数据集、模型和优化器，如何计算它是一个开放的问题，而不是为每个新问题通过实验找到它。🤖</li>
<li>在比较批量大小时，注意示例预算/<a href="https://developers.google.com/machine-learning/glossary#epoch">epoch</a>预算(运行所有实验，同时固定训练示例演示的数量)和步骤预算(运行所有实验，并固定训练步骤的数量)之间的区别。<ul>
<li>将批大小与epoch预算进行比较只能探测完美的扩展机制，即使当更大的批大小仍然可以通过减少所需的训练步骤数量来提供有意义的加速。</li>
</ul>
</li>
<li><strong>通常，可用硬件支持的最大批大小将小于临界批大小。因此，一个好的经验法则(不进行任何实验)是使用尽可能大的批处理大小。</strong></li>
</ul>
</li>
<li>如果使用更大的批量会增加训练时间，那就没有意义了。</li>
</ul>
<p>&lt;/details&gt;</p>
<h4 id="选择批处理大小以最小化资源消耗"><a href="#选择批处理大小以最小化资源消耗" class="headerlink" title="选择批处理大小以最小化资源消耗"></a><strong>选择批处理大小以最小化资源消耗</strong></h4><details><summary><em>[Click to expand]</em></summary>
<br>
- 增加批处理规模会带来两种资源成本:

  1. *前期成本*，例如购买新硬件或重写培训管道以实现多gpu /多tpu培训。

  2. *使用成本*，例如根据团队的资源预算计费，从云提供商计费，电力/维护成本。
- 如果增加批量规模的前期成本很大，那么最好将增加批量规模推迟到项目成熟后，这样更容易评估成本效益权衡。实现多主机并行训练程序可能会引入[bug](#多主机管道的注意事项)和[微妙问题](#Batchnorm实现细节)，因此最好从一个更简单的管道开始。(另一方面，在需要进行大量调优实验的过程早期，训练时间的大幅加速可能非常有益)。
- 我们将总使用成本(可能包括多种不同类型的成本)称为“资源消耗”。我们可以将资源消耗分解为以下几个部分:

<p align="center">资源消耗=(每步资源消耗)x(总步数)</p>

-   增加批量大小通常允许我们[减少总步骤数](#选择批的大小以减少训练时间)。资源消耗是增加还是减少取决于每一步消耗的变化情况。
    -   增加批处理大小可能会减少资源消耗。例如，如果具有较大批处理大小的每个步骤都可以在与较小批处理大小相同的硬件上运行(每个步骤只增加了少量时间)，那么每个步骤所增加的资源消耗可能会被步骤数量的减少所抵消。
    -   增加批处理大小可能不会改变资源消耗。例如，如果批处理大小增加一倍，所需的步骤数减半，使用的gpu数量增加一倍，那么总消耗(以gpu小时为单位)将不会改变。
    -   增加批处理大小可能会增加资源消耗。例如，如果增加批处理大小需要升级硬件，那么每一步消耗的增加可能会超过减少的步骤数。

</details>

<h4 id="更改批处理大小需要重新调优大多数超参数"><a href="#更改批处理大小需要重新调优大多数超参数" class="headerlink" title="更改批处理大小需要重新调优大多数超参数"></a><strong>更改批处理大小需要重新调优大多数超参数</strong></h4><details><summary><em>[Click to expand]</em></summary>
<br>
-   **大多数超参数的最优值对批量大小敏感**。因此，更改批处理大小通常需要重新开始调优过程。
-   与批处理大小相互作用最强烈的超参数是优化器超参数(例如学习率，动量)和正则化超参数，因此对每个批处理大小分别进行调优是最重要的。
-   在项目开始时选择批处理大小时请记住这一点。如果稍后需要切换到不同的批处理大小，为新的批处理大小重新调整所有内容可能会很困难、耗时且昂贵。

</details>

<h4 id="Batchnorm与批量大小如何相互作用"><a href="#Batchnorm与批量大小如何相互作用" class="headerlink" title="Batchnorm与批量大小如何相互作用"></a><strong>Batchnorm与批量大小如何相互作用</strong></h4><details><summary><em>[Click to expand]</em></summary>
<br>
-   批量大小范数比较复杂，通常应该使用不同于梯度计算的批大小来计算统计量。有关详细讨论，请参阅[Batchnorm实现细节](#Batchnorm实现细节)。

</details>

<h3 id="选择初始配置"><a href="#选择初始配置" class="headerlink" title="选择初始配置"></a><strong>选择初始配置</strong></h3><ul>
<li>在开始超参数调优之前，我们必须确定起始点。这包括指定(1)模型配置(例如层数)，(2)优化器超参数(例如学习率)，以及(3)训练步骤的数量。</li>
<li>确定这个初始配置将需要一些手动配置的训练运行和试错。</li>
<li>我们的指导原则是找到一个简单、相对快速、相对低资源消耗的配置，以获得“合理”的结果。<ul>
<li>“简单”是指尽可能避免花哨的装饰;这些都可以在以后添加。即使事后证明这些功能是有用的，在初始配置中添加它们也有浪费时间调整无用功能和/或陷入不必要的复杂性的风险。<ul>
<li>例如，在添加花哨的衰减时间表之前，先从恒定的学习速度开始。</li>
</ul>
</li>
<li>选择一个快速且消耗最少资源的初始配置将使超参数调优更加有效。<ul>
<li>例如，从一个较小的模型开始。</li>
</ul>
</li>
<li>“合理”的性能取决于问题，但至少意味着训练过的模型在验证集上的表现比随机机会要好得多(尽管它可能坏到不值得部署)。</li>
</ul>
</li>
<li>选择训练步数涉及到平衡以下方面:<ul>
<li>一方面，训练更多的步骤可以提高性能，使超参数调优更容易(参见<a href="https://arxiv.org/abs/1811.03600">Shallue et al. 2018</a>)。</li>
<li>另一方面，更少步骤的训练意味着每次训练运行更快，使用更少的资源，通过减少周期之间的时间和允许更多的实验并行运行来提高调优效率。此外，如果一开始选择了一个不必要的大步骤预算，那么在接下来的过程中可能很难改变它，例如，一旦学习率计划针对该步骤数进行了调整。</li>
</ul>
</li>
</ul>
<h2 id="提高模型性能的科学方法"><a href="#提高模型性能的科学方法" class="headerlink" title="提高模型性能的科学方法"></a><strong>提高模型性能的科学方法</strong></h2><p>就本文而言，机器学习开发的最终目标是最大化已部署模型的效用。尽管不同应用程序的开发过程在许多方面有所不同(例如，时间长度、可用的计算资源、模型类型)，但我们通常可以在任何问题上使用相同的基本步骤和原则。</p>
<p>我们的指导原则基于以下假设:</p>
<ul>
<li>已经有一个完全运行的训练流程，以及一个获得合理结果的配置。</li>
<li>有足够的计算资源来进行有意义的调优实验，并并行运行至少几个训练工作。</li>
</ul>
<h3 id="增量调优策略"><a href="#增量调优策略" class="headerlink" title="增量调优策略"></a><strong>增量调优策略</strong></h3><p><strong><em>总结:</em></strong> <em>从一个简单的配置开始，逐步改进，同时建立对问题的洞察力。确保任何改进都是基于强有力的证据，以避免增加不必要的复杂性。</em></p>
<ul>
<li>我们的最终目标是找到一个配置，最大限度地提高我们的模型的性能。<ul>
<li>在某些情况下，我们的目标是在一个固定的截止日期前最大化我们可以改进模型的程度(例如提交给一个比赛)。</li>
<li>在其他情况下，我们希望无限期地不断改进模型(例如，不断改进生产中使用的模型)。</li>
</ul>
</li>
<li>原则上，我们可以通过使用算法自动搜索可能配置的整个空间来最大化性能，但这不是一个实际的选择。<ul>
<li>可能配置的空间非常大，目前还没有任何复杂的算法能够在没有人类引导的情况下有效地搜索这个空间。</li>
</ul>
</li>
<li>大多数自动搜索算法依赖于手工设计的“搜索空间”，该空间定义了要搜索的配置集，而这些搜索空间可能相当重要。</li>
<li>最大化性能的最有效方法是从简单的配置开始，逐步添加功能，并在深入了解问题的同时进行改进。<ul>
<li>我们在每一轮调优中使用自动搜索算法，并随着我们理解的增长不断更新我们的搜索空间。</li>
</ul>
</li>
<li>在探索过程中，我们自然会发现越来越好的配置，因此我们的“最佳”模型将不断改进。<ul>
<li>当我们更新我们的最佳配置时，我们称之为“发布”(这可能与生产模型的实际发布不相对应)。</li>
<li>对于每一次，我们必须确保改变是基于强有力的证据——而不是基于一个幸运配置的随机机会——这样我们就不会给训练流程增加不必要的复杂性。</li>
</ul>
</li>
</ul>
<p>在高层次上，我们的增量调优策略包括重复以下四个步骤:</p>
<ol>
<li>为下一轮实验确定一个适当范围的目标。</li>
<li>设计并运行一组朝着这个目标前进的实验。</li>
<li>从结果中学习我们能学到的东西。</li>
<li>考虑是否启动新的最佳配置。</li>
</ol>
<p>本节的其余部分将更详细地考虑这一策略。</p>
<h3 id="探索vs开发"><a href="#探索vs开发" class="headerlink" title="探索vs开发"></a><strong>探索vs开发</strong></h3><p><strong><em>总结:</em></strong> <em>大多数时候，我们的主要目标是深入了解问题。</em></p>
<ul>
<li>尽管有人可能认为我们会花大部分时间在验证集上试图最大化性能，但在实践中，我们花了大部分时间试图深入了解问题，相对而言，很少有时间过度地关注验证错误。<ul>
<li>换句话说，我们把大部分时间花在了“探索”上，而只花了一小部分时间在“开发”上。</li>
</ul>
</li>
<li>从长远来看，如果我们想要最大化我们的最终表现，理解问题是至关重要的。将洞察力置于短期收益之上可以帮助我们:<ul>
<li>避免因为历史事故而在运行良好的情况下进行不必要的更改。</li>
<li>确定验证错误对哪些超参数最敏感，哪些超参数相互作用最多，因此需要一起重新调优，哪些超参数对其他变化相对不敏感，因此可以在未来的实验中修复。</li>
<li>建议潜在的新功能尝试，如新的正则化，如果过度拟合是一个问题。</li>
<li>识别没有帮助的功能，因此可以删除，降低未来实验的复杂性。</li>
<li>识别何时超参数调整的改进可能已经饱和。</li>
<li>缩小最优值周围的搜索空间，以提高调优效率。</li>
</ul>
</li>
<li>当我们最终准备好时，我们可以纯粹地关注验证错误，即使实验不能最大限度地提供关于调优问题结构的信息。</li>
</ul>
<h3 id="选择下一轮实验的目标"><a href="#选择下一轮实验的目标" class="headerlink" title="选择下一轮实验的目标"></a><strong>选择下一轮实验的目标</strong></h3><p><strong><em>总结:</em></strong> <em>每一轮实验都应该有一个明确的目标，并且范围要足够窄，使实验能够朝着目标实际取得进展。</em></p>
<ul>
<li>每一轮实验都应该有一个明确的目标，范围要足够窄，这样实验才能朝着目标前进:如果我们试图同时添加多个功能或回答多个问题，我们可能无法理清对结果的单独影响。</li>
<li>目标示例包括:<ul>
<li>尝试对流程进行潜在的改进(例如，一个新的正则化器，预处理选择等)。</li>
<li>理解特定模型超参数的影响(例如激活函数)</li>
<li>过度地最大化验证错误。</li>
</ul>
</li>
</ul>
<h3 id="设计下一轮实验"><a href="#设计下一轮实验" class="headerlink" title="设计下一轮实验"></a><strong>设计下一轮实验</strong></h3><p><strong><em>总结:</em></strong> <em>确定哪些超参数是科学的，冗余的以及实验目标的固定超参数。创建一系列的研究来比较科学超参数的不同值，同时优化多余超参数。选择冗余超参数的搜索空间，以平衡资源成本和科学价值。</em></p>
<h4 id="识别科学的、冗余的和固定的超参数"><a href="#识别科学的、冗余的和固定的超参数" class="headerlink" title="识别科学的、冗余的和固定的超参数"></a><strong>识别科学的、冗余的和固定的超参数</strong></h4><details><summary><em>[Click to expand]</em></summary>

<br>

-   对于给定的目标，所有超参数将是**科学超参数**、**冗余超参数**或**固定超参数**。
    -   科学超参数是那些我们试图测量的对模型性能的影响。
    -   冗余的超参数是那些为了公平比较科学超参数的不同值而需要优化的超参数。这类似于[妨害参数](https://en.wikipedia.org/wiki/Nuisance_parameter)的统计概念。
    -   固定超参数将在本轮实验中固定其值。在比较科学超参数的不同值时，这些超参数的值不需要(或者我们不希望)改变。
        -   通过固定一组实验的某些超参数，我们必须接受从实验中得出的结论可能对固定超参数的其他设置无效。换句话说，固定超参数会对我们从实验中得出的任何结论产生警告。.
-   例如，如果我们的目标是“确定具有更多隐藏层的模型是否会减少验证错误”，那么隐藏层的数量就是一个科学的超参数。
    -   如果学习率为每个层数分别调整(最佳学习率通常取决于模型架构)，学习率是一个冗余的超参数，因为我们只能公平地比较具有不同隐藏层数的模型。
    -   激活函数可以是一个固定的超参数，如果我们在之前的实验中确定了激活函数的最佳选择对模型深度不敏感，或者如果我们愿意限制我们关于隐藏层数的结论，只覆盖这个特定的激活函数选择。或者，如果我们准备为每个隐藏层的数量分别调优它，它可能是一个冗余的参数。
-   一个特定的超参数是科学超参数、冗余超参数还是固定超参数不是超参数固有的，而是根据实验目标而变化。
    -   例如，激活函数的选择可以是一个科学的超参数(对于我们的问题，ReLU或tanh是更好的选择吗?)，一个冗余的超参数(当我们允许几个不同的可能的激活函数时，最好的5层模型比最好的6层模型更好吗?)，或者一个固定的超参数(对于ReLU网络，在特定位置添加批量归一化是否有帮助?)
-   在设计新一轮实验时，我们首先确定实验目标的科学超参数。
    -   在这个阶段，我们认为所有其他超参数都是冗余超参数。
-   接下来，我们将一些冗余的超参数转换为固定的超参数。
    -   有了无限的资源，我们会把所有非科学的超参数都当作冗余参数，这样我们从实验中得出的结论就不会受到固定超参数值的限制。
    -   然而，我们试图调优的超参数越多，我们在每次设置科学超参数时无法充分调优的风险就越大，最终从实验中得出错误的结论。
        -   正如[下面](#在更多实验和有限资源之间取得平衡)所描述的，我们可以通过增加计算预算来应对这种风险，但通常我们的最大资源预算小于调优所有非科学超参数所需的资源。.
    -   我们选择将一个冗余的超参数转换为一个固定的超参数，根据我们的判断，修复它所带来的警告比将它作为一个冗余的超参数所带来的成本要小。
        -   给定的冗余超参数与科学超参数的交互作用越多，确定其值的破坏性就越大。例如，权值衰减强度的最佳值通常取决于模型大小，因此比较不同的模型大小假设一个单一的权值衰减将不是很好。
-   尽管我们分配给每个超参数的类型取决于实验目标，但对于某些类别的超参数，我们有以下经验法则:
    -   在各种优化器超参数(例如学习率，动量，学习率计划参数，Adam beta等)中，至少有一些是冗余参数，因为它们倾向于与其他变化交互。
        -   它们很少是科学的超参数，因为像“当前的最佳学习率是多少?”这样的目标并不能提供太多的洞见——无论如何，最佳设置很容易随着下一个处理变化而改变。
        -   虽然我们可能会由于资源限制或当我们有特别有力的证据表明它们不与科学参数相互作用时偶尔修复其中的一些，但我们通常应该假设优化器超参数必须单独调优，以在不同的科学超参数设置之间进行公平的比较，因此不应该被修复。
            -   此外，我们没有“先验”的理由选择一个优化超参数值而不是另一个(例如，它们通常不会以任何方式影响前向传递或梯度的计算成本)。
    -   相比之下，优化器的*选择*通常是一个科学超参数或固定超参数。
        -   如果我们的实验目标是在两个或多个不同的优化器之间进行公平的比较，那么它就是一个科学超参数。“确定哪个优化器在给定数量的步骤中产生的验证错误最低”)。
        -   或者，我们可能出于多种原因使其成为一个固定的超参数，包括:(1)先前的实验使我们相信针对我们的问题的最佳优化器对当前的科学超参数不敏感;(2)我们更喜欢使用这个优化器来比较科学超参数的值，因为它的训练曲线更容易推理;(3)我们更喜欢使用这个优化器，因为它比替代方案使用更少的内存。
    -   由正则化技术引入的超参数通常是冗余的超参数，但无论我们是否包含正则化技术都是一个科学的或固定的超参数。
        -   例如，dropout会增加代码复杂度，所以当决定是否包含它时，我们会把“no dropout”和“dropout”作为一个科学超参数，而把dropout率作为一个冗余的超参数。
            -   如果我们决定在这个实验的基础上添加dropout到我们的管道中，那么dropout率将是未来实验中一个冗余的超参数。
    -   架构超参数通常是科学的或固定的超参数，因为架构更改会影响服务和训练成本、延迟和内存需求。
        -   例如，层数通常是一个科学的或固定的超参数，因为它往往对训练速度和内存使用有显著的影响。
-   在某些情况下，冗余超参数集和固定超参数集将取决于科学超参数的值。
    -   例如，假设我们试图确定哪个优化器的Nesterov动量和Adam结果的验证误差最小。科学超参数是`优化器`，它接受值`{"Nesterov_momentum"， "Adam"}`。值`optimizer="Nesterov_momentum`引入了冗余/固定的超参数`{learning_rate, momentum}`，但值`optimizer="Adam"`引入了冗余/固定的超参数`{learning_rate, beta1, beta2, epsilon}`。
    -   只存在于科学超参数的某些值的超参数称为**条件超参数**。
    -   我们不应该仅仅因为两个条件超形参有相同的名称就假定它们是相同的!在上面的例子中，名为`learning_rate`的条件超参数对于`optimizer="Nesterov_momentum"`和`optimizer="Adam"`是一个不同的超参数。它在两种算法中的作用相似(尽管不完全相同)，但是在每个优化器中工作良好的值范围通常有几个数量级的差异。

</details>

<h4 id="创建一系列的研究"><a href="#创建一系列的研究" class="headerlink" title="创建一系列的研究"></a><strong>创建一系列的研究</strong></h4><details><summary><em>[Click to expand]</em></summary>
<br>
- 一旦我们确定了科学的和冗余的超参数，我们设计一个“研究”或一系列的研究，以朝着实验目标前进。
  -   研究指定一组超参数配置，用于后续分析。每个配置被称为“试验”。
  -   创建一项研究通常包括选择在不同试验中不同的超参数，选择这些超参数可以取什么值(“搜索空间”)，选择试验的数量，并选择一个自动搜索算法从搜索空间中采样这些试验。或者，我们可以通过手动指定超参数配置集来创建一个研究。
- 研究的目的是使用不同的科学超参数值运行管道，同时**“优化掉”**冗余的超参数，以便在不同的科学超参数值之间进行尽可能公平的比较。
-   在最简单的情况下，我们会对科学参数的每个配置进行单独的研究，其中每个研究都会对冗余的超参数进行调整。

    -   例如，如果我们的目标是从Nesterov动量和Adam中选择最好的优化器，我们可以创建一个研究`optimizer="Nesterov_momentum"`和冗余的超参数是 `{learning_rate, momentum}` ，而另一项研究中 `optimizer="Adam"`和冗余的超参数是`{learning_rate, beta1, beta2, epsilon}` 。我们将通过从每个研究中选择性能最好的试验来比较两种优化器。

    -   我们可以使用任何无梯度优化算法，包括贝叶斯优化或进化算法等方法来优化冗余的超参数，尽管[我们更喜欢](#why-use-quasi-random-search-instead-of-more-sophisticated-black-box-optimization-algorithms-during-the-exploration-phase-of-tuning)在优化的[开发阶段](#exploration-vs-exploitation)使用准随机搜索，因为它在这种设置中具有各种优势。[开发结束后](#after-exploration-concludes)，如果有最先进的贝叶斯优化软件，这是我们的首选。
-   在更复杂的情况下，我们想要比较大量的科学超参数的值，并且进行许多独立的研究是不切实际的，我们可以将科学参数与冗余超参数包含在同一个搜索空间中，并使用搜索算法在单个研究中对*科学超参数和*冗余超参数的值进行采样。
    -   当采用这种方法时，条件超参数可能会导致问题，因为很难指定搜索空间，除非冗余超参数集对于科学超参数的所有值是相同的。
    -   在这种情况下，[我们的偏好](#为什么在调优的探索阶段使用准随机搜索而不是更复杂的黑盒优化算法?)使用准随机搜索比花哨的黑盒优化工具更强，因为它确保我们获得相对统一的科学超参数值采样。不管搜索算法是什么，我们都需要确保它能以某种方式统一地搜索科学参数。

</details>

<h4 id="在更多实验和有限资源之间取得平衡"><a href="#在更多实验和有限资源之间取得平衡" class="headerlink" title="在更多实验和有限资源之间取得平衡"></a><strong>在更多实验和有限资源之间取得平衡</strong></h4><details><summary><em>[Click to expand]</em></summary>
<br>


-   在设计一项研究或一系列研究时，我们需要分配有限的预算，以充分实现以下三个目标:
    1.    比较足够多的不同科学超参数值。
    2.  在足够大的搜索空间内调优冗余的超参数。
    3.  对冗余超参数的搜索空间进行足够密集的采样。
-   我们越能更好地实现这三个愿望，我们就越能从实验中获得更多的见解。
    -   比较尽可能多的科学超参数值拓宽了我们从实验中获得的见解的范围。
    -   包括尽可能多的冗余超参数，并允许每个冗余超参数在尽可能宽的范围内变化，这增加了我们的信心，即在科学超参数的每个配置的搜索空间中存在冗余超参数的“好”值。
        -   否则，我们可能会在科学超参数的值之间进行不公平的比较，因为我们没有搜索冗余参数空间的可能区域，在这些区域中，一些科学参数的值可能存在更好的值。
    -   尽可能密集地对冗余超参数的搜索空间进行采样，增加了我们的信心，即搜索过程将发现恰好存在于搜索空间中的冗余超参数的任何良好设置。
        -   否则，我们可能会在科学参数的值之间进行不公平的比较，因为一些值随着冗余的超参数的采样而变得更幸运。
-   不幸的是，这三个维度中的任何一个维度的改进都需要增加试验次数，从而增加资源成本，或者找到一种方法来节省其他维度中的资源。
    -   每个问题都有自己的特点和计算限制，所以如何在这三个需求中分配资源需要一定程度的领域知识。
    -   在进行一项研究后，我们总是试图了解该研究是否足够好地调整了冗余的超参数(即搜索了足够大的空间)，以公平地比较科学的超参数(如更详细的描述[下面](# 从实验结果中提取见解))。

</details>

<h3 id="从实验结果中提取见解"><a href="#从实验结果中提取见解" class="headerlink" title="从实验结果中提取见解"></a>从实验结果中提取见解</h3><p><strong><em>总结:</em></strong> <em>除了努力实现每组实验的原始科学目标外，还要检查附加问题的清单，如果发现问题，修改实验并重新运行</em></p>
<ul>
<li><p>最终，每组实验都有一个特定的目标，我们想要评估实验提供的朝着这个目标的证据。</p>
<ul>
<li>然而，如果我们提出正确的问题，我们经常会发现需要纠正的问题，然后一组给定的实验才能朝着最初的目标取得很大进展。<ul>
<li>如果不问这些问题，就可能得出错误的结论。</li>
</ul>
</li>
<li>由于运行实验可能是昂贵的，我们也想借此机会从每组实验中提取其他有用的见解，即使这些见解与当前目标没有直接关系。</li>
</ul>
</li>
<li><p>-在分析一组给定的实验以朝着最初的目标前进之前，我们应该问自己以下额外的问题:</p>
<ul>
<li><a href="# 识别错误的搜索空间边界">搜索空间够大吗?</a><ul>
<li>如果研究中的最佳点在一个或多个维度的搜索空间边界附近，则搜索可能不够宽。在这种情况下，我们应该进行另一项研究，扩大搜索空间。</li>
</ul>
</li>
<li><a href="#在搜索空间中没有采样足够多的点">我们从搜索空间中采样了足够多的点吗?</a><ul>
<li>如果不是，请运行更多的点，或者在调优目标中不要太雄心勃勃。</li>
</ul>
</li>
<li><p>每项研究中<strong>不可行的试验有多少比例</strong>(即试验偏离，得到非常糟糕的损失值，或因为违反了一些隐含的约束而根本无法运行)?</p>
<ul>
<li><p>当一项研究中有很大一部分点是<strong>不可行的</strong>，我们应该尝试调整搜索空间以避免这样的采样点，这有时需要重新参数化搜索空间。</p>
</li>
<li><p>在某些情况下，大量的不可行点可能表明训练代码中的bug。</p>
</li>
</ul>
</li>
<li><a href="#如何调试和缓解优化失败">模型是否存在优化问题?</a></li>
<li><a href="#检查训练曲线">我们能从最佳试验的训练曲线中学到什么?</a><ul>
<li>例如，最佳试验的训练曲线是否与有问题的过拟合一致?</li>
</ul>
</li>
</ul>
</li>
<li>如有必要，根据上述问题的答案，改进最近的研究(或研究组)，以改善搜索空间和/或抽样更多试验，或采取其他纠正措施。</li>
<li>一旦我们回答了上述问题，我们就可以继续评估实验提供的证据，以实现我们的原始目标(例如，<a href="#检测有隔离的变化图是否有用">评估一个变化是否有用</a>)。</li>
</ul>
<h4 id="识别错误的搜索空间边界"><a href="#识别错误的搜索空间边界" class="headerlink" title="识别错误的搜索空间边界"></a>识别错误的搜索空间边界</h4><details><summary><em>[Click to expand]</em></summary>
<br>


-   如果一个搜索空间的最佳采样点接近它的边界，则该搜索空间是可疑的。如果我们把搜索范围扩大到那个方向也许能找到更好的点。
-   为了检查搜索空间边界，我们喜欢在我们所谓的**基本超参数轴图**上绘制完成的试验，其中我们绘制验证目标值与其中一个超参数(例如学习率)的关系。图上的每个点都对应一次试验。
    -   每次试验的验证目标值通常应是在训练过程中所达到的最佳值。

<p align="center" id="figure-1">
<img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/bad_search_space.png" width="49%" alt="Example of bad search space boundaries">
<img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/good_search_space.png" width="49%" alt="Example of good search space boundaries">
</p>
<p align="center"><b>图1:</b>糟糕搜索空间边界和可接受搜索空间边界的示例。</p>

- [图1](# Figure -1)中的图显示了错误率(越低越好)与初始学习率的关系。
- 如果最佳观察点聚集在搜索空间的边缘(在某些维度上)，则搜索空间的边界可能需要扩展，直到最佳观察点不再靠近边界。
- 通常，一项研究将包括“不可行”的试验，这些试验偏离或得到非常糟糕的结果(在上面的图中用红色x标记)。

  -   如果所有试验对于学习率大于某个阈值都是不可行的，并且如果表现最好的试验具有学习率在该区域的边缘，模型[可能会受到稳定性问题的影响，从而无法获得更高的学习率](#如何调试和缓解优化失败)。


</details>

<h4 id="在搜索空间中没有采样足够多的点"><a href="#在搜索空间中没有采样足够多的点" class="headerlink" title="在搜索空间中没有采样足够多的点"></a>在搜索空间中没有采样足够多的点</h4><details><summary><em>[Click to expand]</em></summary>
<br>


-   一般来说，[很难知道](#准随机搜索需要多少次试验才能得到好的结果?)如果搜索空间的采样足够密集。🤖
-   运行更多的试验当然更好，但代价很明显。
-   因为很难知道我们什么时候已经采样了足够多，我们通常会采样我们能承受的范围，并试图通过反复查看各种超参数轴图来校准我们的直觉信心，并试图获得搜索空间的“好”区域中有多少点。

</details>

<h4 id="检查训练曲线"><a href="#检查训练曲线" class="headerlink" title="检查训练曲线"></a>检查训练曲线</h4><details><summary><em>[Click to expand]</em></summary>
<br>

***总结:*** *检查训练曲线是识别常见故障模式的简单方法，可以帮助我们优先考虑下一步采取什么行动。*

-   虽然在许多情况下，我们实验的主要目标只需要考虑每次试验的验证误差，但在将每次试验减少到一个数字时，我们必须小心，因为它可能隐藏了表面之下发生的事情的重要细节。
-   对于每一项研究，我们总是查看至少最好的几次试验的**训练曲线**(训练误差和验证误差在训练期间与训练步骤的关系)。
-   即使这不是解决主要实验目标所必需的，检查训练曲线是确定常见故障模式的简单方法，并可以帮助我们优先考虑下一步采取的行动。
-   在检查训练曲线时，我们对以下问题感兴趣。
-   是否有任何试验表现出**有问题的过拟合?**
    -   当验证错误在训练过程中的某个时间点开始“增加”时，就会出现问题过拟合。
    -   在实验设置中，我们通过为每个科学超参数设置选择“最佳”试验来优化恼人的超参数，我们应该检查与我们正在比较的科学超参数设置对应的*至少*每个最佳试验中是否存在问题过拟合。
        -   如果任何最佳试验显示出有问题的过拟合，我们通常希望在比较科学超参数的值之前，使用额外的正则化技术重新运行实验和/或更好地调整现有的正则化参数。
            -   如果科学超参数包括正则化参数，这可能不适用，因为如果这些正则化参数的低强度设置导致有问题的过拟合也就不足为奇了。
        -   减少过拟合通常是简单的，使用常见的正则化技术，添加最小的代码复杂性或额外的计算(例如，dropout，标签平滑，权重衰减)，所以在下一轮实验中添加一个或多个这些通常不是什么大问题。
        -   例如，如果科学超参数是“隐藏层数”，而使用最大隐藏层数的最佳试验显示出有问题的过拟合，那么我们通常更愿意用额外的正则化再次尝试，而不是立即选择较小数量的隐藏层。
        -   即使没有一个“最佳”试验表现出有问题的过拟合，如果它发生在*任何*个试验中，仍然可能是一个问题。
            -   选择最佳试验抑制了表现出有问题的过拟合的配置，并倾向于那些没有过拟合的配置。换句话说，它将倾向于更正则化的配置
            -   然而，任何让训练变得更糟的东西都可以作为一个规则，即使它不是故意的。例如，选择较小的学习率可以通过阻碍优化过程来正则化训练，但我们通常不希望以这种方式选择学习率。
            -   因此，我们必须意识到，科学超参数的每一种设置的“最佳”试验可能是以有利于某些科学超参数或讨厌超参数的“坏”值的方式选择的。
-   在训练中是否存在较高的步间差异或训练后期的验证错误?
    -   如果是这样，这可能会干扰我们比较不同科学超参数值的能力(因为每次试验随机结束于“幸运”或“不幸”步骤)，以及我们在生产中再现最佳试验结果的能力(因为生产模型可能不会像研究中那样结束于相同的“幸运”步骤)。
    -   step- step- step方差最可能的原因是批次方差(从每批训练集中随机抽样样本)，小的验证集，以及在训练后期使用过高的学习率。
    -   可能的补救措施包括增加批大小，获得更多的验证数据，使用学习率衰减，或使用**Polyak平均**。
-   训练结束后，还在提升?
    -   如果是这样，这表明我们处于[“计算约束”状态](#确定每次训练的步数)，我们可能会从[增加训练步数](#当训练受计算限制时，决定训练多长时间)或改变学习率计划中受益。
-   在最后的训练步骤之前，训练和验证集的性能是否已经饱和?
    -   如果是这样，这表明我们处于[“不受计算限制”](#确定每次训练的步数)制度中，并且我们可能能够[减少训练步数](当训练*不* 受计算限制时，决定训练多长时间)。
-   虽然我们无法一一列举，但通过检查训练曲线，可以明显地发现许多其他行为(例如，训练期间训练损失*增加*通常表明训练管道中存在错误)。

</details>

<h4 id="检测有隔离的变化图是否有用"><a href="#检测有隔离的变化图是否有用" class="headerlink" title="检测有隔离的变化图是否有用"></a>检测有隔离的变化图是否有用</h4><details><summary><em>[Click to expand]</em></summary>

<br>

<p align="center" id="figure-2">
<img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/isolation_plot.png" width="49%" alt="Isolation plot that investigates the best value of weight decay for ResNet-50
trained on ImageNet.">
</p>


<p align="center"><b>Figure 2:</b> 研究在ImageNet上训练的ResNet-50的权重衰减的最佳值的隔离图。</p>

-   通常，一组实验的目标是比较科学超参数的不同值。
    -   例如，我们可能想要确定导致最佳验证错误的权重衰减值。
-   **隔离图**是基本超参数轴图的一种特殊情况。隔离图上的每个点对应于**最佳试验**在一些(或全部)有害超参数上的性能。
    -   换句话说，我们在“优化掉”讨厌的超参数后绘制模型性能。
-   隔离图可以更容易地在科学超参数的不同值之间进行比较。
-   例如，[图2](# Figure 2)揭示了在ImageNet上训练的ResNet-50的特定配置产生最佳验证性能的权重衰减值。
    -   如果我们的目标是确定是否包含权重衰减，那么我们会将该图中的最佳点与没有权重衰减的基线进行比较。为了进行公平的比较，基线还应该对其学习率进行同样良好的调整。
-   当我们有由(准)随机搜索生成的数据，并考虑隔离图的连续超参数时，我们可以通过将基本超参数轴图的x轴值装入桶，并在桶定义的每个垂直切片中进行最佳试验来近似隔离图。

</details>

<h4 id="自动化生成常用的图"><a href="#自动化生成常用的图" class="headerlink" title="自动化生成常用的图"></a>自动化生成常用的图</h4><details><summary><em>[Click to expand]</em></summary>
<br>

-   生成图的努力越多，我们就越不可能尽可能多地查看它们，所以我们有必要设置我们的基础设施来自动生成尽可能多的图。
-   至少，我们会自动为实验中变化的所有超参数生成基本超参数坐标轴图。
-   此外，我们自动生成所有试验的训练曲线，并尽可能容易地找到每个研究中最好的几个试验，并检查它们的训练曲线。
-   我们可以添加许多其他有用的潜在情节和可视化效果。虽然上面描述的是一个很好的起点，但套用Geoffrey Hinton的话，“每次你策划一些新东西，你就会学到一些新东西。”

</details>

<h3 id="决定是采用改变训练流程还是超参数配置"><a href="#决定是采用改变训练流程还是超参数配置" class="headerlink" title="决定是采用改变训练流程还是超参数配置"></a>决定是采用改变训练流程还是超参数配置</h3><p><strong>摘要:</strong> <em>当决定是否对我们的模型或训练过程进行更改或采用新的超参数配置时，我们需要了解结果中的不同变化来源。</em></p>
<ul>
<li>当我们试图改进模型时，我们可能会观察到，与现有配置相比，特定的候选更改最初实现了更好的验证误差，但在重复实验后，发现没有一致的优势。非正式地，我们可以将可能导致这种不一致结果的最重要的变化来源分为以下大类:<ul>
<li><strong>训练过程方差</strong>、<strong>再训练方差</strong>或<strong>试验方差</strong>:我们看到的使用相同超参数但不同随机种子的训练运行之间的差异。<ul>
<li>例如，不同的随机初始化、训练数据顺序、dropout mask、数据增强操作的模式和并行算术操作的顺序，都是试变的潜在来源。</li>
</ul>
</li>
<li><strong>超参数搜索方差</strong>，或<strong>学习方差</strong>:由我们选择超参数的过程引起的结果变化。<ul>
<li>例如，我们可能对特定的搜索空间运行相同的实验，但使用两种不同的种子进行准随机搜索，并最终选择不同的超参数值。</li>
</ul>
</li>
<li><strong>数据收集和采样方差</strong>:任何类型的随机划分为训练数据、验证数据和测试数据的方差，或者更一般地说，由于训练数据生成过程产生的方差。</li>
</ul>
</li>
<li>使用严格的统计测试比较有限验证集上估计的验证错误率是很好的，但通常仅试方差就可以在使用相同超参数设置的两个不同训练模型之间产生统计上显著的差异。</li>
<li>当我们试图做出超出超参数空间中单个点的水平的结论时，我们最关心的是研究方差。<ul>
<li>研究方差取决于试验的数量和搜索空间，我们已经看到了它大于试验方差的情况，也有比试验方差小得多的情况。</li>
</ul>
</li>
<li>因此，在采用候选变化之前，考虑进行N次最佳试验，以描述试验之间的差异。<ul>
<li>通常，我们可以在流程发生重大变化后重新描述试验方差，但在某些应用程序中，我们可能需要更新的估计。</li>
<li>在其他应用中，表征试验方差的代价太大，不值得。</li>
</ul>
</li>
<li>最后，尽管我们只想采用能够产生真正改进的更改(包括新的超参数配置)，但要求完全确定有什么东西可以帮助也不是正确的答案。</li>
<li>因此，如果一个新的超参数点(或其他变化)得到了比基线更好的结果(尽可能考虑到新点和基线的再训练方差)，那么我们可能应该采用它作为未来比较的新基线。<ul>
<li>然而，我们应该只采用那些能带来改进的更改，这些改进会超过它们增加的复杂性。</li>
</ul>
</li>
</ul>
<h3 id="探索后总结"><a href="#探索后总结" class="headerlink" title="探索后总结"></a>探索后总结</h3><p><strong>摘要:</strong> <em>一旦我们完成了对良好搜索空间的探索，并决定了应该调整哪些超参数，贝叶斯优化工具是一个令人瞩目的选择。</em></p>
<ul>
<li>在某些时候，我们的优先级将从学习更多关于调优问题的内容，转移到生成用于启动或其他用途的最佳配置。</li>
<li>此时，应该有一个精确的搜索空间，其中舒适地包含最佳观察试验周围的局部区域，并已进行充分的采样。</li>
<li>我们的探索工作应该揭示了要调优的最基本的超参数(以及它们的合理范围)，我们可以使用尽可能大的调优预算来构建一个搜索空间，以进行最终的自动调优研究。</li>
<li>由于我们不再关心最大化我们对调优问题的洞察力，许多<a href="#为什么在调优的探索阶段使用准随机搜索而不是更复杂的黑盒优化算法">准随机搜索的优势</a>不再适用，应该使用贝叶斯优化工具自动找到最佳超参数配置。<ul>
<li>如果搜索空间包含大量的发散点(得到NaN训练损失甚至训练损失比均值差许多标准偏差的点)，那么使用黑盒优化工具来正确处理发散的试验是很重要的(请参阅<a href="https://arxiv.org/abs/1403.5607">带有未知约束的贝叶斯优化</a>以获得处理此问题的优秀方法)。</li>
</ul>
</li>
<li>在这一点上，我们还应该考虑检查测试集的性能。<ul>
<li>原则上，我们甚至可以将验证集折叠到训练集中，并重新训练使用贝叶斯优化找到的最佳配置。然而，这只适用于将来不会有这种特定工作负载的启动(例如，一次性的Kaggle竞赛)。</li>
</ul>
</li>
</ul>
<h2 id="确定每次训练的步数"><a href="#确定每次训练的步数" class="headerlink" title="确定每次训练的步数"></a>确定每次训练的步数</h2><ul>
<li>有两种workloads工作负载:计算密集型和非计算密集型。</li>
<li>当训练是<strong>计算约束</strong>时，训练受限于我们愿意等待的时间，而不是我们有多少训练数据或其他一些因素。<ul>
<li>在这种情况下，如果我们可以以某种方式更长或更有效地训练，我们应该看到更低的训练损失，并且通过适当的调优，改进的验证损失。</li>
<li>换句话说，<strong>加速</strong>训练等同于<strong>改善</strong>训练，而“最佳”训练时间总是“在我们负担得起的情况下”。</li>
<li>也就是说，仅仅因为工作负载是计算有限的，并不意味着更长/更快的训练是提高结果的唯一方法。</li>
</ul>
</li>
<li>当训练<strong>不受计算限制</strong>时，我们可以想训练多长时间就训练多长时间，并且在某种程度上，训练更长时间并没有太大帮助(甚至会导致问题过度拟合)。<ul>
<li>在这种情况下，我们应该期望能够训练到非常低的训练损失，直到训练时间更长可能会略微减少训练损失，但不会有意意义地减少验证损失。</li>
<li>特别是当训练不受计算限制时，更慷慨的训练时间预算可以使调优更容易，特别是在调整学习率衰减表时，因为它们与训练预算有特别强的交互作用。<ul>
<li>换句话说，非常吝啬的训练时间预算可能需要一个调整到完美的学习率衰减计划，以实现良好的错误率。</li>
</ul>
</li>
</ul>
</li>
<li>无论给定的工作负载是否受计算限制，增加梯度方差(跨批次)的方法通常会导致训练进度变慢，因此可能会增加达到特定验证损失所需的训练步骤数量。高梯度方差可能由以下原因造成:<ul>
<li>使用较小的批量大小</li>
<li>增加数据扩充</li>
<li>添加一些类型的正则化(例如dropout)</li>
</ul>
</li>
</ul>
<h3 id="当训练不-受计算限制时，决定训练多长时间"><a href="#当训练不-受计算限制时，决定训练多长时间" class="headerlink" title="当训练不 受计算限制时，决定训练多长时间"></a>当训练<em>不</em> 受计算限制时，决定训练多长时间</h3><ul>
<li>我们的主要目标是确保我们的训练时间足够长，以使模型达到最佳的可能结果，同时避免在训练步骤数量上过度浪费。</li>
<li>当有疑问时，宁可训练得更久。假设正确地使用回溯(最佳)检查点选择，并且检查点足够频繁，那么当训练时间更长时，性能永远不会下降。</li>
<li>永远不要在研究中调整<code>max_train_steps</code>数字。选择一个值并将其用于所有试验。从这些试验中，绘制回溯检查点选择找到的训练步骤，以改进<code>max_train_steps</code>的选择。<ul>
<li>例如，如果最好的步数总是在训练的前10%，那么最大步数就太高了。</li>
<li>或者，如果最佳步骤在训练的最后25%中始终如一，我们可能会从更长时间的训练和重新调整衰减表中受益。</li>
</ul>
</li>
<li>当架构或数据发生变化(例如添加数据增强)时，理想的训练步数可能会发生变化。</li>
<li>下面我们将描述如何根据使用恒定学习率“完美拟合”训练集所需的步数为<code>max_train_steps</code>选择初始候选值。<ul>
<li>注意，我们并没有以精确或数学定义良好的方式使用“完美拟合训练集”这个短语。它只是作为一种非正式的描述符，表示非常低的训练损失。<ul>
<li>例如，当使用缺失正则化项的对数损失进行训练时，随着网络权重无限制地增长，模型对训练集的预测变得越来越有信心，我们可能会看到训练损失持续缓慢地改善，直到达到浮点极限。在这种情况下，我们可以说模型在训练集上的错误分类误差达到零的时候“完美拟合”了训练集。</li>
</ul>
</li>
<li>如果训练过程中的梯度噪声量增加，我们发现<code>max_train_steps</code>的初始值可能需要增加。<ul>
<li>例如，如果在模型中引入数据增强或dropout等正则化方法。</li>
</ul>
</li>
<li>如果训练过程有所改善，则可以降低<code>max_train_steps</code>。<ul>
<li>例如，使用更好的优化器或更好的学习率调度。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="使用学习率扫描为max-train-steps选择初始候选的算法"><a href="#使用学习率扫描为max-train-steps选择初始候选的算法" class="headerlink" title="使用学习率扫描为max_train_steps选择初始候选的算法"></a>使用学习率扫描为max_train_steps选择初始候选的算法</h4><details><summary><em>[Click to expand]</em></summary>
<br>

-   这个过程假设不仅可以“完美”拟合训练集，而且可以使用恒定的学习率计划来实现。
-   如果可以完美拟合整个训练集，那么必须存在一个完美拟合训练集的配置(某些值为`max_train_steps`);找到任何这样的配置，并使用其`max_train_steps`的值作为起点`N`。
-   运行一个恒定的学习率sweep扫描(即网格搜索学习率)，而不进行数据增强和正则化，其中每个试验都为`N`步进行训练。
-   为了达到完美的训练性能，最快的测试所需的步数是我们对`max_train_steps`的初步猜测。
-   **注意:**糟糕的搜索空间可能会导致自我欺骗。
    -   例如，如果在一项研究中所有的学习率都太小，我们可能会错误地得出结论，认为需要一个非常大的值`max_train_steps`。
    -   至少，我们应该检查学习中的最佳学习率是否不在搜索空间的边界上。

</details>

<h3 id="当训练受计算限制时，决定训练多长时间"><a href="#当训练受计算限制时，决定训练多长时间" class="headerlink" title="当训练受计算限制时，决定训练多长时间"></a>当训练受计算限制时，决定训练多长时间</h3><ul>
<li>在某些情况下，训练损失无限期地提高，我们的耐心和计算资源成为限制因素。</li>
<li>如果训练损失(甚至验证损失)不断提高，我们是否应该一直训练到我们负担得起?不一定。<ul>
<li>通过运行大量较短的实验，并为我们希望推出的模型保留最长的“生产长度”运行，我们可能能够更有效地调整。</li>
<li>随着试验的训练时间接近我们的耐心极限，优化实验与我们的潜在发布候选人变得更加相关，但我们可以完成的实验更少。</li>
<li>虽然我们仅对生产长度的~10%进行训练，但可能有很多问题可以回答，但总有风险，我们在这个时间限制下的结论不适用于生产长度的20%的实验，更不用说100%的实验。</li>
</ul>
</li>
<li>通过增加每次训练的步长限制进行多轮调整是一种明智的方法。<ul>
<li>我们可以按自己的想法做多少轮，但通常1-3轮是最实用的。</li>
<li>本质上，尝试使用具有非常快的周转时间的试验来获得尽可能多的问题理解，权衡调优的彻底性与最终的、最长的运行的相关性。</li>
<li>一旦给定的每次试验时间限制产生了有用的见解，就可以增加训练时间并继续调优，根据需要再次检查较短运行的结论。</li>
</ul>
</li>
<li>首先，我们推荐两轮调优:<ul>
<li>第1轮:用更短的时间找到好的模型和优化器超参数。</li>
<li>第2轮:在较少的好的超参数上的长时间运行来获得最终模型。</li>
</ul>
</li>
<li>最大的问题来自<code>Round i</code>&rarr;<code>Round i+1</code>是如何调整学习率衰减时间表。<ul>
<li>在两轮之间调整学习率时间表时，一个常见的陷阱是使用学习率过小的所有额外训练步骤。</li>
</ul>
</li>
</ul>
<h4 id="第1轮"><a href="#第1轮" class="headerlink" title="第1轮"></a>第1轮</h4><details><summary><em>[Click to expand]</em></summary>
<br>

-   不幸的是，短的轮次不能保证找到好的超参数，当训练长度显著增加时，不完整的训练仍然是很好的选择。然而，对于某些类型的超参数，它们之间的相关性通常足以使第1轮有用。
-   在短期训练中发现的超参数值我们希望转移到长期训练中?对于所有这些，我们需要更多的研究。但根据我们目前所知，作者的猜测是这样的:
    -   很有可能能转移的
        -   早期训练不稳定可以在第一轮调优中使用更少的训练步骤来解决。也许这些超参数是我们拥有的最接近可靠的转移。
            -   Warmup 轮次
            -   初始化
    -   可能能转移的
        -   模型架构-在模型架构中的特殊的方法通常能够转移，但可能有许多反例。
    -   大概能转移的
        -   优化算法/优化器超参数-我们认为这将“轻松的”迁移。它肯定比上面的东西弱。
        -   数据增强
        -   正则化
            -   如果不能完美拟合训练集，那么模型可能处于正则化帮助不大的状态。
    -   不太可能转移的
        -   学习率时间表:不太可能完美迁移。
            -   [这篇论文](https://arxiv.org/abs/2203.15556)表明，即使是衰减时间表转移，但我们认为一般情况下这不是真的。示例:在训练步骤的小#上调整根号衰减，然后扩展到大#，将导致大多数训练发生在过小的步骤上。
                -   在极限训练预算的限制下，人们可能对大多数时间表都做得“足够好”，但如果调整，可能会看到明显的性能改善。
            -   [理解随机元优化中的短期偏差](https://arxiv.org/abs/1803.02021)描述了试图短视地选择学习率的危险。

</details>

<h4 id="第2轮"><a href="#第2轮" class="headerlink" title="第2轮"></a>第2轮</h4><details><summary><em>[Click to expand]</em></summary>

<br>

-   从第一轮开始运行最佳的超参数配置。
-   **(推测)**🤖使用额外的步骤来延长高学习率下的训练周期。
    -   例如，如果线性时间表从第1轮开始保持衰减的长度固定，并从一开始延长恒定lr的周期。
    -   对于余弦衰减，只需保持轮1的基础lr并扩展`max_train_steps`，如[Chinchilla paper](https://arxiv.org/abs/2203.15556)。
-   对于具有非常成熟的建模和调优管道以及非常长且昂贵的生产培训运行的团队来说，更多的轮次可能是有意义的，但它们通常会过度。
    -   我们已经描述了如何从步骤1 &rarr;步骤2。如果我们不关心分析时间，如果高效地利用计算是压倒一切的考虑，那么理想的做法是在许多轮调优中成倍地增加训练运行的长度(以及完成研究的端到端时间)。
        -   在每一轮中，我们都系统地确保我们的选择继续有效。
        -   新想法经过一个流程，从步骤i到步骤i+1，通过越来越长时间的实验逐步消除风险。

</details>

<h2 id="训练流程外的内容"><a href="#训练流程外的内容" class="headerlink" title="训练流程外的内容"></a>训练流程外的内容</h2><h3 id="优化输入流程"><a href="#优化输入流程" class="headerlink" title="优化输入流程"></a>优化输入流程</h3><p><strong><em>总结:</em></strong> <em>输入受限管道的原因和干预是高度任务依赖的;使用分析器检查常见问题</em></p>
<ul>
<li>使用合适的分析器来诊断输入受限的管道。例如，JAX的<a href="https://jax.readthedocs.io/en/latest/profiling.html">Perfetto</a>或TensorFlow的<a href="https://www.tensorflow.org/guide/profiler">TensorFlow profiler</a>。</li>
<li>最终，具体的原因和干预措施将高度依赖于任务。更广泛的工程考虑(例如，最小化磁盘占用)可能会导致更差的输入管道性能。</li>
<li>常见原因：<ul>
<li>数据没有与训练过程放在一起，导致I/O延迟(这可能发生在通过网络读取训练数据时)。</li>
<li>昂贵的在线数据预处理(考虑离线执行一次并保存)。</li>
<li>干扰数据管道预取的非故意同步障碍。例如，在CommonLoopUtils (<a href="https://github.com/google/CommonLoopUtils/blob/fea2518ada8814a78e1492023fd9f00edb0b0568/clu/metrics.py#L291">link</a>)中同步设备和主机之间的度量时。</li>
</ul>
</li>
<li>常见技巧：<ul>
<li>预取的仪器输入管道示例(例如<a href="https://www.tensorflow.org/guide/data_performance#prefetching">tf.data.Dataset.prefetch</a>)</li>
<li>尽可能早地从管道中删除未使用的功能/元数据。</li>
<li>增加为输入管道生成示例的作业的复制数量。例如，通过使用<a href="https://www.tensorflow.org/api_docs/python/tf/data/experimental/service">tf.data service</a>。</li>
</ul>
</li>
</ul>
<h3 id="评估模型性能"><a href="#评估模型性能" class="headerlink" title="评估模型性能"></a>评估模型性能</h3><p><strong><em>总结:</em></strong> <em>以比训练更大的批处理大小运行评估。以固定的步长(而不是固定的时间间隔)运行求值</em></p>
<h4 id="评估设置"><a href="#评估设置" class="headerlink" title="评估设置"></a>评估设置</h4><details><summary><em>[Click to expand]</em></summary>
<br>

-   我们可以通过几种设置来评估模型的性能。
    -   **在线评估**——当模型在生产环境中服务于预测时，收集指标。
    -   **离线评估**——当模型在代表生产环境的离线训练/验证/测试集上运行时，收集指标。
    -   **定期评估**——在模型训练期间收集指标，这些指标可能是离线评估的代理，或者是离线评估中使用的数据子集。
-   在线评估是黄金标准，但在模型开发阶段往往不切实际。
-   根据不同的问题，离线计算可能相当复杂，计算量也很大。
-   定期评估是最实际和最经济的选择，但可能不能完全代表生产环境。
    -   在定期评估期间，我们的目标是使用离线评估的方便代替，而不牺牲训练期间获得信号的可靠性。

</details>

<h4 id="建立定期评估"><a href="#建立定期评估" class="headerlink" title="建立定期评估"></a>建立定期评估</h4><details><summary><em>[Click to expand]</em></summary>
<br>

-   我们在训练期间进行定期评估以实时监控其进展，以[促进回顾模型检查点选择](#保存检查点并回顾选择最好的检查点)，这样我们就可以[在训练结束时检查训练曲线](#检查训练曲线)。
-   最简单的配置是在同一个计算实例中执行训练和定期评估，定期在训练和评估之间交替。
    -   在这种情况下，用于执行评估的批大小应该**至少**与用于训练的批大小相同，因为在评估期间不需要维护模型激活，从而降低了每个示例的计算需求。
-   定期评估应该按固定的步长间隔进行，而不是按时间间隔。
    -   基于时间间隔的评估可能会使解释训练曲线变得更加困难，特别是当训练可能受到训练作业的抢占、网络延迟问题等的影响时。
-   有效/测试指标的周期性(当使用打乱的训练/验证/测试划分时)可以表明实现中的bug，例如测试数据与训练数据重叠，或者训练数据没有正确打乱。定期评估可以使这些问题更容易发现。
-   当评估集不能被批量大小整除时，可能会出现部分批量。确保经过填充的样本被正确加权，以防止损失函数受到它们的偏差。通常，这些填充样例的权重为零。
-   在每次评估中保存足够的信息以支持离线分析。理想情况下，我们应该将预测保存在选择的单个示例上，因为它们对调试来说是无价的。
    -   生成像[SavedModels](https://www.tensorflow.org/guide/saved_model)这样的工件，可以在评估工作完成后轻松地进行特定的模型检查。

</details>

<h4 id="选择样本进行周期性评估"><a href="#选择样本进行周期性评估" class="headerlink" title="选择样本进行周期性评估"></a>选择样本进行周期性评估</h4><details><summary><em>[Click to expand]</em></summary>
<br>

-   定期评估作业的运行速度可能不够快，无法在合理的时间内计算完整的离线评估集上的指标。这常常需要采样数据进行定期评估。
-   在构建采样数据集时，我们考虑以下因素:
    -   <ins>Sample size</ins>
        -   检查周期作业使用的采样数据集的性能计算与整个离线评估集的性能匹配，即采样集和完整数据集之间没有倾斜。
        -   用于周期性评估的数据集应该足够小，以便于在整个数据集上生成模型预测，但又要足够大，以便可以准确地测量模型的改进(即不被标签噪声淹没)。
        -   它应该足够大，以适应在顺序的试验中进行多次这样的评估，并仍然产生准确的估计。也就是说，避免随着时间的推移自适应地“拟合”验证集，以一种不能泛化到保留测试集的方式。但是，这种考虑很少是实际问题。
    -   <ins>Imbalanced datasets</ins>
        -   对于不平衡的数据集，在罕见类别的样本上的性能通常会有噪声。
        -   对于类标签中样本数量较少的数据集，记录正确预测的样本数量，以更深入地了解精度的提高(0.05的灵敏度提高听起来令人兴奋，但这仅仅是又一个正确的样本吗?)

</details>

<h3 id="保存检查点并回顾选择最好的检查点"><a href="#保存检查点并回顾选择最好的检查点" class="headerlink" title="保存检查点并回顾选择最好的检查点"></a>保存检查点并回顾选择最好的检查点</h3><p><strong><em>总结:</em></strong> <em>进行固定步数的训练，并从运行中回顾性地选择最佳检查点。</em></p>
<ul>
<li>大多数深度学习框架都支持<a href="https://flax.readthedocs.io/en/latest/api_reference/flax.training.html">模型检查点</a>。也就是说，模型的当前状态定期保存在磁盘上。这使得训练工作可以恢复计算实例中断。</li>
<li>最好的检查点通常不是最后一个检查点，特别是当验证集的性能不是随着时间的推移而持续增加，而是在某个特定值上下波动时。</li>
<li>设置管道来跟踪到目前为止在训练中看到的N个最好的检查点。在训练结束时，模型选择就是选择训练过程中看到的最佳检查点。我们称之为<strong>回顾式最佳检查点选择</strong>。</li>
<li>支持预期的提前停止通常是不必要的，因为我们预先指定了一个试验预算，并保留了到目前为止看到的N个最好的检查点。</li>
</ul>
<h3 id="设置实验跟踪"><a href="#设置实验跟踪" class="headerlink" title="设置实验跟踪"></a>设置实验跟踪</h3><p><strong><em>总结:</em></strong> <em>在跟踪不同的实验时，一定要注意一些要点，比如研究中检查点的最佳表现，以及研究的简短描述。</em></p>
<ul>
<li>我们发现，在电子表格中跟踪实验结果对我们正在处理的这类建模问题很有帮助。它通常有以下列:<ul>
<li>Study name</li>
<li>指向存储研究配置的位置的链接。</li>
<li>研究的笔记或简短描述。</li>
<li>试运行次数</li>
<li>在本研究最佳检查点的验证集上的性能。</li>
<li>具体的复制命令或说明哪些未提交的更改是开展培训所必需的。</li>
</ul>
</li>
<li>找到一个跟踪系统，至少捕获上面列出的信息，并方便人们这样做。未跟踪的实验还不如不存在。</li>
</ul>
<h3 id="Batchnorm实现细节"><a href="#Batchnorm实现细节" class="headerlink" title="Batchnorm实现细节"></a>Batchnorm实现细节</h3><p><strong><em>总结:</em></strong> <em>现在批处理规范通常可以用LayerNorm代替，但在不能这样做的情况下，在更改批处理大小或主机数量时存在棘手的细节</em></p>
<ul>
<li>Batch norm使用当前批的平均值和方差对激活进行规范化，但在多设备设置中，这些统计数据在每个设备上是不同的，除非显式同步。</li>
<li>有些报告(主要是在ImageNet上)说，在实践中，只使用~64个例子来计算这些规范化统计数据实际上效果更好(参见本文中的<a href="https://arxiv.org/abs/1705.08741">Ghost Batch Norm</a>)。</li>
<li>将总批大小和用于计算batch norm统计的示例数量解耦对于批大小比较特别有用。</li>
<li>Ghost batch norm实现并不总是正确处理per-device batch size&gt;virtual batch size的情况。在这种情况下，我们实际上需要在每个设备上对批进行子采样，以便获得batch norm 统计示例的适当数量。</li>
<li>测试模式batch norm中使用的指数移动平均线只是训练统计数据的线性组合，因此这些ema只需要在将它们保存在检查点之前进行同步。然而，batch norm的一些常见实现并不同步这些EMA，而只是保存来自第一个设备的EMA。</li>
</ul>
<h3 id="多主机管道的注意事项"><a href="#多主机管道的注意事项" class="headerlink" title="多主机管道的注意事项"></a>多主机管道的注意事项</h3><p><strong><em>总结:</em></strong> <em>对于日志记录，评估，RNG seeds，检查点和数据分片，多主机训练可以使其非常容易引入bug !</em></p>
<p>RNG种子（RNG seeds）是在计算机科学中用于伪随机数生成器（RNG）的起始输入。伪随机数生成器是一种算法，可以生成看似随机但实际上是确定性的数字序列。这些序列在计算机编程和模拟中被广泛应用，用于生成随机性，例如在游戏中的随机事件、密码学中的密钥生成，以及在实验和模拟中的随机化等。</p>
<p>RNG种子是一个起始值，它作为输入提供给伪随机数生成器。通过使用相同的种子，可以在每次运行时生成相同的随机数序列，这对于实验的可重现性和调试代码非常有用。换句话说，如果你在相同的环境中使用相同的种子进行随机数生成，你将会得到相同的随机数序列。但是，如果你使用不同的种子，你将得到不同的随机数序列。</p>
<p>在深度学习中，RNG种子通常用于设置随机初始化的权重和偏差，以及在每个训练轮次中生成随机批次的顺序。通过固定种子，可以使模型的初始化和数据的处理过程在不同运行之间保持一致，以便进行可重复的实验和比较。</p>
<ul>
<li>确保整个流程只在一台主机上进行日志记录和检查点。</li>
<li>确保在运行评估或检查点之前，跨主机同步批规范统计信息。</li>
<li>对于不同主机(用于模型初始化)具有相同的RNG种子和不同主机(用于数据洗牌/预处理)具有不同的RNG种子是至关重要的，因此请确保对它们进行适当标记。</li>
<li>为了提高性能，通常建议跨主机对数据文件进行分片。</li>
</ul>
<h2 id="FAQs"><a href="#FAQs" class="headerlink" title="FAQs"></a>FAQs</h2><h3 id="最佳学习率衰减时间表是什么"><a href="#最佳学习率衰减时间表是什么" class="headerlink" title="最佳学习率衰减时间表是什么?"></a>最佳学习率衰减时间表是什么?</h3><details><summary><em>[Click to expand]</em></summary>
<br>

-   这是一个开放问题。目前还不清楚如何构建一套严格的实验来自信地回答“最佳”LR衰变时间表是什么。
-   虽然我们不知道最好的时间表，但我们相信有一些(不固定的)时间表是很重要的，并且调优它很重要。
-   在优化过程中，不同的学习率在不同的时间发挥最佳作用。制定某种时间表使模型更有可能达到一个良好的学习率。

</details>

<h3 id="我应该使用哪种学习率衰减作为默认值"><a href="#我应该使用哪种学习率衰减作为默认值" class="headerlink" title="我应该使用哪种学习率衰减作为默认值?"></a>我应该使用哪种学习率衰减作为默认值?</h3><details><summary><em>[Click to expand]</em></summary>
<br>

-   我们倾向于线性衰减或余弦衰减，还有一些其他的变换可能也不错。

</details>

<h3 id="为什么有些论文有复杂的学习率时间表"><a href="#为什么有些论文有复杂的学习率时间表" class="headerlink" title="为什么有些论文有复杂的学习率时间表?"></a>为什么有些论文有复杂的学习率时间表?</h3><details><summary><em>[Click to expand]</em></summary>
<br>

-   使用复杂的分段学习率(LR)衰减时间表的论文并不少见。
-   读者常常想知道作者是如何得出如此复杂的研究结果的。
-   许多复杂的LR衰减调度是将验证集的性能作为一个函数，以一种临时的方式调优调度的结果:
    1.  用一些简单的LR衰减(或恒定的学习率)开始一次训练运行。
    2.  继续训练，直到表现停滞。如果发生这种情况，暂停训练。从这一点开始，用可能更陡峭的LR衰减时间表(或更小的恒定学习率)恢复它。重复这个过程直到会议/发布截止日期。
-   盲目地复制结果**时间表**通常不是一个好主意，因为最佳的特定调度对许多其他超参数的选择都很敏感。
    -   最好复制生成时间表的**算法**，尽管遇到任意的人为判断生成时间表时，这几乎是不可能的。
-   如果可以完全自动化，这种类型的验证错误敏感的时间表是可以使用的，但由于验证错误的影响，human-in-the-loop schedules很脆弱，不容易重现，所以我们建议避免使用它们。
    -   在发布使用这种时间表的结果之前，请尝试使其完全可重现。

</details>

<h3 id="如何调优Adam的超参数"><a href="#如何调优Adam的超参数" class="headerlink" title="如何调优Adam的超参数?"></a>如何调优Adam的超参数?</h3><details><summary><em>[Click to expand]</em></summary>
<br>

- 如上所述，对搜索空间以及应该从搜索空间中采样多少个点是非常困难进行一般性的描述的。请注意，并非Adam中的所有超参数都同等重要。以下经验法则对应于一项研究中试验次数的不同“预算”。

  -   如果在一项研究中少于10次试验，只调整(基本)学习率。
  -   如果10-25次试验，调整学习率和$\beta_1$。
  -   如果25次以上的试验，调整学习率，$\beta_1$和$\epsilon$。
  -   如果可以运行超过25次试验，则需要进行额外的调优$\beta_2$.

  一个"trial"（实验）代表了一次完整的训练过程，也就是当你可尝试调参的次数有限时尝试调整的超参数顺序应为学习率>$\beta_1$>$\epsilon$>$\beta_2$。

</details>

<h3 id="为什么在调优的探索阶段使用准随机搜索而不是更复杂的黑盒优化算法"><a href="#为什么在调优的探索阶段使用准随机搜索而不是更复杂的黑盒优化算法" class="headerlink" title="为什么在调优的探索阶段使用准随机搜索而不是更复杂的黑盒优化算法?"></a>为什么在调优的探索阶段使用准随机搜索而不是更复杂的黑盒优化算法?</h3><details><summary><em>[Click to expand]</em></summary>

-   当用作迭代调优过程的一部分时，目的是最大化地了解调优问题(我们称之为“探索阶段”)，准随机搜索(基于[低差异序列](https://en.wikipedia.org/wiki/Low-discrepancy_sequence))是我们的首选，而不是花哨的黑盒优化工具。贝叶斯优化和类似的工具更适合于开发阶段。
-   基于随机移动的低差异序列的准随机搜索可以被认为是"抖动的、打乱的网格搜索"，因为它均匀而随机地探索给定的搜索空间，并且比随机搜索更分散的搜索点。
-   相对于更复杂的黑盒优化工具(如贝叶斯优化、进化算法)，准随机搜索的优势包括:
    1.  对搜索空间进行非自适应采样，可以在事后分析中改变调优目标，而无需重新运行实验。
        -   例如，我们通常希望找到在训练中任何点上的验证误差方面的最佳试验。但准随机搜索的非自适应性质使其有可能根据最终验证误差、训练误差或某些替代评估指标找到最佳试验，而无需重新运行任何实验。
    2.  准随机搜索具有一致性和统计可重复性。
        -   即使搜索算法的实现发生了变化，只要保持相同的均匀性，也应该有可能重现六个月前的研究。如果使用复杂的贝叶斯优化软件，版本之间的实现可能会发生重要变化，使得重现旧的搜索变得更加困难。不可能总是回滚到旧的实现(例如，如果优化工具作为服务运行)。
    3.  它对搜索空间的统一探索使推理结果及其对搜索空间的建议变得更容易。
        -   例如，如果准随机搜索遍历的最佳点位于搜索空间的边界，这是一个很好的(但不是完全可靠的)信号，表明应该改变搜索空间的边界。[本节](#识别错误的搜索空间边界)将深入探讨。然而，由于一些不幸的早期试验，自适应黑盒优化算法可能会忽略搜索空间的中间部分，即使它碰巧包含同样好的点，因为一个好的优化算法需要采用这种精确的非均匀性来加速搜索。
    4.  与自适应算法不同，使用准随机搜索(或其他非自适应搜索算法)时，并行和顺序运行不同数量的试验不会产生统计上的不同结果。
    5.  更复杂的搜索算法可能并不总是正确处理不可达点，特别是在设计它们时没有考虑神经网络超参数调整。
    6.  准随机搜索很简单，当许多调优试验并行运行时，效果特别好。
        -   有趣的是[^3]，一个自适应算法很难击败2X-budget准随机搜索，特别是当许多试验需要并行运行时(因此在启动新试验时很少有机会使用以前的试验结果)。
        -   如果没有贝叶斯优化和其他高级黑盒优化方法的专业知识，我们可能无法实现它们原则上能够提供的好处。在现实的深度学习调优条件下，很难对高级黑盒优化算法进行基准测试。它们是当前研究的一个非常活跃的领域，对于经验不足的用户来说，更复杂的算法也有其固有的缺陷。这些方法的专家能够得到很好的结果，但在高度并行的情况下，搜索空间和预算往往更重要。
-   也就是说，如果我们的计算资源只允许少量的试验并行运行，并且我们可以负担得起顺序运行许多试验，那么贝叶斯优化将变得更具吸引力，尽管这会使我们的调优结果更难解释。

[^3]: Ben Recht and Kevin Jamieson

[指出](http://www.argmin.net/2016/06/20/hypertuning/) 2X-budget随机搜索的强大程度是一个基准([Hyperband论文](https://jmlr.org/papers/volume18/16-558/16-558.pdf)提出了类似的观点)，但肯定有可能找到最先进的贝叶斯优化技术碾压2X-budget随机搜索的搜索空间和问题。然而，根据我们的经验，在高度并行的情况下，击败2X-budget随机搜索会变得更加困难，因为贝叶斯优化没有机会观察之前试验的结果。

</details>

<h3 id="我在哪里可以找到准随机搜索的实现"><a href="#我在哪里可以找到准随机搜索的实现" class="headerlink" title="我在哪里可以找到准随机搜索的实现?"></a>我在哪里可以找到准随机搜索的实现?</h3><details><summary><em>[Click to expand]</em></summary>
<br>

-   我们使用[此实现](https://github.com/mlcommons/algorithmic-efficiency/blob/main/algorithmic_efficiency/halton.py)为给定的搜索空间生成霍尔顿序列(旨在实现一个移位的，打乱的霍尔顿序列，如https://arxiv.org/abs/1706.03200中推荐的)。
-   如果基于低差异序列的准随机搜索算法不可用，则可以用伪随机均匀搜索替代，尽管这可能会稍微低效一些。
    -   在1-2维空间中，网格搜索也是可以接受的，但在更高的维度中则不行(参见[Bergstra & Bengio, 2012](https://www.jmlr.org/papers/v13/bergstra12a.html))。

</details>

<h3 id="准随机搜索需要多少次试验才能得到好的结果"><a href="#准随机搜索需要多少次试验才能得到好的结果" class="headerlink" title="准随机搜索需要多少次试验才能得到好的结果?"></a>准随机搜索需要多少次试验才能得到好的结果?</h3><details><summary><em>[Click to expand]</em></summary>
<br>
<p align="center">
<img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/have_we_sampled_enough.png" width="49%" alt="A box plot showing the importance of sampling enough">
</p>

<p align="center"><b>Figure 3:</b> 在ImageNet上调整ResNet-50为100试用通过bootstrapping方法，模拟不同数量的调优预算。上面绘制了每个试验预算的最佳性能的箱线图.




-   一般来说没有办法回答这个问题，但我们可以看一些具体的例子。
-   如图3所示，研究中的试验次数会对结果产生重大影响。
    -   请注意，当采样6个试验时，四分位数范围的大小与采样20个试验时的四分位数范围的大小。
    -   即使有20次试验，特别幸运的研究和特别不幸运的研究之间的差异很可能会比在固定超参数的情况下，在验证错误率为\~23%的情况下，在不同的随机种子上重新训练该模型之间的典型差异更大。

</details>

<h3 id="如何调试和缓解优化失败"><a href="#如何调试和缓解优化失败" class="headerlink" title="如何调试和缓解优化失败"></a>如何调试和缓解优化失败</h3><details><summary><em>[Click to expand]</em></summary>
<br>
**总结:** *如果模型遇到优化困难，在尝试其他方法之前解决它们是很重要的。诊断和纠正训练失败是一个活跃的研究领域*

<p align="center">
<img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/stride_instability.png" width="80%" alt="Changing the strides in a single residual block in a WideResnet results in training instability.">
</p>



<p align="center"><b>Figure 4:</b> 改变WideResnet中单个残差块(2x2 -> 1x1)的步幅会导致训练不稳定。这不会降低低学习率时的性能，但由于不稳定，高学习率不再训练良好。应用1000步的学习率热身解决了这种特殊的不稳定情况，允许在最大学习率为.1的情况下进行稳定的训练。</p>

#### 识别不稳定的workloads工作负载

-   如果学习率太大，任何工作负载都会变得不稳定。只有当它迫使我们使用太小的学习率时，不稳定性才是一个问题。
-   至少有两种类型的训练不稳定性值得区分:
    1.  初始化/训练早期不稳定。
    2.  训练中途突然不稳定。
-   我们可以采用系统的方法来识别工作负载中的稳定性问题。
    1.  执行学习率扫描并找到最佳学习率lr*。
    2.  绘制学习率略高于lr*的训练损失曲线。
    3.  如果学习率> lr*显示损失不稳定(损失在训练期间上升而不是下降)，那么修复不稳定可能会导致更好的训练。
-   对整个损失梯度的L2范数进行Log处理，在训练过程中，异常值会导致虚假的不稳定。这可以告诉我们如何选择渐变/更新裁剪。

**NOTE:**一些模型表现出非常早期的不稳定性，然后恢复，导致缓慢但稳定的训练。**通常的评估计划可能会因为评估不够频繁而错过这些问题!**

为了检查这一点，我们可以使用`lr = 2 * current best`来训练\~500步的简短运行，但对每一步都进行评估。

<p align="center">
<img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/more_frequent_evals.png" width="80%" alt="Illustration of the value of more frequent evaluations at the start of
training.">
</p>

<p align="center"><b>Figure 5:</b> 说明在训练开始时更频繁的评估的价值。如果怀疑模型存在早期训练不稳定的问题，则是有用的。</p>

#### 对常见的不稳定模式的潜在修复

-   使用 learning rate warmup
    -   最适合早期训练不稳定。
-   使用 gradient clipping
    -   对早期和中期训练的不稳定性都有好处，可以解决一些warmup不能解决的问题。
-   尝试一个新的优化器
    -   有时候Adam能处理好Momentum处理不了的不稳定。这是一个活跃的研究领域。
-   我们可以确保我们为我们的模型架构使用最佳实践/初始化(下面的示例)。
    -   如果模型不包含残差连接，则添加残差连接并进行规范化。
-   归一化应该是残差之前的最后一个操作。 E.g. x + Norm(f(x)).
-   Norm(x + f(x))已知会引起问题。
-   尝试将residual分支初始化为0(e.g. [ReZero init](https://arxiv.org/abs/2003.04887)).
-   降低学习率
    -   这是最后的办法。

#### Learning rate warmup

<p align="center">
<img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/instability_during_warmup.png" width="80%" alt="An example of instability during a warmup period (note the horizontal axis log
scale).">
</p>

<p align="center"><b>Figure 6:</b> 热身期间不稳定的例子(注意水平轴对数尺度)。在这种情况下，成功的训练需要40k步的热身。</p>

##### When to apply learning rate warmup

<p align="center">
<img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/axis_model_with_instability.png" width="49%" alt="Axis plot for model with instability">
</p>

<p align="center"><b>Figure 7a:</b> 展示训练不稳定的模型的超参数轴图示例。最佳学习率是在可行范围的边缘。“不可行”试验被定义为产生nan或异常高的损失值的试验。</p>

<p align="center">
<img src="assets/loss_model_with_instability.png" width="49%" alt="Loss curve for model with instability">
</p>
<p align="center"><b>Figure 7b:</b> 使用学习率训练的模型的训练损失，我们看到不稳定.</p>

-   图7a显示了一个超参数轴图，表明一个模型正经历优化不稳定，因为最佳学习率正好位于不稳定的边缘。
-   图7b展示了如何通过检查以比峰值大5倍或10倍的学习率训练的模型的训练损失来进行双重检查。如果该图显示了损失在稳步下降之后突然上升(例如上图中的步长\~10k)，那么模型可能会遭遇优化不稳定。

##### How to apply learning rate warmup

<p align="center">
<img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/beneficial_effect_warmup.png" width="80%" alt="Beneficial effect of warmup on training instabilities">
</p>

<p align="center"><b>Figure 8:</b> learning rate warmup 对解决训练不稳定性的有益作用</p>

-   使用上面的部分，我们假设从业者已经确定了模型变得不稳定的学习率。这就是`unstable_base_learning_rate`。
-   热身包括预先设定学习率，将学习率从0提升到某个稳定的`base_learning_rate`，比`unstable_base_learning_rate`至少大一个数量级。默认值是10倍于`unstable_base_learning_rate`的`base_learning_rate`。不过请注意，对于类似100x的`unstable_base_learning_rate`，可以再次运行整个过程。具体过程如下:
    -   通过`warmup_steps`从0上升到`base_learning_rate`。
    -   以恒定的速率训练`post_warmup_steps`。
-   我们的目标是找到最短数量的`warmup_steps`，使我们能够获得远高于`unstable_base_learning_rate`的峰值学习率。
-   所以对于每个`base_learning_rate`，我们需要调整`warmup_steps`和`post_warmup_steps`。通常可以将`post_warmup_steps`设置为`2*warmup_steps`。
-   Warmup 可以独立于现有的衰减计划进行调整。`warmup_steps`应该以几个不同的数量级进行清理。例如，一个示例研究可以尝试[10,10 <sup>3</sup>， 10<sup>4</sup>， 10<sup>5</sup>]。最大可行点不应该超过`max_train_steps`的10%。
-   一旦建立了不会破坏`base_learning_rate`训练的`warmup_steps`，就应该将其应用于基线模型。本质上，我们将此调度添加到现有的调度中，并使用上面讨论的最佳检查点选择来将此实验与基线进行比较。例如，如果我们最初有10 000个`max_train_steps`，并对1000个步骤执行了`warmup_steps`，那么新的训练过程总共应该运行11 000个步骤。
-   如果稳定训练需要较长的`warmup_steps` (`max_train_steps`的>5%)，则可能需要增加`max_train_steps`来说明这一点。
-   在整个工作负载范围内，并没有一个真正的“典型”值。有些模型只需要100步，而其他模型(特别是transformer)可能需要40k以上。

#### Gradient clipping

<p align="center">
<img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/gradient_clipping.png" width="80%" alt="Gradient clipping on early training instabilities">
</p>


<p align="center"><b>Figure 9:</b> Illustration of gradient clipping correcting early training instability.</p>

-   Gradient clipping在发生较大或异常梯度问题时最有用。
-   Clipping 可以解决早期训练的不稳定性(早期的大梯度范数)，或中期训练的不稳定性(训练中期的突然梯度峰值)。
-   有时更长的预热时间可以纠正裁剪无法纠正的不稳定性:请参阅[上面的这部分](#How-to-apply-learning-rate-warmup).
    -   🤖 What about clipping during warmup?
-   理想的clip阈值刚好高于“典型的”梯度范数。
-   下面是一个渐变裁剪的例子:
    -   如果梯度的范数$\left | g \right |$大于梯度裁剪阈值$\lambda$，那么执行${g}'= \lambda \times \frac{g}{\left | g \right |}$，其中${g}'$是新的梯度。
-   在训练过程中记录未裁剪的梯度范数。默认情况下，生成:
    -   梯度范数与步长的图
    -   在所有步骤中聚合的梯度范数直方图
-   基于梯度范数的90百分位数选择梯度裁剪阈值。
    -   阈值取决于工作负载，但90%是一个很好的起点。如果它不起作用，可以调整这个阈值。
    -   🤖 What about some sort of adaptive strategy?
-   如果我们尝试梯度裁剪，但不稳定的问题仍然存在，我们可以更努力地尝试(即使阈值更小)。
-   极端激进的梯度裁剪本质上是一种降低学习率的奇怪方法。如果我们发现自己使用了非常激进的裁剪，我们可能应该降低学习率。
-   我们通常会考虑将>50%的更新以某种方式剪辑为“极端激进”。
-   如果我们需要进行非常激进的梯度裁剪来处理不稳定问题，那么我们可能还需要降低学习率。

</details>

<h3 id="为什么把学习率和其他优化参数称为超参数-它们不是任何先验分布的参数"><a href="#为什么把学习率和其他优化参数称为超参数-它们不是任何先验分布的参数" class="headerlink" title="为什么把学习率和其他优化参数称为超参数?它们不是任何先验分布的参数"></a>为什么把学习率和其他优化参数称为超参数?它们不是任何先验分布的参数</h3><details><summary><em>[Click to expand]</em></summary>
<br>

-   的确，术语“超参数”在贝叶斯机器学习中有一个精确的[含义](https://en.wikipedia.org/wiki/Hyperparameter)，将学习率和我们在深度学习中调优的大多数其他参数称为“超参数”是一种术语滥用。
-   我们更倾向于使用术语“元参数”来表示学习率、架构参数和我们在深度学习中调整的所有其他东西，因为它避免了误用“超参数”这个词带来的潜在混淆(在讨论贝叶斯优化时，概率响应面模型有自己的真正超参数，这种混淆尤其可能发生)。
-   不幸的是，尽管可能令人困惑，但术语超参数在深度学习社区中已经变得非常普遍。
-   因此，对于一份文件，比如这份文件，它的目的是为广泛的受众，其中包括许多不太可能意识到这种技术细节的人，我们选择在该领域造成一个困惑的来源，希望避免另一个。
-   也就是说，在发表研究论文时，我们可能会做出不同的选择，我们会鼓励其他人在大多数情况下使用“元参数”。

</details>

<h3 id="为什么不调整批大小以直接提高验证集性能"><a href="#为什么不调整批大小以直接提高验证集性能" class="headerlink" title="为什么不调整批大小以直接提高验证集性能?"></a>为什么不调整批大小以直接提高验证集性能?</h3><details><summary><em>[Click to expand]</em></summary>
<br>

-   在不改变训练管道的任何其他细节的情况下改变批大小通常会影响验证集的性能。
-   然而，如果训练管道针对每个批量大小进行独立优化，则两个批量大小之间验证集性能的差异通常会消失。
-   与批处理大小相互作用最强烈的超参数是优化器超参数(例如学习率，动量)和正则化超参数，因此对每个批处理大小分别进行调优是最重要的。
    - 由于样本方差，较小的批量大小会在训练算法中引入更多的噪声，并且这种噪声可以具有正则化效果。因此，较大的批大小更容易出现过拟合，可能需要更强的正则化和/或额外的正则化技术。
-   另外，在更改批处理大小时，[训练步数可能需要调整](# 选择批的大小以减少训练时间)。
-   一旦考虑到所有这些影响，目前没有令人信服的证据表明批量大小会影响可达到的最大验证性能(见[Shallue et al. 2018](https://arxiv.org/abs/1811.03600))。

</details>

<h3 id="所有流行的优化算法的更新规则是什么"><a href="#所有流行的优化算法的更新规则是什么" class="headerlink" title="所有流行的优化算法的更新规则是什么?"></a>所有流行的优化算法的更新规则是什么?</h3><details><summary><em>[Click to expand]</em></summary>

<br>

#### Stochastic gradient descent (SGD)

$$\theta_{t+1} = \theta_{t} - \eta_t \nabla \mathcal{l}(\theta_t)$$

#### Momentum

$$v_0 = 0$$

$$v_{t+1} = \gamma v_{t} + \nabla \mathcal{l}(\theta_t)$$

$$\theta_{t+1} = \theta_{t} - \eta_t v_{t+1}$$

#### Nesterov

$$v_0 = 0$$

$$v_{t+1} = \gamma v_{t} + \nabla \mathcal{l}(\theta_t)$$

$$\theta_{t+1} = \theta_{t} - \eta_t( \gamma v_{t+1} + \nabla \mathcal{l}(\theta_{t})$$

#### RMSProp

$$v_0 = 1 \text{,} m_0 = 0$$

$$v_{t+1} = \rho v_{t} + (1 - \rho) \nabla \mathcal{l}(\theta_t)^2$$

$$m_{t+1} = \gamma m_{t} + \frac{\eta_t}{\sqrt{v_{t+1} + \epsilon}}\nabla \mathcal{l}(\theta_t)$$

$$\theta_{t+1} = \theta_{t} - m_{t+1}$$

#### ADAM

$$m_0 = 0 \text{,} v_0 = 0$$

$$m_{t+1} = \beta_1 m_{t} + (1 - \beta_1) \nabla \mathcal{l} (\theta_t)$$

$$v_{t+1} = \beta_2 v_{t} + (1 - \beta_2) \nabla \mathcal{l}(\theta_t)^2$$

$$b_{t+1} = \frac{\sqrt{1 - \beta_2^{t+1}}}{1 - \beta_1^{t+1}}$$

$$\theta_{t+1} = \theta_{t} - \alpha_t \frac{m_{t+1}}{\sqrt{v_{t+1}} + \epsilon} b_{t+1}$$

#### NADAM

$$m_0 = 0 \text{,} v_0 = 0$$

$$m_{t+1} = \beta_1 m_{t} + (1 - \beta_1) \nabla \mathcal{l} (\theta_t)$$

$$v_{t+1} = \beta_2 v_{t} + (1 - \beta_2) \nabla \mathcal{l} (\theta_t)^2$$

$$b_{t+1} = \frac{\sqrt{1 - \beta_2^{t+1}}}{1 - \beta_1^{t+1}}$$

$$\theta_{t+1} = \theta_{t} - \alpha_t \frac{\beta_1 m_{t+1} + (1 - \beta_1) \nabla \mathcal{l} (\theta_t)}{\sqrt{v_{t+1}} + \epsilon} b_{t+1}$$

</details>

<h2 id="Acknowledgments"><a href="#Acknowledgments" class="headerlink" title="Acknowledgments"></a>Acknowledgments</h2><ul>
<li>We owe a debt of gratitude to Max Bileschi, Roy Frostig, Zelda Mariet, Stan<br>Bileschi, Mohammad Norouzi, Chris DuBois and Charles Sutton for reading the<br>manuscript and providing valuable feedback.</li>
<li>We reused some experimental data for several plots that were originally<br>produced by Naman Agarwal for other joint research.</li>
<li>We would like to thank Will Chen for invaluable advice on the presentation of the document.</li>
<li>We would also like to thank Rohan Anil for useful discussions.</li>
</ul>
<h2 id="Citing"><a href="#Citing" class="headerlink" title="Citing"></a>Citing</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@misc&#123;tuningplaybookgithub,</span><br><span class="line">  author = &#123;Varun Godbole and George E. Dahl and Justin Gilmer and Christopher J. Shallue and Zachary Nado&#125;,</span><br><span class="line">  title = &#123;Deep Learning Tuning Playbook&#125;,</span><br><span class="line">  url = &#123;http://github.com/google/tuning_playbook&#125;,</span><br><span class="line">  year = &#123;2023&#125;,</span><br><span class="line">  note = &#123;Version 1.0&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Contributing"><a href="#Contributing" class="headerlink" title="Contributing"></a>Contributing</h2><ul>
<li><p>This is not an officially supported Google product.</p>
</li>
<li><p>We’d love to hear your feedback!</p>
<ul>
<li>If you like the playbook, please <a href="https://docs.github.com/en/get-started/exploring-projects-on-github/saving-repositories-with-stars#starring-a-repository">leave a star</a>! Or email deep-learning-tuning-playbook [at] googlegroups.com. Testimonials help us justify creating more resources like this.</li>
<li>If anything seems incorrect, please file an issue to start a discussion. For questions or other messages where an issue isn’t appropriate, please open a new discussion topic on GitHub.</li>
</ul>
</li>
<li><p>As discussed in the preamble, this is a living document. We anticipate making periodic improvements, both small and large. If you’d like to be notified, please watch our repository (see <a href="https://docs.github.com/en/account-and-profile/managing-subscriptions-and-notifications-on-github/setting-up-notifications/configuring-notifications#configuring-your-watch-settings-for-an-individual-repository">instructions</a>).</p>
</li>
<li><p>Please don’t file a pull request without first coordinating with the authors via the issue tracking system.</p>
</li>
</ul>
<h3 id="Contributor-License-Agreement"><a href="#Contributor-License-Agreement" class="headerlink" title="Contributor License Agreement"></a>Contributor License Agreement</h3><p>Contributions to this project must be accompanied by a Contributor License Agreement (CLA). You (or your employer) retain the copyright to your contribution; this simply gives us permission to use and redistribute your contributions as part of the project. Head over to <a href="https://cla.developers.google.com/">https://cla.developers.google.com/</a> to see your current agreements on file or to sign a new one.</p>
<p>You generally only need to submit a CLA once, so if you’ve already submitted one (even if it was for a different project), you probably don’t need to do it again.</p>
<h3 id="Code-Reviews"><a href="#Code-Reviews" class="headerlink" title="Code Reviews"></a>Code Reviews</h3><p>All submissions, including submissions by project members, require review. We use GitHub pull requests for this purpose. Consult<br><a href="https://help.github.com/articles/about-pull-requests/">GitHub Help</a> for more information on using pull requests.</p>
<h3 id="Community-Guidelines"><a href="#Community-Guidelines" class="headerlink" title="Community Guidelines"></a>Community Guidelines</h3><p>This project follows <a href="https://opensource.google/conduct/">Google’s Open Source Community Guidelines</a>.</p>
]]></content>
      <categories>
        <category>网络优化</category>
      </categories>
      <tags>
        <tag>调参</tag>
      </tags>
  </entry>
  <entry>
    <title>代码随想录(刷题总目录)</title>
    <url>/link/suixiangluc++.html</url>
    <content><![CDATA[<blockquote>
<p>刷题参考：<a href="https://www.programmercarl.com/">代码随想录 (programmercarl.com)</a></p>
<p>题目来源：<a href="https://leetcode.cn/problems/binary-search">力扣（LeetCode）</a></p>
</blockquote>
<h1 id="代码随想录刷题总结"><a href="#代码随想录刷题总结" class="headerlink" title="代码随想录刷题总结"></a>代码随想录刷题总结</h1><ul>
<li><a href="https://www.liumeng.top/link/suixiangluday1.html">Day 1：数组</a></li>
<li><a href="https://www.liumeng.top/link/suixiangluday2.html">Day 2：链表</a></li>
<li><a href="https://www.liumeng.top/link/suixiangluday3.html">Day 3：哈希表</a></li>
<li><a href="https://www.liumeng.top/link/suixiangluday4.html">Day 4：字符串</a></li>
<li><a href="https://www.liumeng.top/link/suixiangluday5.html">Day 5：栈与队列</a></li>
<li><a href="https://www.liumeng.top/link/suixiangluday6.html">Day 6：二叉树（前篇）</a></li>
<li><a href="https://www.liumeng.top/link/suixiangluday7.html">Day 7：二叉树（中篇）</a></li>
<li><a href="https://www.liumeng.top/link/suixiangluday8.html">Day 8：二叉树（后篇）</a></li>
<li><a href="https://www.liumeng.top/link/suixiangluday9.html">Day 9：回溯算法（前篇）</a></li>
<li><a href="https://www.liumeng.top/link/suixiangluday10.html">Day 10：回溯算法（后篇）</a></li>
<li><a href="https://www.liumeng.top/link/suixiangluday11.html">Day 11：贪心算法（前篇）</a></li>
<li><a href="https://www.liumeng.top/link/suixiangluday12.html">Day 12：贪心算法（后篇）</a></li>
<li><a href="https://www.liumeng.top/link/suixiangluday13.html">Day 13：动态规划（一）</a></li>
<li><a href="https://www.liumeng.top/link/suixiangluday14.html">Day 14：动态规划（二）</a></li>
<li><a href="https://www.liumeng.top/link/suixiangluday15.html">Day 15：动态规划（三）</a></li>
<li><a href="https://www.liumeng.top/link/suixiangluday16.html">Day 16：动态规划（四）</a></li>
<li><a href="https://www.liumeng.top/link/suixiangluday17.html">Day 17：动态规划（五）</a></li>
<li><a href="https://www.liumeng.top/link/suixiangluday18.html">Day 18：单调栈</a></li>
<li><a href="https://www.liumeng.top/link/suixiangluday19.html">Day 19：图论（一）</a></li>
<li><a href="https://www.liumeng.top/link/suixiangluday20.html">Day 20：图论（二）</a></li>
<li><a href="https://www.liumeng.top/link/topset.html">补充：堆与优先队列</a></li>
<li><a href="https://www.liumeng.top/link/paixun2.html">补充：排序算法（$n^2$）</a></li>
<li><a href="https://www.liumeng.top/link/paixunlogn.html">补充：排序算法（$nlogn$）</a></li>
<li><a href="https://www.liumeng.top/link/paixun.html">补充：排序算法（$n$）</a></li>
<li><a href="https://www.liumeng.top/link/chazhao.html">补充：查找算法</a></li>
<li><a href="https://www.liumeng.top/link/avltree.html">补充：平衡树</a></li>
<li><a href="https://www.liumeng.top/link/acminput.html">补充：ACM输入读取</a></li>
</ul>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++算法</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程基础</title>
    <url>/link/adcb768c.html</url>
    <content><![CDATA[<p>​    </p>
<h1 id="网络编程基础"><a href="#网络编程基础" class="headerlink" title="网络编程基础"></a>网络编程基础</h1><h2 id="第一章：准备知识"><a href="#第一章：准备知识" class="headerlink" title="第一章：准备知识"></a>第一章：准备知识</h2><h3 id="1-IP地址"><a href="#1-IP地址" class="headerlink" title="1. IP地址"></a>1. IP地址</h3><blockquote>
<p>IP地址用来<strong>标记用户</strong>，同一局域网下<strong>每个用户IP唯一</strong>。</p>
</blockquote>
<p><strong>1.1 查看电脑IP地址</strong></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ifconfig   Linux，Mac查看命令</span><br><span class="line"><span class="built_in">ipconfig</span>   Windows命令</span><br></pre></td></tr></table></figure>
<p><strong>1.2 IP地址分类</strong></p>
<ul>
<li><strong>IPv4：</strong>格式为<strong>xxx.xxx.xxx.xxx</strong>，最高为<strong>255.255.255.255</strong></li>
<li><strong>IPv6：</strong>为了解决IPv4耗尽的问题，提出的新协议</li>
</ul>
<p><strong>IPv4按用途可分五大类：A类（政府）、B类（公司）、C类（公用）、D类（组播）和E类（实验）</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"><strong>地址类型</strong></th>
<th><strong>特征</strong></th>
<th><strong>介绍</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>A类地址</strong></td>
<td><strong>第一位为0，注意是位</strong></td>
<td><strong>1、第1字节为网络地址，其它3个字节为主机地址 <br>2、地址范围：1.0.0.1—126.255.255.254 <br/>3、10.X.X.X是私有地址，范围从10.0.0.0-10.255.255.255<br/>4、127.X.X.X是保留地址，用做环回测试。</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>B类地址</strong></td>
<td><strong>前两位为10，注意是位</strong></td>
<td><strong>1、 第1字节和第2字节为网络地址，后2个字节为主机地址 <br/>2、地址范围：128.0.0.1—191.255.255.254 <br/>3、私有地址范围：172.16.0.0—172.31.255.255 <br/>4、保留地址：169.254.X.X</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>C类地址</strong></td>
<td><strong>前三位为110，注意是位</strong></td>
<td><strong>1、前三个字节为网络地址，最后字节为主机地址 <br/>2、地址范围：192.0.0.1—223.255.255.254 <br/>3、私有地址：192.168.X.X，范围从192.168.0.0-192.168.255.255</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>D类地址</strong></td>
<td><strong>前四位为1110，注意是位</strong></td>
<td><strong>1、不分网络地址和主机地址。 <br/>2、地址范围：224.0.0.1—239.255.255.254</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>E类地址</strong></td>
<td><strong>前五位为11110，注意是位</strong></td>
<td><strong>1、不分网络地址和主机地址 <br/>2、地址范围：240.0.0.1—255.255.255.254</strong></td>
</tr>
</tbody>
</table>
</div>
<p><strong>1.3 私有ip</strong></p>
<p>​        私有地址<strong>主要用于在局域网</strong>中进行分配，在 <strong>Internet上</strong>是<code>无效</code>的。这样可以很好地隔离局域网和 Internet。<strong>私有地址</strong>在<strong>公网上</strong>是<strong>不能被识别</strong>的，必须通过<code>NAT</code>将<strong>内部IP地址</strong>转换成<strong>公网</strong>上可用的<strong>IP</strong>地址，从而<code>实现内部IP地址与外部公网的通信</code>。公有地址是在广域网内使用的地址，但在局域网中同样也可以使用，除了私有地址以外的地址都是公有地址。</p>
<p>​        私有ip属于非注册地址，专门为组织机构内部使用。RFC1918定义了私有IP地址范围：</p>
<p><strong>A: 10.0.0.0~10.255.255.255 即10.0.0.0/8</strong></p>
<p><strong>B:172.16.0.0~172.31.255.255\</strong>即172.16.0.0*<em>/12*</em></p>
<p><strong>C:192.168.0.0~192.168.255.255 即192.168.0.0/16</strong></p>
<p>​        这些地址是<strong>不会被Internet分配</strong>的，它们在Internet上也不会被路由，虽然它们不能直接和Internet网连接，但通过技术手段仍旧可以<strong>和Internet通讯</strong>（<strong><em>NAT技术</em></strong> ）。我们可以根据需要来选择适当的地址类，在内部局域网中将这些地址像公用IP地址一样地使用。在Internet上，有些<strong>不需要与Internet通讯的设备</strong>，如<code>打印机、可管理集线器等</code>也<strong>可以使用</strong>这些地址，以<strong>节省IP地址资源</strong>。</p>
<h3 id="2-端口（Port）"><a href="#2-端口（Port）" class="headerlink" title="2. 端口（Port）"></a>2. 端口（Port）</h3><p>​        如果把<strong>IP地址</strong>比作一间<strong>房子</strong> ，<strong>端口</strong>就是出入这间<strong>房子的门</strong>。真正的房子只有几个门，但是一个<strong>IP地址的端口可以有65536</strong>（即：2^16）个,端口是通过端口号来标记的，<strong>端口号只有整数</strong>，范围是从<code>0 ~65535</code>（2^16-1）。</p>
<p>​        每个软件服务都会占用一个端口，两台机器进行信息传递时需要使用IP确定主机，端口确定服务。</p>
<p>​        协议端口分为<strong>TCP端口</strong>和<strong>UDP端口</strong>。由于TCP和UDP <strong>两个协议是独立的</strong>，因此各自的端口号也相互独立，比如TCP有235端口，UDP也 可以有235端口，<strong>两者并不冲突</strong>。</p>
<p><strong>2.1.周知端口（Well Known Ports）</strong></p>
<p>​        周知端口是众所周知的端口号，范围从<code>0到1023</code>，其中<code>80端口</code>分配给<code>WWW服务</code>，<code>21端口</code>分配给<code>FTP服务</code>等。我们在IE的地址栏里输入一个网址的时候是不必指定端口号的，因为在<strong>默认情况</strong>下<strong>WWW服务的端口是“80”</strong>。</p>
<p>​        <em>网络服务是可以使用其他端口号的</em>，如果不是默认的端口号则应该在 地址栏上指定端口号，方法是在地址后面加上冒号“：”（半角），再加上端口号。比如使用“8080”作为WWW服务的端口，则需要在地址栏里输入“网址：8080”。</p>
<p>​        但是<strong>有些系统协议使用固定的端口号</strong>，它是<strong>不能被改变</strong>的，比如<code>139 端口</code>专门用于<code>NetBIOS与TCP/IP之间的通信</code>，不能手动改变。</p>
<p><strong>2.2.动态端口（Dynamic Ports）</strong></p>
<p>​        动态端口的范围是从<code>49152到65535</code>。之所以称为动态端口，是因为它 一般不固定分配某种服务，而是动态分配。</p>
<p><strong>2.3.注册端口</strong></p>
<p>​        端口<code>1024到49151</code>，分配给用户进程或应用程序。这些进程主要是用户选择安装的一些应用程序，而不是已经分配好了公认端口的常用程序。这些端口在没有被服务器资源占用的时候，可以用用户端动态选用为源端口。</p>
<h3 id="3-网络协议"><a href="#3-网络协议" class="headerlink" title="3.网络协议"></a>3.网络协议</h3><h4 id="3-1简介"><a href="#3-1简介" class="headerlink" title="3.1简介"></a>3.1简介</h4><p>​        <strong>网络协议为计算机网络中进行数据交换而建立的规则、标准或约定的集合</strong>。<strong>网络中</strong>一个微机用户和一个大型主机的操作员<strong>进行通信</strong>，由于这<strong>两个数据终端所用字符集不同</strong>，因此操作员所输入的命令彼此不认识。<strong>为了</strong>能<code>进行通信</code>，<strong>规定每个终端都要将各自字符集中的字符先变换为标准字符集的字符</strong>后，<strong>才进入网络传送</strong>，<strong>到达目的终端</strong>之后，<strong>再变换为该终端字符集的字符</strong>。</p>
<h4 id="3-2-TCP-IP协议"><a href="#3-2-TCP-IP协议" class="headerlink" title="3.2.TCP/IP协议"></a>3.2.TCP/IP协议</h4><p>​        TCP/IP协议为目前最常用的网络协议。分为链路层，网络层，传输层，应用层四层。</p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202302101954328.png" alt="tcp/ip五层模型组成、封装、常用协议示意图"></p>
<ul>
<li><strong>链路层：即物理硬件</strong>，主要工作就是对电信号进行分组并形成具有特定意义的数据帧，然后以广播的形式通过物理介质发送给接收方。</li>
<li><strong>网络层：主要工作是定义网络地址、区分网段、子网内MAC寻址、对于不同子网的数据包进行路由。存在有IP协议，APR协议，路由协议。</strong></li>
<li><strong>传输层：主要工作是定义端口，标识应用程序身份，实现端口到端口的通信，主要协议有TCP和UDP。</strong></li>
<li><strong>应用层</strong>：主要工作就是<strong>定义数据格式</strong>并按照对应的格式<strong>解读数据</strong>。</li>
</ul>
<h3 id="4-套接字（socket）"><a href="#4-套接字（socket）" class="headerlink" title="4.套接字（socket）"></a>4.套接字（socket）</h3><h4 id="4-1-简介"><a href="#4-1-简介" class="headerlink" title="4.1.简介"></a>4.1.简介</h4><p>​        <strong>套接字</strong>是通信的基石，<strong>是支持TCP/IP协议的网络通信的基本操作单元</strong>。可以将套接字看作不同主机间的进程进行双间通信的端点，它构成了单个主机内及整个网络间的编程界面。套接字存在于通信域中，通信域是为了处理一般的线程通过套接字通信而引进的一种抽象概念。</p>
<p>​        <strong>套接字通常和同一个域中的套接字交换数据</strong>(数据交换也可能穿越域的界限，但这时一定要执行某种解释程序)，各种进程使用这个相同的域互相之间用Internet协议簇来进行通信 ，<strong>Windows Socket只支持一个通信区域——AF_INET国际网区域</strong>，使用网际协议族通信的进程使用该域 。</p>
<h4 id="4-2-主要类型"><a href="#4-2-主要类型" class="headerlink" title="4.2.主要类型"></a>4.2.主要类型</h4><p><strong>1.流套接字(SOCK_STREAM)</strong></p>
<p>​        流套接字用于提供面向<strong>连接、可靠</strong>的数据传输服务。该服务将保证数据能够实现<strong>无差错、无重复送，并按顺序接收</strong>。流套接字之所以能够实现可靠的数据服务，原因在于其使用了<strong>传输控制协议，即TCP</strong>(The Transmission Control Protocol)协议。</p>
<p><strong>2.数据报套接字(SOCK_DGRAM)</strong></p>
<p>​       数据报套接字提供一种<strong>无连接</strong>的服务。该服务并<strong>不能保证</strong>数据<strong>传输的可靠性</strong>,数据有<strong>可能在传输过程中丢失或出现数据重复</strong>，且<strong>无法保证顺序地接收</strong>到数据。数据报套接字使用<strong>UDP</strong>( User DatagramProtocol)协议进行数据的传输。由于数据报套接字不能保证数据传输的可靠性，<strong>对于</strong>有可能出现的<strong>数据丢失</strong>情况，<strong>需要在程序中做相应的处理</strong> 。</p>
<p><strong>3.原始套接字(SOCK_RAW)</strong></p>
<p>​        原始套接字与标准套接字(标准套接字指的是前面介绍的流套接字和数据报套接字)的区别在于：<strong>原始套接字可以读写内核没有处理的IP数据包</strong>，而<strong>流套接字只能读取TCP协议的数据</strong>，<strong>数据报套接字只能读取UDP协议的数据</strong>。因此，如果要<strong>访问其他协议发送的数据必须使用原始套接</strong> 。</p>
<h2 id="第二章：UDP简单通信"><a href="#第二章：UDP简单通信" class="headerlink" title="第二章：UDP简单通信"></a>第二章：UDP简单通信</h2><h3 id="1-UDP简介"><a href="#1-UDP简介" class="headerlink" title="1.UDP简介"></a>1.UDP简介</h3><p>​        <strong>UDP协议定义了端口</strong>，<strong>同一个主机上的每个应用程序</strong>都需要<strong>指定唯一的端口号</strong>，并且规定<strong>网络中传输的数据包必须加上端口信息</strong>，当<strong>数据包到达主机</strong>以后，就<strong>可以根据端口号找到对应的应用程序</strong>。<strong>UDP协议比较简单，实现容易</strong>，<strong>但</strong>它<strong>没有确认机制</strong>，数据包一旦发出，无法知道对方是否收到，因此<strong>可靠性较差</strong>。</p>
<h3 id="2-UDP发送数据"><a href="#2-UDP发送数据" class="headerlink" title="2. UDP发送数据"></a>2. UDP发送数据</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># socket是全双工通信</span></span><br><span class="line"><span class="comment"># UDP发送数据步骤</span></span><br><span class="line"><span class="comment"># 1.创建套接字</span></span><br><span class="line"><span class="comment"># 2.绑定ip端口</span></span><br><span class="line"><span class="comment"># 3.发送数据</span></span><br><span class="line"><span class="comment"># 4.关闭套接字</span></span><br><span class="line"><span class="comment"># 导入socket库</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="comment"># 定义一个功能函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 1.创建套接字</span></span><br><span class="line">    udp_socket = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)</span><br><span class="line">    <span class="comment"># 2.绑定ip端口，不绑定自动分配端口</span></span><br><span class="line">    localaddr = (<span class="string">&quot;&quot;</span>, <span class="number">7788</span>)  <span class="comment"># 本地ip及选定端口</span></span><br><span class="line">    udp_socket.bind(localaddr)</span><br><span class="line">    <span class="comment"># 3.发送数据</span></span><br><span class="line">    <span class="comment"># 输入要发送的信息和地址</span></span><br><span class="line">    send_msg = <span class="built_in">input</span>(<span class="string">&quot;请输入要发送的信息：&quot;</span>)</span><br><span class="line">    recv_ip = <span class="built_in">input</span>(<span class="string">&quot;请输入目的ip：&quot;</span>)  <span class="comment"># 字符串</span></span><br><span class="line">    recv_port = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入目的端口：&quot;</span>))  <span class="comment"># 整型</span></span><br><span class="line">    recv_addr = (recv_ip, recv_port)</span><br><span class="line">    <span class="comment"># 发送信息选择utf-8编码</span></span><br><span class="line">    udp_socket.sendto(send_msg.encode(<span class="string">&quot;utf-8&quot;</span>), recv_addr)</span><br><span class="line">    <span class="comment"># 4.关闭套接字</span></span><br><span class="line">    udp_socket.close()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-UDP接收数据"><a href="#3-UDP接收数据" class="headerlink" title="3.UDP接收数据"></a>3.UDP接收数据</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># UDP发送数据步骤</span></span><br><span class="line"><span class="comment"># 1.创建套接字</span></span><br><span class="line"><span class="comment"># 2.绑定ip端口</span></span><br><span class="line"><span class="comment"># 3.接收数据</span></span><br><span class="line"><span class="comment"># 4.关闭套接字</span></span><br><span class="line"><span class="comment"># 接收数据时是阻塞状态</span></span><br><span class="line"><span class="comment"># 导入socket库</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="comment"># 定义一个功能函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 1.创建套接字</span></span><br><span class="line">    udp_socket = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)</span><br><span class="line">    <span class="comment"># 2.绑定ip端口</span></span><br><span class="line">    localaddr = (<span class="string">&quot;&quot;</span>, <span class="number">7788</span>)  <span class="comment"># 本地ip及选定端口</span></span><br><span class="line">    udp_socket.bind(localaddr)</span><br><span class="line">    <span class="comment"># 3.接收数据</span></span><br><span class="line">    <span class="comment"># 接收信息,接收的信息为((msg)(ip,port))</span></span><br><span class="line">    recv_data = udp_socket.recvfrom(<span class="number">1024</span>)  <span class="comment"># 一次接收字节数</span></span><br><span class="line">    recv_msg = recv_data[<span class="number">0</span>]</span><br><span class="line">    send_addr = recv_data[<span class="number">1</span>]</span><br><span class="line">    <span class="comment"># 显示时需要把信息进行解码，Windows默认gbk</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%s:%s&quot;</span> % (<span class="built_in">str</span>(send_addr), recv_msg.decode(<span class="string">&quot;utf-8&quot;</span>)))</span><br><span class="line">    <span class="comment"># 4.关闭套接字</span></span><br><span class="line">    udp_socket.close()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h2 id="第三章：TCP简单通信"><a href="#第三章：TCP简单通信" class="headerlink" title="第三章：TCP简单通信"></a>第三章：TCP简单通信</h2><h3 id="1-TCP简介"><a href="#1-TCP简介" class="headerlink" title="1. TCP简介"></a>1. TCP简介</h3><p>​        <strong>TCP即传输控制协议</strong>，是一种面向连接的、可靠的、基于字节流的通信协议。简单来说<strong>TCP就是有确认机制的UDP协议</strong>，每发出一个数据包都要求确认，如果有一个数据包丢失，就收不到确认，发送方就必须重发这个数据包。为了保证传输的可靠性，<strong>TCP协议在UDP基础之上建立了三次对话的确认机制</strong>，即在<strong>正式收发数据前</strong>，<strong>必须和对方建立可靠的连接</strong>。TCP数据包和UDP一样，都是由首部和数据两部分组成，唯一不同的是，<strong>TCP数据包没有长度限制</strong>，<strong>理论上可以无限长</strong>，但是为了保证网络的效率，<strong>通常TCP数据包的长度不会超过IP数据包的长度</strong>，以<strong>确保单个TCP数据包不必再分割</strong>。</p>
<p>​        <code>TCP与UDP</code>的区别就像打<code>电话与写信</code>的区别。<strong>UDP</strong>由于其接收的阻塞模式，以及类似信件的邮寄模式，<strong>存在</strong>着很大的信息<strong>被拦截丢失的风险</strong>；而<strong>TCP</strong>的通信模式存在着一个<strong>应答机制</strong>，当接收方<strong>收不到信息</strong>或者信息有误时，<strong>请求重传</strong>。</p>
<h4 id="2-TCP客户端"><a href="#2-TCP客户端" class="headerlink" title="2.TCP客户端"></a>2.TCP客户端</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 与UDP不同的是TCP分为客户端和服务端</span></span><br><span class="line"><span class="comment"># TCP客户端步骤</span></span><br><span class="line"><span class="comment"># 1.创建TCP套接字</span></span><br><span class="line"><span class="comment"># 2.连接服务器</span></span><br><span class="line"><span class="comment"># 3.发送/接收数据</span></span><br><span class="line"><span class="comment"># 4.关闭套接字</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 1.创建套接字</span></span><br><span class="line">    tcp_socket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">    <span class="comment"># 2.连接服务器</span></span><br><span class="line">    server_ip = <span class="built_in">input</span>(<span class="string">&quot;请输入目的服务器ip：&quot;</span>) </span><br><span class="line">    server_port = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入目的服务器端口：&quot;</span>)) </span><br><span class="line">    server_addr = (server_ip, server_port)</span><br><span class="line">    tcp_socket.connect(server_addr)</span><br><span class="line">    <span class="comment"># 3.发送/接收数据</span></span><br><span class="line">    <span class="comment"># 发送数据</span></span><br><span class="line">    send_data = <span class="built_in">input</span>(<span class="string">&quot;请输入要发送的信息：&quot;</span>)</span><br><span class="line">    tcp_socket.send(send_data.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">    <span class="comment"># 4.关闭套接字</span></span><br><span class="line">    tcp_socket.close()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h3 id="3-TCP服务器"><a href="#3-TCP服务器" class="headerlink" title="3.TCP服务器"></a>3.TCP服务器</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># TCP服务器步骤</span></span><br><span class="line"><span class="comment"># 1.创建TCP套接字</span></span><br><span class="line"><span class="comment"># 2.绑定ip和Port</span></span><br><span class="line"><span class="comment"># 3.使套接字从默认状态变为被动（listen）</span></span><br><span class="line"><span class="comment"># 4.等待客户端链接（accept）分配新套接字</span></span><br><span class="line"><span class="comment"># 5.新套接字接收数据</span></span><br><span class="line"><span class="comment"># 6.回复确认消息</span></span><br><span class="line"><span class="comment"># 7.关闭套接字</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 1.创建套接字</span></span><br><span class="line">    tcp_socket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">    <span class="comment"># 2.绑定ip和Port</span></span><br><span class="line">    server_ip = <span class="built_in">input</span>(<span class="string">&quot;请输入绑定ip：&quot;</span>) </span><br><span class="line">    server_port = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入绑定端口：&quot;</span>)) </span><br><span class="line">    server_addr = (server_ip, server_port)</span><br><span class="line">    tcp_socket.bind(server_addr)</span><br><span class="line">    <span class="comment"># 3.使套接字从默认状态变为被动（listen）</span></span><br><span class="line">    tcp_socket.listen(<span class="number">128</span>)</span><br><span class="line">    <span class="comment"># 为多个客户端服务</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 4.等待客户端链接（accept 返回值为（新套接字，地址）</span></span><br><span class="line">        <span class="comment"># 客户端请求监听套接字，监听套接字分配新套接字为客户端服务</span></span><br><span class="line">        new_tcp_socket,client_addr = tcp_socket.accept()</span><br><span class="line">        <span class="comment"># 为一个客户端多次服务</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># 5.新套接字接收数据(返回值只有数据)</span></span><br><span class="line">            recv_data = new_tcp_socket.recv(<span class="number">1024</span>)</span><br><span class="line">            <span class="comment"># 6.回复确认消息,对方关闭连接退出</span></span><br><span class="line">            <span class="keyword">if</span> recv_data:  <span class="comment"># recv_data解阻塞且返回值不为空</span></span><br><span class="line">                new_tcp_socket.send(<span class="string">&quot;确认收到&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 7.关闭套接字</span></span><br><span class="line">        new_tcp_socket.close()</span><br><span class="line">    tcp_socket.close()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h1 id="多任务-amp-线程、进程、协程"><a href="#多任务-amp-线程、进程、协程" class="headerlink" title="多任务&amp;线程、进程、协程"></a>多任务&amp;线程、进程、协程</h1><h2 id="第一章：线程"><a href="#第一章：线程" class="headerlink" title="第一章：线程"></a>第一章：线程</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p>​        当想要<strong>程序同时执行多个功能</strong>时，即需要开启<strong>多任务</strong>。</p>
<p>​        实际情况来讲，<strong>单核cpu</strong>并<strong>不能真正的实现</strong>两个程序<strong>同时运行</strong>，由于CPU的执行速度很快，<strong>为每个程序分配极短的时间运行不停循环</strong>，就能够让我们看上去像是程序在同时运行，这种方式称为<strong>时间片轮转</strong>；<strong>多核cpu</strong>，<strong>每个核单独处理一个事务</strong>，是<strong>真正的多任务</strong>。<strong>假的多任务称为并发，真的多任务称为并行。</strong></p>
<h3 id="2-函数线程使用"><a href="#2-函数线程使用" class="headerlink" title="2.函数线程使用"></a>2.函数线程使用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time,threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sing</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;-----singing-------&quot;</span>)</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dance</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;-----dancing-------&quot;</span>)</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    t1 = threading.Thread(target=sing)</span><br><span class="line">    t2 = threading.Thread(target=dance)</span><br><span class="line">    </span><br><span class="line">    t1.start()  <span class="comment"># 此时创建线程，开始运行线程</span></span><br><span class="line">    t2.start()</span><br><span class="line">    <span class="comment"># 当调用的线程执行结束，线程结束</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># .enumerate方法返回一个线程列表</span></span><br><span class="line">        length = threading.<span class="built_in">enumerate</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> length:</span><br><span class="line">            <span class="built_in">print</span>(i)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;当前运行线程数目：%d&quot;</span> % <span class="built_in">len</span>(length))</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"><span class="comment"># PS：threading.Thread(target=`函数名`,args=`传递参数`)</span></span><br></pre></td></tr></table></figure>
<h3 id="3-类线程使用"><a href="#3-类线程使用" class="headerlink" title="3.类线程使用"></a>3.类线程使用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 线程不止可以指向一个函数，也可以是一个类</span></span><br><span class="line"><span class="keyword">import</span> time,threading</span><br><span class="line"><span class="comment"># 新建类必须继承 threading.Thread</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mythread</span>(threading.Thread):</span><br><span class="line">    <span class="comment"># 类里面执行的是run方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;-----dancing-------&quot;</span>)</span><br><span class="line">            time.sleep(<span class="number">0.5</span>)</span><br><span class="line">            </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    t = Mythread()</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure>
<h3 id="4-资源竞争"><a href="#4-资源竞争" class="headerlink" title="4.资源竞争"></a>4.资源竞争</h3><p>​        <strong>多线程中共享全局变量</strong>，有<strong>两个线程同时对一个变量</strong>进行操作时，由于多线程<strong>时间片轮转</strong>的实现方式，可能会出现问题，该现象称为<strong>资源竞争</strong>。</p>
<p>​        例如两个线程同时对全局变量做加法，<code>g_num += 1</code>，那么在CPU执行过程中可能会分为三步执行（<code>1.调取全局变量g_num的值(g_num=1)；2.对g_num进行+1(g_num=2)；3.赋值g_num=2</code>），如下图所示，<code>线程1</code>未能在分配时间内存储新值到变量，<code>线程2</code>运行改变变量值，当<code>线程1</code>再次运行时，该线程用上次计算好的值覆盖掉当前变量值，<code>线程2</code>相当于没有改变变量值，导致程序结果不符合预期。</p>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  
  </pre></div>
<pre class="mermaid">sequenceDiagram

        participant 线程1 as 线程1
        participant cpu as CPU
        participant 线程2 as 线程2  
        线程1 ->> cpu: 线程1调用
        Note over 线程1,cpu: 3.赋值g_num=1<br/>1.调取全局变量g_num的值(g_num=1)<br/>2.对g_num进行+1(g_num=1)
        cpu  ->> 线程1: 线程1停止调用 
        activate 线程2
        线程2 ->> cpu: 线程2调用
        Note over 线程2,cpu: 1.调取全局变量g_num的值(g_num=1)<br/>2.对g_num进行+1(g_num=2)<br/>3.赋值g_num=2
        cpu  ->> 线程2: 线程2停止调用 
        线程1 ->> cpu: 线程1调用
        Note over 线程1,cpu: 3.赋值g_num=2<br/>1.调取全局变量g_num的值(g_num=2)<br/>2.对g_num进行+1(g_num=2)
        cpu  ->> 线程1: 线程1停止调用</pre>

<h4 id="4-1-互斥锁"><a href="#4-1-互斥锁" class="headerlink" title="4.1.互斥锁"></a>4.1.互斥锁</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 为了解决资源竞争问题，当线程1调用全局变量时，给变量上锁</span></span><br><span class="line"><span class="comment"># 线程2要等待变量锁打开才能访问变量，继续执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建互斥锁</span></span><br><span class="line">mutex = threading.Lock()</span><br><span class="line"><span class="comment"># 锁定</span></span><br><span class="line">mutex.acquire()</span><br><span class="line"><span class="comment"># 释放</span></span><br><span class="line">mutex.release()</span><br><span class="line"></span><br><span class="line"><span class="comment"># PS:默认互斥锁是未上锁状态，上锁代码越少越好</span></span><br></pre></td></tr></table></figure>
<h4 id="4-2-死锁"><a href="#4-2-死锁" class="headerlink" title="4.2.死锁"></a>4.2.死锁</h4><p>​        当有<strong>多个线程</strong>，每个线程内有<strong>多个不同的锁</strong>时，会发生<code>线程A</code>等待<code>线程B</code>中的<strong>锁1解锁</strong>,<code>线程B</code>等待<code>线程A</code>中的<strong>锁2解锁</strong>，造成<strong>互相等待解锁</strong>的死锁局面。</p>
<p>如何避免死锁?</p>
<ul>
<li>程序设计时要尽量避免(<strong>银行家算法</strong>)</li>
<li>添加超时时间</li>
</ul>
<p>PS ：<strong>银行家算法：</strong>使得所有流程按照不会出现死锁的流程进行设计（合理安排的思想）。</p>
<h2 id="第二章：进程"><a href="#第二章：进程" class="headerlink" title="第二章：进程"></a>第二章：进程</h2><h3 id="1-简介-1"><a href="#1-简介-1" class="headerlink" title="1.简介"></a>1.简介</h3><p>​        在日常使用中.exe文件称为程序，<strong>运行</strong>.exe文件，产生<strong>的可以调用资源的程序称为进程。</strong></p>
<p>​        <code>进程</code>可以理解为<strong>应用多开</strong>，<code>线程</code>可以理解为<strong>一个应用的多个功能</strong>。也就是<strong>有了进程才能创建线程</strong>，进程运行时，<strong>多个进程会复制使用多套资源，多线程共用一套资源</strong>。</p>
<h3 id="2-进程创建"><a href="#2-进程创建" class="headerlink" title="2.进程创建"></a>2.进程创建</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进程创建与线程几乎一致</span></span><br><span class="line"><span class="keyword">import</span> time,multiprocessing </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sing</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;-----singing-------&quot;</span>)</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dance</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;-----dancing-------&quot;</span>)</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    p1 = multiprocessing.Process(target=sing)</span><br><span class="line">    p2 = multiprocessing.Process(target=dance)</span><br><span class="line">    </span><br><span class="line">    p1.start()  <span class="comment"># 此时创建进程，开始运行进程</span></span><br><span class="line">    p2.start()</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h3 id="3-进程间通信"><a href="#3-进程间通信" class="headerlink" title="3.进程间通信"></a>3.进程间通信</h3><h4 id="3-1-简单通信方式"><a href="#3-1-简单通信方式" class="headerlink" title="3.1.简单通信方式"></a>3.1.简单通信方式</h4><ul>
<li><strong>Socket：</strong>使用网络，可实现<strong>不同计算机的进程通信</strong>。</li>
<li><strong>文件：</strong>两个进程对一个文件进行读写，但由于硬盘速度很慢。</li>
<li><strong>Queue：</strong>队列，将<strong>数据存到一块内存</strong>中，<strong>先进先出</strong>，可多个进程读取，只能同一程序，同一电脑使用。</li>
</ul>
<h4 id="3-2-队列（Queue）"><a href="#3-2-队列（Queue）" class="headerlink" title="3.2.队列（Queue）"></a>3.2.队列（Queue）</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 队列能够降低程序的耦合性</span></span><br><span class="line"><span class="comment"># Queue的常用函数</span></span><br><span class="line"><span class="comment"># 创建一个内存区域</span></span><br><span class="line">q = multiprocessing.Queue(`存入数据数目`)</span><br><span class="line"><span class="comment"># 放入数据,当队列放满时,put等待，nowait不等待，返回异常</span></span><br><span class="line">q.put(数据)/q.put_nowait(数据)</span><br><span class="line"><span class="comment"># 取出数据,当队列为空时,get等待，nowait不等待，返回异常</span></span><br><span class="line">q.get()/q.get_nowait()</span><br><span class="line"><span class="comment"># 判断队列是否为空，为空返回true，不为空返回false</span></span><br><span class="line">q.empty()</span><br><span class="line"><span class="comment"># 判断队列是否为满，为满返回true，不为满返回false</span></span><br><span class="line">q.full()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 简单使用</span></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">put_data</span>(<span class="params">q</span>):</span><br><span class="line">    data = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">        q.put(i)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;放入完成&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_date</span>(<span class="params">q</span>):</span><br><span class="line">    data_get = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data = q.get()</span><br><span class="line">        data_get.append(data)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> q.empty():</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span>(data_get)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 1.创建一个队列</span></span><br><span class="line">    q = multiprocessing.Queue(<span class="number">5</span>)</span><br><span class="line">    <span class="comment"># 2.创建多进程,传递参数,参数形式必须为元组</span></span><br><span class="line">    p1 = multiprocessing.Process(target=put_data, args=(q,))</span><br><span class="line">    p2 = multiprocessing.Process(target=get_date,args=(q,) )</span><br><span class="line">    </span><br><span class="line">    p1.start()  <span class="comment"># 此时创建进程，开始运行进程</span></span><br><span class="line">    p2.start()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()        </span><br></pre></td></tr></table></figure>
<h4 id="3-3-进程池（Pool）"><a href="#3-3-进程池（Pool）" class="headerlink" title="3.3.进程池（Pool）"></a>3.3.进程池（Pool）</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进程池是为了重复使用进程，减少资源损耗</span></span><br><span class="line"><span class="comment"># 进程数量很多的时候使用</span></span><br><span class="line"><span class="comment"># 导入进程池库</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool </span><br><span class="line"><span class="comment"># 进程池的创建，最多n个</span></span><br><span class="line">po = Pool(n)</span><br><span class="line"><span class="comment"># 向进程池添加任务，Pool().apply_async(调用目标,(参数元组,))</span></span><br><span class="line">po.apply_async(woker,(i,))  </span><br><span class="line"><span class="comment"># 进程池内放不下的进程会在等待区等待空位，有空位自动填充</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭进程池，进程池不再接收新请求</span></span><br><span class="line">po.close()</span><br><span class="line"><span class="comment"># 关闭进程池的时候可能进程尚未结束，继续执行主进程可能运行结束</span></span><br><span class="line"><span class="comment"># 添加语句等待进程池内进程执行结束，必须用在close语句后</span></span><br><span class="line">po.join()</span><br></pre></td></tr></table></figure>
<h3 id="4-文件copy-多进程"><a href="#4-文件copy-多进程" class="headerlink" title="4.文件copy(多进程)"></a>4.文件copy(多进程)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 想要进行多文件copy，导入os，multiprocessing</span></span><br><span class="line"><span class="keyword">import</span> os, multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">copy_file</span>(<span class="params">q, file_name, old_folder_name</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;copy file to new file&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 打开文件夹，并且读取内容</span></span><br><span class="line">    old_file = <span class="built_in">open</span>(old_folder_name + <span class="string">&quot;/&quot;</span> + file_name, <span class="string">&quot;rb&quot;</span>)</span><br><span class="line">    content = old_file.read()</span><br><span class="line">    old_file.close()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建新文件夹，将文件复制到新文件夹</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        new_folder_name = old_folder_name + <span class="string">&quot;[副本]&quot;</span></span><br><span class="line">        os.makedirs(new_folder_name)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    new_file = <span class="built_in">open</span>(new_folder_name + <span class="string">&quot;/&quot;</span> + file_name, <span class="string">&quot;wb&quot;</span>)</span><br><span class="line">    new_file.write(content)</span><br><span class="line">    new_file.close()</span><br><span class="line"></span><br><span class="line">    q.put(file_name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 输入文件名，修改路径格式</span></span><br><span class="line">    old_folder_name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    k = <span class="built_in">input</span>(<span class="string">&quot;请输入需复制的文件名称：&quot;</span>).split(<span class="string">&quot;\\&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> k:</span><br><span class="line">        old_folder_name = old_folder_name + i + <span class="string">&quot;/&quot;</span></span><br><span class="line">    old_folder_name = <span class="built_in">list</span>(old_folder_name)</span><br><span class="line">    old_folder_name.pop()</span><br><span class="line">    old_folder_name = <span class="string">&quot;&quot;</span>.join(old_folder_name)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 打开文件获取文件内容 listdir()</span></span><br><span class="line">    file_names = os.listdir(old_folder_name)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建进程池</span></span><br><span class="line">    po = multiprocessing.Pool(<span class="number">5</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 想要进程间传递参数，必须使用进程间通信Queue()</span></span><br><span class="line">    <span class="comment"># 进程池内想使用要先调用Manager()</span></span><br><span class="line">    q = multiprocessing.Manager().Queue()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 复制文件，向进程池中添加进程</span></span><br><span class="line">    <span class="keyword">for</span> file_name <span class="keyword">in</span> file_names:</span><br><span class="line">        po.apply_async(copy_file, (q, file_name, old_folder_name,))</span><br><span class="line">    po.close()</span><br><span class="line">    </span><br><span class="line">    num,p = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    <span class="comment"># 显示复制进度</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> num == <span class="built_in">len</span>(file_names):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        m = q.get()</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">        p = num*<span class="number">100</span>/<span class="built_in">len</span>(file_names)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\r已经复制%.2f %%&quot;</span> % p,end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="comment"># 结束</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h2 id="第三章：协程"><a href="#第三章：协程" class="headerlink" title="第三章：协程"></a>第三章：协程</h2><blockquote>
<blockquote>
<p>Python中特有的实现多任务的一种方式，在线程中等待的时候可以去执行其他任务，消耗的资源更少，运行效率更高。</p>
</blockquote>
</blockquote>
<h3 id="1-迭代器"><a href="#1-迭代器" class="headerlink" title="1.迭代器"></a>1.迭代器</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.什么是迭代？</span></span><br><span class="line"><span class="comment"># 在原来的基础上添加新的东西，得到新版本</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.怎么判断是迭代对象？</span></span><br><span class="line"><span class="keyword">from</span> collectioms <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="built_in">isinstance</span>(判断的对象，Iterable)</span><br><span class="line"><span class="comment"># 返回值为True则为可迭代对象</span></span><br><span class="line"><span class="comment"># 类里面有__iter__方法的称为迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.for循环如何判断并进行迭代</span></span><br><span class="line"><span class="comment">#    1.判断对象所在类的是否有__iter__方法</span></span><br><span class="line"><span class="comment">#    2.调用__iter__方法</span></span><br><span class="line"><span class="comment">#    3.__iter__方法的返回值是迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.如何判断对象为迭代器</span></span><br><span class="line"><span class="keyword">from</span> collectioms <span class="keyword">import</span> Iterator</span><br><span class="line"><span class="built_in">isinstance</span>(判断的对象，Iterator)</span><br><span class="line"><span class="comment"># 返回值为True则为可迭代器</span></span><br><span class="line"><span class="comment"># 类里面有__iter__和__next__方法的称为迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.自己创建的类是否是可迭代对象？</span></span><br><span class="line"><span class="comment"># 创建的普通类是不能够被迭代的</span></span><br><span class="line"><span class="comment"># 如果想要创建的类可以使用迭代必须加入__iter__方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Classmate</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.name = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 要想能够进行迭代，必须返回有__iter__和__next__方法的对象即迭代器</span></span><br><span class="line">        <span class="keyword">return</span> ClassIterator(self)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassIterator</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment"># 想要迭代其他类中的对象需要引入对象</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,obj</span>):</span><br><span class="line">        self.obj = obj</span><br><span class="line">        self.num = <span class="number">0</span>  <span class="comment"># 创建一个全局变量来使__next__方法进行循环</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.num &lt;= <span class="built_in">len</span>(self.obj.name): </span><br><span class="line">            <span class="keyword">return</span> self.obj.name[self.num]</span><br><span class="line">            self.num += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration  <span class="comment"># for循环取完需要有异常才能判断</span></span><br><span class="line">            </span><br><span class="line"><span class="comment"># 6.只有for循环能够使用迭代吗？</span></span><br><span class="line"><span class="comment"># 除了for循环外还有 类型转换 也是用到了迭代器</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个可以自己迭代的迭代器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Itertest</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.num = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>]</span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.count&lt;=<span class="built_in">len</span>(self.num):</span><br><span class="line">            <span class="keyword">return</span> self.num[self.count]</span><br><span class="line">            self.count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br></pre></td></tr></table></figure>
<h3 id="2-生成器"><a href="#2-生成器" class="headerlink" title="2.生成器"></a>2.生成器</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 简单说生成器是特殊的迭代器，生成器执行时会在上次执行的地方继续执行</span></span><br><span class="line"><span class="comment"># 创建生成器的方式</span></span><br><span class="line"><span class="comment"># 1.创建列表的中括号变为小括号</span></span><br><span class="line">num = [x*<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]  <span class="comment"># 创建了一个列表</span></span><br><span class="line">num = (x*<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))  <span class="comment"># 创建了一个生成器，可用for迭代</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.使用yield，当函数里有yield语句，就不再是函数，而是生成器模板</span></span><br><span class="line"><span class="comment"># 当调用这个函数时，不是调用函数，而是创建一个生成器对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成器使用</span></span><br><span class="line"><span class="built_in">next</span>(f)  <span class="comment"># 不能往里面传参数</span></span><br><span class="line">f.send()  <span class="comment"># 可以往外面传参数,第一次用send传值只能是None    </span></span><br></pre></td></tr></table></figure>
<h3 id="3-使用yield实现多任务"><a href="#3-使用yield实现多任务" class="headerlink" title="3.使用yield实现多任务"></a>3.使用yield实现多任务</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># yield实现多任务</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test1</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;-------1--------&quot;</span>)</span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test2</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;-------2--------&quot;</span>)</span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="built_in">next</span>(test1())</span><br><span class="line">    <span class="built_in">next</span>(test2())</span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="4-协程实现多任务"><a href="#4-协程实现多任务" class="headerlink" title="4.协程实现多任务"></a>4.协程实现多任务</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 协程切换相当于调用函数，所用资源最少</span></span><br><span class="line"><span class="comment"># gevent实现多任务，安装gevent包</span></span><br><span class="line"><span class="comment"># gevent将yield功能打包扩展</span></span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="built_in">print</span>(gevent.getcurrent(),i)</span><br><span class="line">        <span class="comment"># gevent中的延时,协程延迟等待时自动切换</span></span><br><span class="line">        gevent.sleep(<span class="number">0.5</span>)</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 创建协程</span></span><br><span class="line">g1 = gevent.spawn(f,<span class="number">5</span>)</span><br><span class="line">g2 = gevent.spawn(f,<span class="number">5</span>)</span><br><span class="line">g3 = gevent.spawn(f,<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 开启协程</span></span><br><span class="line">g1.join()</span><br><span class="line">g2.join()</span><br><span class="line">g3.join()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注意事项</span></span><br><span class="line"><span class="comment"># 1.协程是在一个函数处于等待状态时自动切换至另一函数，如果函数中没有延时，则会执行完程序。</span></span><br><span class="line"><span class="comment"># 2.程序中的延时如time.sleep()和socket接收等待，不能够作为协程中的延时直接使用，要想使用需添加以下代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将所有的延时操作全部修改为gevent内的延时</span></span><br><span class="line">monkey.patch_all()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="built_in">print</span>(gevent.getcurrent(),i)</span><br><span class="line">        <span class="comment"># time延时,协程延迟等待时自动切换</span></span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 创建开启协程,将上面的代码综合使用，更简洁</span></span><br><span class="line">gevent.joinall([</span><br><span class="line">    gevent.spawn(f,<span class="number">5</span>),</span><br><span class="line">    gevent.spawn(f,<span class="number">5</span>),</span><br><span class="line">    gevent.spawn(f,<span class="number">5</span>)])</span><br></pre></td></tr></table></figure>
<h3 id="5-图片下载器"><a href="#5-图片下载器" class="headerlink" title="5.图片下载器"></a>5.图片下载器</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 图片，视频等从网页上下载都有一个等待的过程，此时可以使用协程，实现多个任务同时下载</span></span><br><span class="line"><span class="comment"># 导入需要的模块</span></span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</span><br><span class="line"></span><br><span class="line">monkey.patch_all()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">downloader</span>(<span class="params">img_name, img_url</span>):</span><br><span class="line">    req = urllib.request.urlopen(img_url)</span><br><span class="line">    </span><br><span class="line">    img_content = req.read()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(img_name, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(img_content)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    img_url = <span class="built_in">list</span>()</span><br><span class="line">    img_name = <span class="built_in">input</span>(<span class="string">&quot;请输入下载位置：&quot;</span>)</span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i:</span><br><span class="line">        <span class="keyword">if</span> i!=<span class="number">1</span>:</span><br><span class="line">            img_url.append(i)</span><br><span class="line">        i = <span class="built_in">input</span>(<span class="string">&quot;请输入图片链接:&quot;</span>)</span><br><span class="line">  </span><br><span class="line">    gevent.joinall([</span><br><span class="line">        gevent.spawn(downloader, img_name+<span class="string">&quot;/1.jpg&quot;</span>, img_url[<span class="number">0</span>] ),</span><br><span class="line">        gevent.spawn(downloader, img_name+<span class="string">&quot;/2.jpg&quot;</span>, img_url[<span class="number">1</span>] )</span><br><span class="line">    ])</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h1 id="网络爬虫"><a href="#网络爬虫" class="headerlink" title="网络爬虫"></a>网络爬虫</h1><h2 id="第一章：引言"><a href="#第一章：引言" class="headerlink" title="第一章：引言"></a>第一章：引言</h2><h3 id="1-爬虫概念"><a href="#1-爬虫概念" class="headerlink" title="1.爬虫概念"></a>1.爬虫概念</h3><p>​        爬虫模拟浏览器，发送请求，获取响应。重要的是如何去模拟浏览器。</p>
<h3 id="2-爬虫作用"><a href="#2-爬虫作用" class="headerlink" title="2.爬虫作用"></a>2.爬虫作用</h3><ul>
<li>数据采集</li>
<li>软件测试</li>
<li>12306抢票</li>
<li>网站投票刷票</li>
<li>网络安全</li>
</ul>
<h3 id="3-爬虫的流程"><a href="#3-爬虫的流程" class="headerlink" title="3.爬虫的流程"></a>3.爬虫的流程</h3><ol>
<li>根据URL列表发送请求</li>
<li>获取响应，解析响应</li>
<li>提取URL(翻页/详情)保存数据</li>
<li>重复1-3</li>
</ol>
<h2 id="第二章：请求头与响应头"><a href="#第二章：请求头与响应头" class="headerlink" title="第二章：请求头与响应头"></a>第二章：请求头与响应头</h2><h3 id="1-http协议"><a href="#1-http协议" class="headerlink" title="1.http协议"></a>1.http协议</h3><p>向网页发送请求需要了解http/https协议，http和https概念和区别</p>
<p>http：超文本传输协议，默认端口80，明文传输，容易被拦截</p>
<p>https：http+ssl，带有安全套接字的超文本传输协议，默认端口443</p>
<h3 id="2-爬虫的请求头与响应头"><a href="#2-爬虫的请求头与响应头" class="headerlink" title="2.爬虫的请求头与响应头"></a>2.爬虫的请求头与响应头</h3><h4 id="2-1请求头格式"><a href="#2-1请求头格式" class="headerlink" title="2.1请求头格式"></a>2.1请求头格式</h4><p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202302101959660.PNG" alt="1"></p>
<h4 id="2-2网页的请求头"><a href="#2-2网页的请求头" class="headerlink" title="2.2网页的请求头"></a>2.2网页的请求头</h4><p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202302101959516.PNG" alt="捕获"></p>
<h4 id="2-3特别关注的请求头"><a href="#2-3特别关注的请求头" class="headerlink" title="2.3特别关注的请求头"></a>2.3特别关注的请求头</h4><ul>
<li>Content-Type</li>
<li>Host(主机和端口)：域名</li>
<li>Connection(链接类型)：长链接</li>
<li>Upgrade-Insecure-Requests(升级为HTTPS请求)：重定向</li>
<li><strong>User-Agent</strong>：浏览器及其用户信息</li>
<li><strong>Referer</strong>(页面跳转处)：上一条链接，防盗链(视频/图片)</li>
<li><strong>Cookie</strong>：状态信息，有时效性，需登录的网站</li>
<li>Authorization(用于表示HTTP协议中需要认证资源的认证信息)</li>
</ul>
<blockquote>
<p>加粗的为常用请求头</p>
</blockquote>
<h4 id="2-4特别关注的响应头"><a href="#2-4特别关注的响应头" class="headerlink" title="2.4特别关注的响应头"></a>2.4特别关注的响应头</h4><p><strong>Set-Cookie</strong> (对方服务器设置cookie到用户浏览器的缓存)</p>
<h2 id="第三章：常见的响应状态码"><a href="#第三章：常见的响应状态码" class="headerlink" title="第三章：常见的响应状态码"></a>第三章：常见的响应状态码</h2><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>类别</th>
<th>原因短语</th>
</tr>
</thead>
<tbody>
<tr>
<td>1XX</td>
<td>Informational（信息性状态码）</td>
<td>接受的请求正在处理</td>
</tr>
<tr>
<td>2XX</td>
<td>Success（成功状态码）</td>
<td>请求正常处理完毕</td>
</tr>
<tr>
<td>3XX</td>
<td>Redirection（重定向状态码）</td>
<td>需要进行附加操作以完成请求</td>
</tr>
<tr>
<td>4XX</td>
<td>Client Error（客户端错误状态码）</td>
<td>服务器无法处理请求</td>
</tr>
<tr>
<td>5XX</td>
<td>Server Error（服务器错误状态码）</td>
<td>服务器处理请求出错</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>100：这个状态码是告诉客户端应该继续发送请求，这个临时响应是用来通知客户端的，部分的请求服务器已经接受，但是客户端应继续发送求请求的剩余部分，如果请求已经完成，就忽略这个响应，而且服务器会在请求完成后向客户发送一个最终的结果</li>
</ul>
<ul>
<li><p>200 OK：请求已正常处理。</p>
</li>
<li><p>204 No Content：请求处理成功，但没有任何资源可以返回给客户端，一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。</p>
</li>
<li><p>206 Partial Content：是对资源某一部分的请求，该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range指定范围的实体内容。</p>
</li>
</ul>
<ul>
<li><p>301 Moved Permanently：资源的uri已更新，你也更新下你的书签引用吧。永久性重定向，请求的资源已经被分配了新的URI，以后应使用资源现在所指的URI。</p>
</li>
<li><p>302 Found：资源的URI已临时定位到其他位置了，姑且算你已经知道了这个情况了。临时性重定向。和301相似，但302代表的资源不是永久性移动，只是临时性性质的。换句话说，已移动的资源对应的URI将来还有可能发生改变。</p>
</li>
<li><p>303 See Other：资源的URI已更新，你是否能临时按新的URI访问。该状态码表示由于请求对应的资源存在着另一个URL，应使用GET方法定向获取请求的资源。303状态码和302状态码有着相同的功能，但303状态码明确表示客户端应当采用GET方法获取资源，这点与302状态码有区别。</p>
</li>
</ul>
<p>PS：当301,302,303响应状态码返回时，几乎所有的浏览器都会把POST改成GET，并删除请求报文内的主体，之后请求会自动再次发送。</p>
<ul>
<li><p>304 Not Modified：资源已找到，但未符合条件请求。该状态码表示客户端发送附带条件的请求时（采用GET方法的请求报文中包含If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since中任一首部）服务端允许请求访问资源，但因发生请求未满足条件的情况后，直接返回304.。</p>
</li>
<li><p>307 Temporary Redirect：临时重定向。与302有相同的含义。</p>
</li>
</ul>
<ul>
<li><p>400 Bad Request：服务器端无法理解客户端发送的请求，请求报文中可能存在语法错误。</p>
</li>
<li><p>401 Unauthorized：该状态码表示发送的请求需要有通过HTTP认证（BASIC认证，DIGEST认证）的认证信息。</p>
</li>
<li><p>403 Forbidden：不允许访问那个资源。该状态码表明对请求资源的访问被服务器拒绝了。（权限，未授权IP等）</p>
</li>
<li><p>404 Not Found：服务器上没有请求的资源。路径错误等。</p>
</li>
</ul>
<ul>
<li><p>500 Internal Server Error：貌似内部资源出故障了。该状态码表明服务器端在执行请求时发生了错误。也有可能是web应用存在bug或某些临时故障。</p>
</li>
<li><p>503 Service Unavailable：抱歉，我现在正在忙着。该状态码表明服务器暂时处于超负载或正在停机维护，现在无法处理请求。</p>
</li>
</ul>
<p><strong>PS：服务器已经识别出那你是爬虫时，可能会给你成功的状态码，但响应没数据，所有状态码都不可信，一切以是否从抓包中得到数据为准。</strong></p>
<p><strong>network中抓包得到的才是真正的源码，element中显示的源码是渲染过得到的。</strong></p>
<h2 id="第四章：浏览器与爬虫区别"><a href="#第四章：浏览器与爬虫区别" class="headerlink" title="第四章：浏览器与爬虫区别"></a>第四章：浏览器与爬虫区别</h2><h3 id="1-浏览器运行过程"><a href="#1-浏览器运行过程" class="headerlink" title="1.浏览器运行过程"></a>1.浏览器运行过程</h3><p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202302101959607.PNG" alt="3"></p>
<ol>
<li><p>浏览器拿到域名对应的ip后，先向地址栏中的url发起请求，并获取响应。</p>
</li>
<li><p>在返回的响应内容(html)中，会带有css，js，图片等URL地址，以及ajax代码、浏览器按照响应内容中的顺序一次发送其他的请求，并获取响应的响应。</p>
</li>
<li><p>浏览器每获取一个响应就对展示的结果进行加载，js，css等内容就会修改页面的内容，js也可再发送请求获取响应。</p>
</li>
<li><p>到所有响应请求结束，这个过程叫做浏览器的渲染。</p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202302102000339.PNG" alt="捕获-16378144186571"></p>
</li>
</ol>
<ul>
<li>骨骼文件：html静态文件</li>
<li>肌肉文件：js/ajax请求</li>
<li>皮肤：css/font/图片</li>
</ul>
<h3 id="2-爬虫抓包"><a href="#2-爬虫抓包" class="headerlink" title="2.爬虫抓包"></a>2.爬虫抓包</h3><ul>
<li>浏览器：发送所有请求，进行渲染</li>
<li>爬虫：只发送指定请求，不会渲染</li>
<li>抓包过程：根据发送请求的流程分别在骨骼/肌肉/皮肤响应中查找数据</li>
</ul>
<h2 id="第五章：requests模块"><a href="#第五章：requests模块" class="headerlink" title="第五章：requests模块"></a>第五章：requests模块</h2><blockquote>
<p><a href="https://docs.python-requests.org/zh_CN/latest/">https://docs.python-requests.org/zh_CN/latest/</a> 官方文档中快速入手需要精度，了解一下高级用法，使用到时再查找使用。</p>
</blockquote>
<h3 id="1-简单使用get"><a href="#1-简单使用get" class="headerlink" title="1.简单使用get"></a>1.简单使用get</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://www.baidu.com&#x27;</span></span><br><span class="line">response = requests.get(url)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(response.text)</span><br><span class="line"><span class="comment"># 发现输出返回的中文为乱码，其原因是二进制解码时是程序自己推测的解码方式</span></span><br><span class="line"><span class="comment"># 可使用response.encoding = &#x27;utf8&#x27;设置解码的解码方式</span></span><br><span class="line"><span class="comment"># response.content是储存的二进制的值,可以用.decode()进行解码,默认utf8</span></span><br><span class="line"><span class="built_in">print</span>(response.content.decode())</span><br></pre></td></tr></table></figure>
<h3 id="2-response响应对象和方法"><a href="#2-response响应对象和方法" class="headerlink" title="2.response响应对象和方法"></a>2.response响应对象和方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(response.url)  <span class="comment"># 响应url,有时响应url和请求的url不一样</span></span><br><span class="line"><span class="built_in">print</span>(response.status_code)  <span class="comment"># 响应状态码</span></span><br><span class="line"><span class="built_in">print</span>(response.request.headers)  <span class="comment"># 响应对应的请求头</span></span><br><span class="line"><span class="built_in">print</span>(response.headers)  <span class="comment"># 响应头</span></span><br><span class="line"><span class="built_in">print</span>(response.request._cookies)  <span class="comment"># 响应对应请求的cookie，返回cookiejar类型</span></span><br><span class="line"><span class="built_in">print</span>(response.cookies)  <span class="comment"># 响应的cookie(经过了set-cookie动作)，返回cookiejar类型</span></span><br><span class="line"><span class="built_in">print</span>(response.json)  <span class="comment"># 自动将json字符串类型的响应内容转换为python对象(dict or list)</span></span><br></pre></td></tr></table></figure>
<h3 id="3-携带请求头发送请求"><a href="#3-携带请求头发送请求" class="headerlink" title="3.携带请求头发送请求"></a>3.携带请求头发送请求</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模拟浏览器的请求头</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://www.baidu.com&#x27;</span></span><br><span class="line">headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36&#x27;</span>&#125;  <span class="comment">#请求头字典</span></span><br><span class="line">response = requests.get(url,headers=headers)</span><br><span class="line"><span class="built_in">print</span>(response.content.decode())</span><br></pre></td></tr></table></figure>
<h3 id="4-发送带参数的请求"><a href="#4-发送带参数的请求" class="headerlink" title="4.发送带参数的请求"></a>4.发送带参数的请求</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># url中？后的为参数，但有些参数是没有用的</span></span><br><span class="line"><span class="comment"># 通过不断的删除参数，可确定关键参数</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://www.baidu.com/s?&#x27;</span></span><br><span class="line">headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36&#x27;</span>&#125;  <span class="comment">#请求头字典</span></span><br><span class="line">data = &#123;<span class="string">&#x27;wd&#x27;</span>: <span class="string">&#x27;python&#x27;</span>&#125;  <span class="comment"># 请求参数字典</span></span><br><span class="line">response = requests.get(url,headers=headers,params=data)</span><br><span class="line"><span class="built_in">print</span>(response.url)</span><br><span class="line"><span class="comment"># 请求的url即为 http://www.baidu.com/s?wd=python</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL基础</title>
    <url>/link/c24675b4.html</url>
    <content><![CDATA[<h1 id="MySQL-amp-Python"><a href="#MySQL-amp-Python" class="headerlink" title="MySQL&amp;Python"></a>MySQL&amp;Python</h1><h2 id="引言：关于数据库"><a href="#引言：关于数据库" class="headerlink" title="引言：关于数据库"></a>引言：关于数据库</h2><blockquote>
<blockquote>
<p>数据库是用来记录和管理数据的仓库，数据库相对于文件能更快的管理和处理数据，数据库分类如下图所示。</p>
</blockquote>
</blockquote>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  
  </pre></div>
<pre class="mermaid">graph TD 
B(数据库)--> C1(关系型数据库)
B--> A(非关系型数据库) 
C1(关系型数据库) -->D(Oracle)
C1-->D1(Microsoft SQL Server)
C1 -->D2(MySQL)-->v[用于网页]
C1-->D3(SQLlite)
D1-->e[收费]
D-->e
D3-->e1[免费]
D2-->e1
D3-->e2[主要用于手机]
A-->b1(MongoDB)-->c2[爬虫]
A-->b2(Redis)-->c3[缓存]</pre>


<p>​        <strong>关系型数据库</strong>采用  <strong><em>行 (记录 )列 (字段 )—&gt;表—&gt;库</em> </strong> 的形式储存数据；<strong>非关系型数据库</strong>则采用  <strong><em>键值等类似字典</em> </strong>  的方式储存数据。数据库相对于其他的数据存储方式，有着<strong>持久化存储、读写速度极高、保证数据有效性</strong>等优点。数据库的调用框架如下图所示。</p>
<pre class="mermaid">graph LR
a(用户)-->b(数据库用户端)-->c(SQL语句)
c-->b(数据库用户端)
c-->d(数据库服务器端)
d-->c
d-->e1[数据库1]
d-->e2[数据库2]
d-->e3[......]</pre>


<p>​        <strong>SQL</strong>是用于<strong>关系型数据库</strong>的指令语言，具体的命令分为<strong><em>DQL(查询指令 )、DML(操作指令 )、DDL(定义指令 )、TPL(事务处理 )、DCL(数据控制 )</em></strong>几大类。</p>
<h2 id="第一章：基本SQL指令"><a href="#第一章：基本SQL指令" class="headerlink" title="第一章：基本SQL指令"></a>第一章：基本SQL指令</h2><blockquote>
<blockquote>
<p><strong>配置完成</strong>的MySQL，只需要在命令行输入mysql <del>-h <code>主机名</code>  -P <code>端口编号</code></del>  -u <code>用户名</code> -p <code>密码</code> 即可登录MySQL。</p>
<h3 id="1-库相关指令"><a href="#1-库相关指令" class="headerlink" title="1.库相关指令"></a>1.库相关指令</h3></blockquote>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">指令语句</th>
<th style="text-align:center">语句功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">create database <code>库名</code>  <br>char set= <code>编码方式UTF8</code>;</td>
<td style="text-align:center">创建一个库<br>指定一个编码方式（UTF8）</td>
</tr>
<tr>
<td style="text-align:center">show create database <code>库名</code>;</td>
<td style="text-align:center">展示创建的库的属性</td>
</tr>
<tr>
<td style="text-align:center">show databases;</td>
<td style="text-align:center">显示所有数据库</td>
</tr>
<tr>
<td style="text-align:center">use <code>库名</code>;</td>
<td style="text-align:center">进入指定库</td>
</tr>
<tr>
<td style="text-align:center">select database();</td>
<td style="text-align:center">显示现在所在库</td>
</tr>
<tr>
<td style="text-align:center">drop database <code>库名</code>;</td>
<td style="text-align:center">删除库</td>
</tr>
</tbody>
</table>
</div>
<h3 id="2-表相关指令"><a href="#2-表相关指令" class="headerlink" title="2.表相关指令"></a>2.表相关指令</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">指令语句</th>
<th style="text-align:center">语句功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">show tables;</td>
<td style="text-align:center">显示库内所有的表</td>
</tr>
<tr>
<td style="text-align:center">show tables from <code>库名</code>;</td>
<td style="text-align:center">不入库展示指定库所有表</td>
</tr>
<tr>
<td style="text-align:center">create table <code>表名</code>(<br><code>列名1</code>,<code>列数据类型</code>  <code>约束</code> ,<br><code>列名2</code>,<code>列数据类型</code>  <code>约束</code> ,<br/>……);</td>
<td style="text-align:center">创建一个表<br>第一列列名，数据类型和约束<br/>第二列列名，数据类型和约束<br/>……</td>
</tr>
<tr>
<td style="text-align:center">desc <code>表名</code>;</td>
<td style="text-align:center">查看表结构</td>
</tr>
<tr>
<td style="text-align:center">show create table <code>表名</code>;</td>
<td style="text-align:center">查看表创建语句</td>
</tr>
<tr>
<td style="text-align:center">alter table <code>表名</code> add <code>列名</code> <code>列数据类型</code>;</td>
<td style="text-align:center">向表中添加新列</td>
</tr>
<tr>
<td style="text-align:center">alter table <code>表名</code> modify <code>列名</code> <code>类型及约束</code>;</td>
<td style="text-align:center">修改指定列类型及约束</td>
</tr>
<tr>
<td style="text-align:center">alter table <code>表名</code> change <code>原名</code> <code>新名</code> <code>类型及约束</code>;</td>
<td style="text-align:center">重命名指定列并修改列类型及约束</td>
</tr>
<tr>
<td style="text-align:center">alter table <code>表名</code> drop <code>列名</code> ;<br>alter table <code>表名</code> drop column<code>列名1</code> ,<br/>drop column<code>列名2</code>,…… ;</td>
<td style="text-align:center">删除指定列<br/>删除多列必须有column</td>
</tr>
<tr>
<td style="text-align:center">drop table <code>表名</code> ;</td>
<td style="text-align:center">删除表</td>
</tr>
</tbody>
</table>
</div>
<h4 id="2-1数据类型"><a href="#2-1数据类型" class="headerlink" title="2.1数据类型"></a>2.1数据类型</h4><blockquote>
<blockquote>
<p>数据类型后加(<code>指定值</code>)，可指定数据大小。</p>
</blockquote>
</blockquote>
<h5 id="2-1-1数值类型"><a href="#2-1-1数值类型" class="headerlink" title="2.1.1数值类型"></a>2.1.1数值类型</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">大小(bytes)</th>
<th style="text-align:center">范围</th>
<th style="text-align:center">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">TINYINT</td>
<td style="text-align:center">1 byte</td>
<td style="text-align:center">(-128，127)</td>
<td style="text-align:center">小整数值</td>
</tr>
<tr>
<td style="text-align:center">SMALLINT</td>
<td style="text-align:center">2 bytes</td>
<td style="text-align:center">(-32 768，32 767)</td>
<td style="text-align:center">大整数值</td>
</tr>
<tr>
<td style="text-align:center">MEDIUMINT</td>
<td style="text-align:center">3 bytes</td>
<td style="text-align:center">(-8 388 608，8 388 607)</td>
<td style="text-align:center">大整数值</td>
</tr>
<tr>
<td style="text-align:center">INT或INTEGER</td>
<td style="text-align:center">4 bytes</td>
<td style="text-align:center">(-2 147 483 648，2 147 483 647)</td>
<td style="text-align:center">大整数值</td>
</tr>
<tr>
<td style="text-align:center">BIGINT</td>
<td style="text-align:center">8 bytes</td>
<td style="text-align:center">(-9,223,372,036,854,775,808，<br/>9 223 372 036 854 775 807)</td>
<td style="text-align:center">极大整数值</td>
</tr>
<tr>
<td style="text-align:center">FLOAT</td>
<td style="text-align:center">4 bytes</td>
<td style="text-align:center">(-3.402 823 466 E+38，<br/>-1.175 494 351 E-38)，<br>0，(1.175 494 351 E-38，<br/>3.402 823 466 351 E+38)</td>
<td style="text-align:center">单精度<br/>浮点数值</td>
</tr>
<tr>
<td style="text-align:center">DOUBLE</td>
<td style="text-align:center">8 bytes</td>
<td style="text-align:center">(-1.797 693 134 862 315 7 E+308，<br/>-2.225 073 858 507 201 4 E-308)，<br/>0，(2.225 073 858 507 201 4 E-308，<br/>1.797 693 134 862 315 7 E+308)</td>
<td style="text-align:center">双精度<br/>浮点数值</td>
</tr>
<tr>
<td style="text-align:center">DECIMAL</td>
<td style="text-align:center">对DECIMAL(M,D) ，如果M&gt;D，<br/>为M+2否则为D+2</td>
<td style="text-align:center">依赖于M和D的值</td>
<td style="text-align:center">小数值</td>
</tr>
</tbody>
</table>
</div>
<h5 id="2-1-2时间及日期类型"><a href="#2-1-2时间及日期类型" class="headerlink" title="2.1.2时间及日期类型"></a>2.1.2时间及日期类型</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">大小(bytes)</th>
<th style="text-align:center">格式</th>
<th style="text-align:center">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">DATE</td>
<td style="text-align:center">3bytes</td>
<td style="text-align:center">YYYY-MM-DD</td>
<td style="text-align:center">日期值</td>
</tr>
<tr>
<td style="text-align:center">TIME</td>
<td style="text-align:center">3bytes</td>
<td style="text-align:center">HH:MM:SS</td>
<td style="text-align:center">时间值或持续时间</td>
</tr>
<tr>
<td style="text-align:center">YEAR</td>
<td style="text-align:center">1byte</td>
<td style="text-align:center">YYYY</td>
<td style="text-align:center">年份值</td>
</tr>
<tr>
<td style="text-align:center">DATETIME</td>
<td style="text-align:center">8bytes</td>
<td style="text-align:center">YYYY-MM-DD HH:MM:SS</td>
<td style="text-align:center">混合日期和时间值</td>
</tr>
</tbody>
</table>
</div>
<h5 id="2-1-3字符串类型"><a href="#2-1-3字符串类型" class="headerlink" title="2.1.3字符串类型"></a>2.1.3字符串类型</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">大小(bytes)</th>
<th style="text-align:center">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">CHAR</td>
<td style="text-align:center">0-255 bytes</td>
<td style="text-align:center">定长字符串</td>
</tr>
<tr>
<td style="text-align:center">VARCHAR</td>
<td style="text-align:center">0-65535 bytes</td>
<td style="text-align:center">变长字符串</td>
</tr>
<tr>
<td style="text-align:center">TINYBLOB</td>
<td style="text-align:center">0-255 bytes</td>
<td style="text-align:center">不超过 255 个字符的二进制字符串</td>
</tr>
<tr>
<td style="text-align:center">TINYTEXT</td>
<td style="text-align:center">0-255 bytes</td>
<td style="text-align:center">短文本字符串</td>
</tr>
<tr>
<td style="text-align:center">BLOB</td>
<td style="text-align:center">0-65 535 bytes</td>
<td style="text-align:center">二进制形式的长文本数据</td>
</tr>
<tr>
<td style="text-align:center">TEXT</td>
<td style="text-align:center">0-65 535 bytes</td>
<td style="text-align:center">长文本数据</td>
</tr>
<tr>
<td style="text-align:center">MEDIUMBLOB</td>
<td style="text-align:center">0-16 777 215 bytes</td>
<td style="text-align:center">二进制形式的中等长度文本数据</td>
</tr>
<tr>
<td style="text-align:center">MEDIUMTEXT</td>
<td style="text-align:center">0-16 777 215 bytes</td>
<td style="text-align:center">中等长度文本数据</td>
</tr>
<tr>
<td style="text-align:center">LONGBLOB</td>
<td style="text-align:center">0-4 294 967 295 bytes</td>
<td style="text-align:center">二进制形式的极大文本数据</td>
</tr>
<tr>
<td style="text-align:center">LONGTEXT</td>
<td style="text-align:center">0-4 294 967 295 bytes</td>
<td style="text-align:center">极大文本数据</td>
</tr>
</tbody>
</table>
</div>
<h5 id="2-1-4其他类型"><a href="#2-1-4其他类型" class="headerlink" title="2.1.4其他类型"></a>2.1.4其他类型</h5><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">范围</th>
<th style="text-align:center">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">bit</td>
<td style="text-align:center">0,1，null</td>
<td style="text-align:center">一般用作标记</td>
</tr>
<tr>
<td style="text-align:center">enum</td>
<td style="text-align:center">指定对象范围，共可有0-65535</td>
<td style="text-align:center">2字节，整数管理，下标从1开始</td>
</tr>
<tr>
<td style="text-align:center">set</td>
<td style="text-align:center">指定对象范围，共可有0-64</td>
<td style="text-align:center">8字节，移位运算管理，下标从1开始</td>
</tr>
</tbody>
</table>
</div>
<h4 id="2-2约束"><a href="#2-2约束" class="headerlink" title="2.2约束"></a>2.2约束</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">primary key</td>
<td style="text-align:center">主键</td>
</tr>
<tr>
<td style="text-align:center">foreign key</td>
<td style="text-align:center">外键</td>
</tr>
<tr>
<td style="text-align:center">not null</td>
<td style="text-align:center">非空</td>
</tr>
<tr>
<td style="text-align:center">unique</td>
<td style="text-align:center">唯一值</td>
</tr>
<tr>
<td style="text-align:center">default  <code>0</code></td>
<td style="text-align:center">默认值</td>
</tr>
<tr>
<td style="text-align:center">auto_increment</td>
<td style="text-align:center">自动增长,<br>可用0，null，default占位</td>
</tr>
<tr>
<td style="text-align:center"><code>数据类型</code>  unsigned</td>
<td style="text-align:center">无符号类型</td>
</tr>
</tbody>
</table>
</div>
<h3 id="3-数据相关指令"><a href="#3-数据相关指令" class="headerlink" title="3.数据相关指令"></a>3.数据相关指令</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">指令语句</th>
<th style="text-align:center">语句功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">insert into <code>表名</code>(<code>列名</code>)  <br>values(<code>对应数据</code>),(<code>对应数据</code>),……；</td>
<td style="text-align:center">向表内添加数据,<br/>无列名默认全部列,<br/>可一次插入多组数据</td>
</tr>
<tr>
<td style="text-align:center">update <code>表名</code> set <code>列名1</code>=<code>值</code>, <br/><code>列名2</code>=<code>值</code>,……  where <code>约束条件</code>;</td>
<td style="text-align:center">更新约束条件下的指定列的值，<br/>无约束即所有</td>
</tr>
<tr>
<td style="text-align:center">seclect * from <code>表名</code> where <code>约束条件</code>;</td>
<td style="text-align:center">显示表内所有符合条件的数据，<br/>无约束即所有</td>
</tr>
<tr>
<td style="text-align:center">seclect <code>列名1</code> as <code>别名</code> ,<br/><code>列名2</code> as <code>别名</code> ,…<br/>from <code>表名</code> where <code>约束条件</code>;</td>
<td style="text-align:center">显示表内所有符合条件的指定列的数据，<br/>列的名称可以指定别名，<br/>排列顺序为代码顺序</td>
</tr>
<tr>
<td style="text-align:center">delete from <code>表名</code> where <code>约束条件</code>;</td>
<td style="text-align:center">删除表内所有符合条件的数据，<br/>无约束即所有</td>
</tr>
<tr>
<td style="text-align:center">alter table <code>表名</code> add <code>列名</code> bit default 0;<br/>update <code>表名</code> set <code>列名</code>=1 where <code>约束条件</code>;</td>
<td style="text-align:center">向表里添加删除标记，<br/>把需要删除的数据标记为1，<br/>不真正删除数据</td>
</tr>
</tbody>
</table>
</div>
<h3 id="4-其他指令"><a href="#4-其他指令" class="headerlink" title="4.其他指令"></a>4.其他指令</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">指令语句</th>
<th style="text-align:center">语句功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">select getdata();</td>
<td style="text-align:center">查看当前时间</td>
</tr>
<tr>
<td style="text-align:center">select @@version;</td>
<td style="text-align:center">查看当前版本</td>
</tr>
<tr>
<td style="text-align:center">source  <code>sql文件地址</code>；</td>
<td style="text-align:center">导入运行sql文件</td>
</tr>
</tbody>
</table>
</div>
<h2 id="第二章：数据的查询"><a href="#第二章：数据的查询" class="headerlink" title="第二章：数据的查询"></a>第二章：数据的查询</h2><blockquote>
<blockquote>
<p>数据查询是数据库使用过程中用到最多的，数据查询可用于单表查询，也可用于多表查询。</p>
</blockquote>
</blockquote>
<h3 id="1-准备数据"><a href="#1-准备数据" class="headerlink" title="1.准备数据"></a>1.准备数据</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 首先创建一个库test,使用utf8编码</span></span><br><span class="line"><span class="keyword">create</span> database test charset<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看库是否创建成功</span></span><br><span class="line"><span class="keyword">show</span> databases;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用库</span></span><br><span class="line">use test;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看在使用的库</span></span><br><span class="line"><span class="keyword">select</span> database();</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建一个表单students</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> students (</span><br><span class="line">    id <span class="type">int</span> unsigned <span class="keyword">primary</span> key <span class="keyword">not</span> <span class="keyword">null</span>  auto_increment,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    gender enum(&quot;男&quot;,&quot;女&quot;,&quot;保密&quot;) <span class="keyword">default</span> &quot;保密&quot;,</span><br><span class="line">    age tinyint unsigned <span class="keyword">default</span> <span class="number">18</span>,</span><br><span class="line">    is_delete bit <span class="keyword">default</span> <span class="number">0</span> </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看表单是否创建成功</span></span><br><span class="line"><span class="keyword">show</span> tables;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看表单创建代码</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> students;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建另一个表单classes</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> classes(</span><br><span class="line">    id <span class="type">int</span> unsigned <span class="keyword">primary</span> key <span class="keyword">not</span> <span class="keyword">null</span> auto_increment,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">30</span>) <span class="keyword">not</span> <span class="keyword">null</span>  </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导入student数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> students(name,gender,age)</span><br><span class="line"> <span class="keyword">values</span>(&quot;张三&quot;,<span class="number">1</span>,<span class="number">18</span>),(&quot;林梦&quot;,<span class="number">2</span>,<span class="number">19</span>),(&quot;田甜&quot;,<span class="number">2</span>,<span class="number">20</span>),</span><br><span class="line"> (&quot;李四&quot;,<span class="number">1</span>,<span class="number">16</span>),(&quot;王五&quot;,<span class="number">1</span>,<span class="number">19</span>),(&quot;韩婷&quot;,<span class="number">2</span>,<span class="number">18</span>),</span><br><span class="line"> (&quot;赵六&quot;,<span class="number">1</span>,<span class="number">19</span>),(&quot;李洛璃&quot;,<span class="number">2</span>,<span class="number">22</span>),(&quot;肖八&quot;,<span class="number">1</span>,<span class="number">19</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 查看数据是否导入,数据多不建议全部查看</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> students;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导入class数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> classes(name) <span class="keyword">values</span></span><br><span class="line">(&quot;高一一班&quot;),(&quot;高二二班&quot;),(&quot;高三三班&quot;);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 突然发现第一个表没班级，新加班级字段</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> students <span class="keyword">add</span> cls_id </span><br><span class="line">   <span class="type">int</span> unsigned <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 更新班级信息</span></span><br><span class="line"><span class="keyword">update</span> students <span class="keyword">set</span> cls_id<span class="operator">=</span><span class="number">1</span> <span class="keyword">where</span> age<span class="operator">&lt;=</span><span class="number">18</span>;</span><br><span class="line"><span class="keyword">update</span> students <span class="keyword">set</span> cls_id<span class="operator">=</span><span class="number">2</span> <span class="keyword">where</span> age<span class="operator">=</span><span class="number">19</span>;</span><br><span class="line"><span class="keyword">update</span> students <span class="keyword">set</span> cls_id<span class="operator">=</span><span class="number">3</span> <span class="keyword">where</span> age<span class="operator">&gt;</span><span class="number">19</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 数据导入完成，删除库可用 drop database test;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-简单查询"><a href="#2-简单查询" class="headerlink" title="2.简单查询"></a>2.简单查询</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询所有字段</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> students;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> classes;</span><br><span class="line"><span class="comment">-- 查询指定字段</span></span><br><span class="line"><span class="keyword">select</span> id,name,gender <span class="keyword">from</span> students;</span><br><span class="line"><span class="keyword">select</span> students.id,students.name <span class="keyword">from</span> students;</span><br><span class="line"><span class="comment">-- 使用as给字段起别名</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">as</span> 序号,name <span class="keyword">as</span> 姓名,gender <span class="keyword">as</span> 性别 </span><br><span class="line"><span class="keyword">from</span> students;</span><br><span class="line"><span class="comment">-- 使用as给表起别名，不能使用原表名</span></span><br><span class="line"><span class="keyword">select</span> s.id,s.name <span class="keyword">from</span> students <span class="keyword">as</span> s;</span><br><span class="line"><span class="comment">-- 消除重复行 distinct </span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> gender <span class="keyword">from</span> students;</span><br></pre></td></tr></table></figure>
<h3 id="3-条件查询"><a href="#3-条件查询" class="headerlink" title="3.条件查询"></a>3.条件查询</h3><h4 id="3-1比较运算符"><a href="#3-1比较运算符" class="headerlink" title="3.1比较运算符"></a>3.1比较运算符</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询大于18岁的信息 &gt;</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> students <span class="keyword">where</span> age<span class="operator">&gt;</span><span class="number">18</span>;</span><br><span class="line"><span class="comment">-- 查询小于18岁的信息 &lt;</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> students <span class="keyword">where</span> age<span class="operator">&lt;</span><span class="number">18</span>;</span><br><span class="line"><span class="comment">-- 查询等于18岁的信息 =</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> students <span class="keyword">where</span> age<span class="operator">=</span><span class="number">18</span>;</span><br><span class="line"><span class="comment">-- 查询不等于18岁的信息 != , &lt;&gt;</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> students <span class="keyword">where</span> age<span class="operator">!=</span><span class="number">18</span>;</span><br></pre></td></tr></table></figure>
<h4 id="3-2逻辑运算符"><a href="#3-2逻辑运算符" class="headerlink" title="3.2逻辑运算符"></a>3.2逻辑运算符</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询18到19岁学生的信息 and</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> students <span class="keyword">where</span> age<span class="operator">&gt;=</span><span class="number">18</span> <span class="keyword">and</span> age<span class="operator">&lt;=</span><span class="number">19</span>;</span><br><span class="line"><span class="comment">-- 查询18岁以上或者女性 or</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> students <span class="keyword">where</span> age<span class="operator">&gt;=</span><span class="number">18</span> <span class="keyword">or</span> gender<span class="operator">=</span><span class="number">2</span>;</span><br><span class="line"><span class="comment">-- 查询查询不是 18岁以上女性 not</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> students <span class="keyword">where</span> </span><br><span class="line">    <span class="keyword">not</span> (age<span class="operator">&gt;</span><span class="number">18</span> <span class="keyword">and</span> gender<span class="operator">=</span><span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<h4 id="3-3模糊查询"><a href="#3-3模糊查询" class="headerlink" title="3.3模糊查询"></a>3.3模糊查询</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- like 匹配字符，效率较低</span></span><br><span class="line"><span class="comment">-- _ 替代一个位置</span></span><br><span class="line"><span class="comment">-- % 替代剩余位置</span></span><br><span class="line"><span class="comment">-- 查询姓李的同学</span></span><br><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> students <span class="keyword">where</span> name <span class="keyword">like</span> &quot;李%&quot;;</span><br><span class="line"><span class="comment">-- 查询名字两个字以上的同学</span></span><br><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> students <span class="keyword">where</span> name <span class="keyword">like</span> &quot;___%&quot;;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- rlike 正则匹配</span></span><br><span class="line"><span class="comment">-- ^ 开头  .* 填充  $结尾</span></span><br><span class="line"><span class="comment">-- 查询姓韩的同学</span></span><br><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> students <span class="keyword">where</span> name rlike &quot;^韩.*&quot;;</span><br><span class="line"><span class="comment">-- 查询以李开头 以璃结尾的同学</span></span><br><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> students <span class="keyword">where</span> name rlike &quot;^李.*璃$&quot;;</span><br></pre></td></tr></table></figure>
<h4 id="3-4范围查询"><a href="#3-4范围查询" class="headerlink" title="3.4范围查询"></a>3.4范围查询</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- in/not in (1,5,8) 在/不在一个非连续范围</span></span><br><span class="line"><span class="comment">-- 查看年龄为18和22岁的同学信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> students <span class="keyword">where</span> age <span class="keyword">in</span> (<span class="number">18</span>,<span class="number">22</span>);</span><br><span class="line"><span class="comment">-- 查看年龄不为18和22岁的同学信息，not in是一个整体</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> students <span class="keyword">where</span> age <span class="keyword">not</span> <span class="keyword">in</span> (<span class="number">18</span>,<span class="number">22</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- between/not between ... and ... 在/不在一个连续范围</span></span><br><span class="line"><span class="comment">-- 查看年龄为18到20岁的同学信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> students <span class="keyword">where</span> age <span class="keyword">between</span> <span class="number">18</span> <span class="keyword">and</span> <span class="number">20</span>;</span><br><span class="line"><span class="comment">-- 查看年龄不在18到20岁的同学信息，not between是一个整体</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> students <span class="keyword">where</span> age <span class="keyword">not</span> <span class="keyword">between</span> <span class="number">18</span> <span class="keyword">and</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- is/is not null 判断为空/不为空</span></span><br><span class="line"><span class="comment">-- 插入一个为空的数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> students(name,gender,age,cls_id)</span><br><span class="line"> <span class="keyword">values</span>(&quot;张三三&quot;,<span class="number">2</span>,<span class="number">18</span>,<span class="keyword">null</span>);</span><br><span class="line"><span class="comment">-- 查看班级为空的同学</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> students <span class="keyword">where</span> cls_id <span class="keyword">is</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">-- 查看班级不为空的同学</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> students <span class="keyword">where</span> cls_id <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<h3 id="4-排序"><a href="#4-排序" class="headerlink" title="4.排序"></a>4.排序</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- order by `字段` 不写默认按主键排序</span></span><br><span class="line"><span class="comment">-- asc 从小到大排(默认值)</span></span><br><span class="line"><span class="comment">-- desc 从大到小排</span></span><br><span class="line"><span class="comment">-- 查询姓李的同学，年龄从大到小排</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> students <span class="keyword">where</span> name rlike &quot;^李.*&quot; <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">desc</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- order by 后面可跟多字段，依照顺序判断</span></span><br><span class="line"><span class="comment">-- 查询所有同学，班级从小到大排，年龄从小到大排</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> students <span class="keyword">order</span> <span class="keyword">by</span> cls_id,age;</span><br></pre></td></tr></table></figure>
<h3 id="5-聚合分组"><a href="#5-聚合分组" class="headerlink" title="5.聚合分组"></a>5.聚合分组</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">聚合函数</th>
<th style="text-align:center">函数作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">count(<code>字段</code>)</td>
<td style="text-align:center">总数</td>
</tr>
<tr>
<td style="text-align:center">max(<code>字段</code>)</td>
<td style="text-align:center">最大值</td>
</tr>
<tr>
<td style="text-align:center">min(<code>字段</code>)</td>
<td style="text-align:center">最小值</td>
</tr>
<tr>
<td style="text-align:center">sum(<code>字段</code>)</td>
<td style="text-align:center">求和</td>
</tr>
<tr>
<td style="text-align:center">avg(<code>字段</code>)<br>sum(<code>字段</code>)/count(<code>字段</code>)</td>
<td style="text-align:center">平均值</td>
</tr>
<tr>
<td style="text-align:center">round(<code>需保留的值</code>，<code>保留小数位数</code>)</td>
<td style="text-align:center">四舍五入</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 聚合函数</span></span><br><span class="line"><span class="comment">-- ps:计算机计算小数存在误差，当需要准确计算时可扩大相应倍数后计算</span></span><br><span class="line"><span class="comment">-- 计算平均年龄，保留两位小数</span></span><br><span class="line"><span class="keyword">select</span> round(<span class="built_in">avg</span>(age),<span class="number">2</span>) <span class="keyword">as</span> 平均年龄 <span class="keyword">from</span> students;</span><br><span class="line"><span class="keyword">select</span> round(<span class="built_in">sum</span>(age)<span class="operator">/</span><span class="built_in">count</span>(age),<span class="number">2</span>) <span class="keyword">as</span> 平均年龄 <span class="keyword">from</span> students;</span><br><span class="line"><span class="comment">-- 输出女性总数，最大年龄，最小年龄</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> 总数,<span class="built_in">max</span>(age) <span class="keyword">as</span> 最大年龄,</span><br><span class="line"><span class="built_in">min</span>(age) <span class="keyword">as</span> 最小年龄 <span class="keyword">from</span> students <span class="keyword">where</span> gender<span class="operator">=</span><span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 输出女性所有名字，以及总数</span></span><br><span class="line"><span class="keyword">select</span> name,<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> students <span class="keyword">where</span> gender<span class="operator">=</span><span class="number">2</span>;</span><br><span class="line"><span class="comment">-- 语句报错，需要分组后再进行计算</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- group by 分组</span></span><br><span class="line"><span class="comment">-- 按照性别分组,select后跟非分组字段无意义，可跟聚合函数</span></span><br><span class="line"><span class="keyword">select</span> gender <span class="keyword">from</span> students <span class="keyword">group</span> <span class="keyword">by</span> gender;</span><br><span class="line"><span class="comment">-- 按照性别分组并计算人数</span></span><br><span class="line"><span class="keyword">select</span> gender,<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> students <span class="keyword">group</span> <span class="keyword">by</span> gender;</span><br><span class="line"><span class="comment">-- group_concat(`字段`) 查询同组的所有字段</span></span><br><span class="line"><span class="comment">-- 查询每个性别里所有人的姓名,年龄</span></span><br><span class="line"><span class="keyword">select</span> gender,group_concat(name,&quot; &quot;,age) <span class="keyword">from</span> students <span class="keyword">group</span> <span class="keyword">by</span> gender;</span><br><span class="line"><span class="comment">-- having 对组进行约束，一般处理生成表单采用having，原表单使用where</span></span><br><span class="line"><span class="comment">-- 输出大于两个人的班级的所有人姓名</span></span><br><span class="line"><span class="keyword">select</span> cls_id,group_concat(name) <span class="keyword">from</span> students <span class="keyword">group</span> <span class="keyword">by</span> cls_id <span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>)<span class="operator">&gt;</span><span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 此时解决上面未解决的问题</span></span><br><span class="line"><span class="comment">-- 输出女性所有名字，以及总数</span></span><br><span class="line"><span class="keyword">select</span> group_concat(name),<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> students </span><br><span class="line">    <span class="keyword">where</span> gender<span class="operator">=</span><span class="number">2</span> <span class="keyword">group</span> <span class="keyword">by</span> gender;</span><br><span class="line"><span class="keyword">select</span> group_concat(name),<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> students </span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> gender <span class="keyword">having</span> gender<span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<h3 id="6-分页"><a href="#6-分页" class="headerlink" title="6.分页"></a>6.分页</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- limit 在所有约束之后</span></span><br><span class="line"><span class="comment">-- limit `个数`  限制查询个数</span></span><br><span class="line"><span class="comment">-- 查询最开始的5个数据</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> students limit <span class="number">5</span>;</span><br><span class="line"><span class="comment">-- limit `起始位置`,`个数` 查询从固定位置开始的几个记录</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> students limit <span class="number">0</span>,<span class="number">5</span>; #从<span class="number">1</span>开始五个数据</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> students limit <span class="number">5</span>,<span class="number">5</span>; #从<span class="number">6</span>开始五个数据</span><br></pre></td></tr></table></figure>
<h3 id="7-连接查询"><a href="#7-连接查询" class="headerlink" title="7.连接查询"></a>7.连接查询</h3><blockquote>
<p>SQL支持三种类型的连接查询：内连接，右连接，左连接，可实现如下图所示的多种效果。</p>
</blockquote>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202302052208317.png" alt="sql-join"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- inner join 内连接</span></span><br><span class="line"><span class="comment">-- 将学生信息和班级对应起来,as可省略</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> students <span class="keyword">as</span> s <span class="keyword">inner</span> <span class="keyword">join</span> classes c</span><br><span class="line">    <span class="keyword">on</span> s.cls_id<span class="operator">=</span>c.id;</span><br><span class="line">    </span><br><span class="line"><span class="comment">-- left join 左连接</span></span><br><span class="line"><span class="comment">-- 右侧添加信息到左侧表单，没有对应填null</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> students s <span class="keyword">left</span> <span class="keyword">join</span> classes c</span><br><span class="line">    <span class="keyword">on</span> s.cls_id<span class="operator">=</span>c.id;   </span><br><span class="line">    </span><br><span class="line"><span class="comment">-- right join 右连接，效果等同左连接反转</span></span><br><span class="line"><span class="comment">-- full join 全连接，可用左连接+约束条件实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 显示班级，编号，学生，性别,先按班级排序，再按编号排序</span></span><br><span class="line"><span class="keyword">select</span> c.name 班级,s.id 编号,s.name 学生,s.gender 性别 </span><br><span class="line">  <span class="keyword">from</span> students s <span class="keyword">inner</span> <span class="keyword">join</span> classes c <span class="keyword">on</span> s.cls_id<span class="operator">=</span>c.id</span><br><span class="line">    <span class="keyword">order</span> <span class="keyword">by</span> c.id,s.id;</span><br></pre></td></tr></table></figure>
<h3 id="8-自关联"><a href="#8-自关联" class="headerlink" title="8.自关联"></a>8.自关联</h3><blockquote>
<blockquote>
<p>要实现三级城市选择，按照一般方法需要建最少三个表，由于表结构基本相同，因此可以使用一个表来完成，一个表内一个字段p_id关联另一字段id则称为自关联，如下表。</p>
</blockquote>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">id</th>
<th style="text-align:center">name</th>
<th style="text-align:center">p_id</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">河北省</td>
<td style="text-align:center">null</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">石家庄市</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">正定</td>
<td style="text-align:center">2</td>
</tr>
</tbody>
</table>
</div>
<p>[提取码：z04f ]:<a href="https://pan.baidu.com/s/1HAN9WwO4T-aQyVPf0-RBpQ">https://pan.baidu.com/s/1HAN9WwO4T-aQyVPf0-RBpQ</a>    点击下载</p>
<h4 id="8-1数据导入"><a href="#8-1数据导入" class="headerlink" title="8.1数据导入"></a>8.1数据导入</h4><pre><code><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 从上方链接下载完sql文件，解压选择单文件放在桌面上</span></span><br><span class="line"><span class="comment">-- 使用test库</span></span><br><span class="line">use test</span><br><span class="line"><span class="comment">-- 导入sql文件</span></span><br><span class="line">source C:\Users\Administrator\Desktop\cn_region_info.sql</span><br><span class="line"><span class="comment">-- 显示创建的表的字段信息</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> cn_region_info;</span><br><span class="line"><span class="comment">-- 删掉不需要的字段</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> cn_region_info <span class="keyword">drop</span> <span class="keyword">column</span> CRI_GMT_CREATE,</span><br><span class="line">  <span class="keyword">drop</span> <span class="keyword">column</span> CRI_GMT_MODIFIED,<span class="keyword">drop</span> <span class="keyword">column</span> CRI_MEMO,</span><br><span class="line">   <span class="keyword">drop</span> <span class="keyword">column</span> CRI_DATA_STATE,<span class="keyword">drop</span> <span class="keyword">column</span> CRI_TENANT_CODE;</span><br><span class="line"><span class="comment">-- 查看前6行信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> cn_region_info limit <span class="number">6</span>;</span><br><span class="line"><span class="comment">-- 显示信息则导入成功</span></span><br></pre></td></tr></table></figure>
</code></pre><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">CRI_ID</th>
<th style="text-align:center">CRI_CODE</th>
<th style="text-align:center">CRI_NAME</th>
<th style="text-align:center">CRI_SHORT_NAME</th>
<th style="text-align:center">CRI_SUPERIOR_CODE</th>
<th style="text-align:center">CRI_LNG</th>
<th style="text-align:center">CRI_LAT</th>
<th style="text-align:center">CRI_LEVEL</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">110000</td>
<td style="text-align:center">北京</td>
<td style="text-align:center">北京</td>
<td style="text-align:center">000000</td>
<td style="text-align:center">116.405289</td>
<td style="text-align:center">39.904987</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">120000</td>
<td style="text-align:center">天津</td>
<td style="text-align:center">天津</td>
<td style="text-align:center">000000</td>
<td style="text-align:center">117.190186</td>
<td style="text-align:center">39.125595</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">130000</td>
<td style="text-align:center">河北省</td>
<td style="text-align:center">河北</td>
<td style="text-align:center">000000</td>
<td style="text-align:center">114.502464</td>
<td style="text-align:center">38.045475</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">140000</td>
<td style="text-align:center">山西省</td>
<td style="text-align:center">山西</td>
<td style="text-align:center">000000</td>
<td style="text-align:center">112.549248</td>
<td style="text-align:center">37.857014</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">150000</td>
<td style="text-align:center">内蒙古自治区</td>
<td style="text-align:center">内蒙古</td>
<td style="text-align:center">000000</td>
<td style="text-align:center">111.670799</td>
<td style="text-align:center">40.81831</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">210000</td>
<td style="text-align:center">辽宁省</td>
<td style="text-align:center">辽宁</td>
<td style="text-align:center">000000</td>
<td style="text-align:center">123.429092</td>
<td style="text-align:center">41.796768</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
</div>
<h4 id="8-2数据查询"><a href="#8-2数据查询" class="headerlink" title="8.2数据查询"></a>8.2数据查询</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询河北省的代码130000</span></span><br><span class="line"><span class="keyword">select</span> cri_code <span class="keyword">from</span> cn_region_info <span class="keyword">where</span> cri_name<span class="operator">=</span>&quot;河北省&quot;;</span><br><span class="line"><span class="comment">-- 查询河北省下所有市</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> cn_region_info <span class="keyword">where</span> cri_superior_code<span class="operator">=</span><span class="number">130000</span>;</span><br><span class="line"><span class="comment">-- 查询衡水市的代码131100</span></span><br><span class="line"><span class="keyword">select</span> cri_code <span class="keyword">from</span> cn_region_info <span class="keyword">where</span> cri_superior_code<span class="operator">=</span><span class="number">130000</span> <span class="keyword">and</span> cri_name<span class="operator">=</span>&quot;衡水市&quot;;</span><br><span class="line"><span class="comment">-- 查询衡水市下所有县</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> cn_region_info <span class="keyword">where</span> cri_superior_code<span class="operator">=</span><span class="number">131100</span>;</span><br><span class="line"><span class="comment">-- 查询衡水市下所有县，显示市，县,一张表当成两个表使用连接</span></span><br><span class="line"><span class="keyword">select</span> s.cri_name 市,c.cri_name 县 <span class="keyword">from</span> cn_region_info s <span class="keyword">inner</span> <span class="keyword">join</span> cn_region_info c <span class="keyword">on</span></span><br><span class="line">    c.cri_superior_code<span class="operator">=</span>s.cri_code <span class="keyword">where</span> s.cri_name<span class="operator">=</span>&quot;衡水市&quot;;</span><br></pre></td></tr></table></figure>
<h3 id="9-子查询"><a href="#9-子查询" class="headerlink" title="9.子查询"></a>9.子查询</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 一个select里嵌套一个select称为子查询</span></span><br><span class="line"><span class="comment">-- 查询衡水市下所有县</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> cn_region_info <span class="keyword">where</span> cri_superior_code<span class="operator">=</span></span><br><span class="line"> (<span class="keyword">select</span> cri_code <span class="keyword">from</span> cn_region_info <span class="keyword">where</span> cri_superior_code<span class="operator">=</span><span class="number">130000</span> <span class="keyword">and</span> cri_name<span class="operator">=</span>&quot;衡水市&quot;);</span><br><span class="line"><span class="comment">-- 查询一个结果有多种方式，但所用时间不同</span></span><br></pre></td></tr></table></figure>
<h3 id="10-数据库设计"><a href="#10-数据库设计" class="headerlink" title="10.数据库设计"></a>10.数据库设计</h3><h4 id="10-1-三范式"><a href="#10-1-三范式" class="headerlink" title="10.1 三范式"></a>10.1 三范式</h4><blockquote>
<p>​        经过研究和对使用中问题的总结，对于设计数据库提出了一些规范，这些规范被称为范式(Normal Form),一般需要遵守三条即可。</p>
</blockquote>
<ol>
<li><code>第一范式(1NF)</code>：强调的是列的<strong>原子性</strong>，即<strong><em>列不能够再分成其他列</em></strong>。</li>
<li><code>第二范式(2NF)</code>：首先是1NF，另外包含两部分内容，<strong>一是表必须有一个主键</strong>；二是<strong>没有包含在主键中的列必须完全依赖</strong>，而<strong>不能只是依赖于主键的一部分</strong>。</li>
<li><code>第三范式(3NF)</code>：首先是2NF，另外<strong>非主键列必须直接依赖于主键，不能存在传递依赖</strong>。即<strong><em>不能存在</em></strong>：<strong>非主键列A依赖于非主键列B，非主键列B依赖于主键的情况</strong>。</li>
</ol>
<p>PS：可适当<em>降低标准</em>，<strong>设计数据库是需求&gt;性能&gt;表结构</strong>，不能一味追求范式。</p>
<h4 id="10-2-E-R模型"><a href="#10-2-E-R模型" class="headerlink" title="10.2 E-R模型"></a>10.2 E-R模型</h4><p>​        <strong><em>描述事物之间一对一，一对多，多对多的关系</em></strong>，当为<strong>一对一和一对多</strong>时，<strong><em>两个表</em></strong>即可解决问题，当为<strong>多对多</strong>时<strong><em>需要添加一个中间表来关联两个表</em></strong>。</p>
<h2 id="第三章：MySQL-amp-Python"><a href="#第三章：MySQL-amp-Python" class="headerlink" title="第三章：MySQL&amp;Python"></a>第三章：MySQL&amp;Python</h2><h3 id="1-MySQL强化"><a href="#1-MySQL强化" class="headerlink" title="1.MySQL强化"></a>1.MySQL强化</h3><h4 id="1-1准备数据"><a href="#1-1准备数据" class="headerlink" title="1.1准备数据"></a>1.1准备数据</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database jing_dong charset<span class="operator">=</span>utf8;</span><br><span class="line">use jing_dong</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> goods( id <span class="type">int</span> unsigned <span class="keyword">primary</span> key auto_increment <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">                   name <span class="type">varchar</span>(<span class="number">150</span>) <span class="keyword">not</span> <span class="keyword">null</span>, </span><br><span class="line">                   cate_name <span class="type">varchar</span>(<span class="number">40</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">                   brand_name <span class="type">varchar</span>(<span class="number">40</span>) <span class="keyword">not</span> <span class="keyword">null</span>, </span><br><span class="line">                   price <span class="type">decimal</span>(<span class="number">10.3</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="number">0</span>,</span><br><span class="line">                   is_show bit <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="number">1</span>, </span><br><span class="line">                   is_saleoff bit <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="number">0</span> </span><br><span class="line">                  );</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> goods <span class="keyword">values</span>(<span class="number">0</span>,<span class="string">&#x27;r510vc 15.6英寸笔记本&#x27;</span>,<span class="string">&#x27;笔记本&#x27;</span>,<span class="string">&#x27;华硕&#x27;</span>,<span class="string">&#x27;3399&#x27;</span>,<span class="keyword">default</span>,<span class="keyword">default</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> goods <span class="keyword">values</span>(<span class="number">0</span>,<span class="string">&#x27;x550cc 15.6英寸笔记本&#x27;</span>,<span class="string">&#x27;笔记本&#x27;</span>,<span class="string">&#x27;华硕&#x27;</span>,<span class="string">&#x27;2799&#x27;</span>,<span class="keyword">default</span>,<span class="keyword">default</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> goods <span class="keyword">values</span>(<span class="number">0</span>,<span class="string">&#x27;x240 超极本&#x27;</span>,<span class="string">&#x27;超极本&#x27;</span>,<span class="string">&#x27;联想&#x27;</span>,<span class="string">&#x27;4880&#x27;</span>,<span class="keyword">default</span>,<span class="keyword">default</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> goods <span class="keyword">values</span>(<span class="number">0</span>,<span class="string">&#x27;u330p 13.3英寸超级本&#x27;</span>,<span class="string">&#x27;超极本&#x27;</span>,<span class="string">&#x27;联想&#x27;</span>,<span class="string">&#x27;4299&#x27;</span>,<span class="keyword">default</span>,<span class="keyword">default</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> goods <span class="keyword">values</span>(<span class="number">0</span>,<span class="string">&#x27;svp13226scb 触控超级本&#x27;</span>,<span class="string">&#x27;超级本&#x27;</span>,<span class="string">&#x27;索尼&#x27;</span>,<span class="string">&#x27;7999&#x27;</span>,<span class="keyword">default</span>,<span class="keyword">default</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> goods <span class="keyword">values</span>(<span class="number">0</span>,<span class="string">&#x27;ipad mini 7.9英寸平板电脑&#x27;</span>,<span class="string">&#x27;平板电脑&#x27;</span>,<span class="string">&#x27;苹果&#x27;</span>,<span class="string">&#x27;1999&#x27;</span>,<span class="keyword">default</span>,<span class="keyword">default</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> goods <span class="keyword">values</span>(<span class="number">0</span>,<span class="string">&#x27;iPad air 9.7英寸平板电脑&#x27;</span>,<span class="string">&#x27;平板电脑&#x27;</span>,<span class="string">&#x27;苹果&#x27;</span>,<span class="string">&#x27;3388&#x27;</span>,<span class="keyword">default</span>,<span class="keyword">default</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> goods <span class="keyword">values</span>(<span class="number">0</span>,<span class="string">&#x27;iPad mini 配置 retine 显示屏&#x27;</span>,<span class="string">&#x27;平板电脑&#x27;</span>,<span class="string">&#x27;苹果&#x27;</span>,<span class="string">&#x27;2788&#x27;</span>,<span class="keyword">default</span>,<span class="keyword">default</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> goods <span class="keyword">values</span>(<span class="number">0</span>,<span class="string">&#x27;ideacentre c3340 20英寸一体电脑&#x27;</span>,<span class="string">&#x27;台式机&#x27;</span>,<span class="string">&#x27;联想&#x27;</span>,<span class="string">&#x27;3499&#x27;</span>,<span class="keyword">default</span>,<span class="keyword">default</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> goods <span class="keyword">values</span>(<span class="number">0</span>,<span class="string">&#x27;vostro 3800-r1206 台式电脑&#x27;</span>,<span class="string">&#x27;台式机&#x27;</span>,<span class="string">&#x27;戴尔&#x27;</span>,<span class="string">&#x27;2899&#x27;</span>,<span class="keyword">default</span>,<span class="keyword">default</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> goods <span class="keyword">values</span>(<span class="number">0</span>,<span class="string">&#x27;15.6 寸电脑屏保护膜&#x27;</span>,<span class="string">&#x27;电脑配件&#x27;</span>,<span class="string">&#x27;爱戴尔&#x27;</span>,<span class="string">&#x27;29&#x27;</span>,<span class="keyword">default</span>,<span class="keyword">default</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> goods <span class="keyword">values</span>(<span class="number">0</span>,<span class="string">&#x27;优雅 复古 无线鼠标键盘&#x27;</span>,<span class="string">&#x27;电脑配件&#x27;</span>,<span class="string">&#x27;雷蛇&#x27;</span>,<span class="string">&#x27;299&#x27;</span>,<span class="keyword">default</span>,<span class="keyword">default</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> goods <span class="keyword">values</span>(<span class="number">0</span>,<span class="string">&#x27;15寸 4K 液晶显示屏&#x27;</span>,<span class="string">&#x27;电脑配件&#x27;</span>,<span class="string">&#x27;索尼&#x27;</span>,<span class="string">&#x27;1899&#x27;</span>,<span class="keyword">default</span>,<span class="keyword">default</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> goods <span class="keyword">values</span>(<span class="number">0</span>,<span class="string">&#x27;限量款 LOL 鼠标垫&#x27;</span>,<span class="string">&#x27;电脑配件&#x27;</span>,<span class="string">&#x27;唯爱&#x27;</span>,<span class="string">&#x27;29&#x27;</span>,<span class="keyword">default</span>,<span class="keyword">default</span>);       </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 数据库导入完成</span></span><br></pre></td></tr></table></figure>
<h4 id="1-2查询数据"><a href="#1-2查询数据" class="headerlink" title="1.2查询数据"></a>1.2查询数据</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询每个品牌最贵的产品</span></span><br><span class="line"><span class="keyword">select</span> group_concat(name) 产品名称,brand_name 品牌,</span><br><span class="line"><span class="built_in">max</span>(price) 价格 <span class="keyword">from</span> goods <span class="keyword">group</span> <span class="keyword">by</span> brand_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看所有的产品种类</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> cate_name 类型 <span class="keyword">from</span> goods; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将超级本修正为超极本</span></span><br><span class="line"><span class="keyword">update</span> goods <span class="keyword">set</span> cate_name<span class="operator">=</span>&quot;超极本&quot; <span class="keyword">where</span> cate_name<span class="operator">=</span>&quot;超级本&quot;; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看各个种类的产品数据，并按价格排序</span></span><br><span class="line"><span class="keyword">select</span> a.name 名称,b.cate_name 类型,a.price 价格 </span><br><span class="line">       <span class="keyword">from</span> goods <span class="keyword">as</span> a <span class="keyword">inner</span> <span class="keyword">join</span> </span><br><span class="line">        (<span class="keyword">select</span> cate_name <span class="keyword">from</span> goods <span class="keyword">group</span> <span class="keyword">by</span> cate_name <span class="keyword">having</span> cate_name<span class="operator">=</span>&quot;超极本&quot;) <span class="keyword">as</span> b </span><br><span class="line">           <span class="keyword">on</span> a.cate_name<span class="operator">=</span>b.cate_name <span class="keyword">order</span> <span class="keyword">by</span> a.price;</span><br><span class="line">           </span><br><span class="line"><span class="comment">-- 查看小于平均价格的电脑配件</span></span><br><span class="line"><span class="keyword">select</span> name 名称,cate_name 类型,price 价格 </span><br><span class="line">    <span class="keyword">from</span> goods <span class="keyword">where</span> </span><br><span class="line">    price<span class="operator">&lt;</span>(<span class="keyword">select</span> <span class="built_in">avg</span>(price) <span class="keyword">from</span> goods <span class="keyword">group</span> <span class="keyword">by</span> cate_name <span class="keyword">having</span> cate_name<span class="operator">=</span>&quot;电脑配件&quot;) </span><br><span class="line">    <span class="keyword">and</span> cate_name<span class="operator">=</span>&quot;电脑配件&quot; <span class="keyword">order</span> <span class="keyword">by</span> price;</span><br></pre></td></tr></table></figure>
<h4 id="1-3拆分数据表"><a href="#1-3拆分数据表" class="headerlink" title="1.3拆分数据表"></a>1.3拆分数据表</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 首先建立一个类型表单，将类型添加到表单</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> name_type (</span><br><span class="line">    id <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span> </span><br><span class="line">) <span class="keyword">select</span> <span class="keyword">distinct</span> cate_name <span class="keyword">as</span> name <span class="keyword">from</span> goods;</span><br><span class="line">#PS:起的别名一定要对应新建表中的字段名</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将原表中的名称换成id</span></span><br><span class="line"><span class="keyword">update</span> goods <span class="keyword">as</span> a <span class="keyword">inner</span> <span class="keyword">join</span> name_type <span class="keyword">as</span> b <span class="keyword">on</span> a.cate_name<span class="operator">=</span>b.name <span class="keyword">set</span> a.cate_name<span class="operator">=</span>b.id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改字段类型</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> goods change cate_name name_id <span class="type">int</span>(<span class="number">10</span>) unsigned;</span><br><span class="line"><span class="comment">-- 查看修改后的信息</span></span><br><span class="line"><span class="keyword">desc</span> goods;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> goods;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 外键关联</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> goods <span class="keyword">add</span> <span class="keyword">foreign</span> key(name_id) <span class="keyword">references</span> name_type(id);</span><br><span class="line"><span class="comment">-- 删除外键，数据过多时，外键会降低效率，因为一般数据存储在硬盘中，程序运行在内存里，程序判断要快的多。</span></span><br><span class="line"><span class="comment">-- 查看外键信息,在字段最后多出来一个外键goods_ibfk_1</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> goods;</span><br><span class="line"><span class="comment">-- 删除外键</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> goods <span class="keyword">drop</span> <span class="keyword">foreign</span> key goods_ibfk_1;</span><br></pre></td></tr></table></figure>
<h4 id="1-4数据备份"><a href="#1-4数据备份" class="headerlink" title="1.4数据备份"></a>1.4数据备份</h4><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">-- 在shell里执行，不登录数据库</span><br><span class="line">-- 备份指定库 mysqldump -uroot -p`密码` `库` &gt; `目标地址`</span><br><span class="line">mysqldump -uroot -p****** jing_dong &gt; C:\Users\Administrator\Desktop\jd.sql</span><br><span class="line"></span><br><span class="line">返回信息：mysqldump: [Warning] Using a password on the command line interface can be insecure.</span><br><span class="line"></span><br><span class="line">-- 备份所有内容</span><br><span class="line">mysqldump -uroot -p****** --all-databases --lock-all-tables&gt; C:\Users\Administrator\Desktop\al.sql</span><br></pre></td></tr></table></figure>
<h3 id="2-Python调用"><a href="#2-Python调用" class="headerlink" title="2.Python调用"></a>2.Python调用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用pycharm先添加pymysql的package</span></span><br><span class="line"><span class="keyword">from</span> pymysql <span class="keyword">import</span> * </span><br><span class="line"><span class="comment"># 定义一个简单的查询函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">search</span> ():</span><br><span class="line">    <span class="comment">#创建connection连接，输入端口，用户名，密码和使用的库</span></span><br><span class="line">    conn = connect(host=<span class="string">&#x27;localhost&#x27;</span>,port=<span class="number">3306</span>,user=<span class="string">&#x27;root&#x27;</span>,\</span><br><span class="line">                   password=<span class="string">&#x27;password&#x27;</span>,database=<span class="string">&#x27;jing_dong&#x27;</span>,charset=<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">    <span class="comment">#获得游标cursor对象</span></span><br><span class="line">    cs1=conn.cursor()</span><br><span class="line">    <span class="comment">#以上两句为开头固定使用</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#执行sql的查询语句,返回值为数据数</span></span><br><span class="line">    count=cs1.execute(<span class="string">&#x27;select id,name from goods where id &gt;=4&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;查询到%d条数据&quot;</span>%count)</span><br><span class="line">    <span class="comment">#打印所有的数据</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(count):</span><br><span class="line">        <span class="comment">#获取查询的结果</span></span><br><span class="line">        result = cs1.fetchone()</span><br><span class="line">        <span class="built_in">print</span>(result)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">#关闭游标对象和连接</span></span><br><span class="line">    cs1.close()</span><br><span class="line">    conn.close()</span><br><span class="line">    <span class="comment">#最后两句固定</span></span><br><span class="line"><span class="keyword">if</span> __name__ ==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    search()</span><br></pre></td></tr></table></figure>
<h3 id="3-查询练习"><a href="#3-查询练习" class="headerlink" title="3.查询练习"></a>3.查询练习</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- MySQL</span></span><br><span class="line"><span class="comment">-- 添加一个用户密码表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> <span class="keyword">user</span>(</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">primary</span> key <span class="keyword">unique</span>,</span><br><span class="line">    pass <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">default</span><span class="operator">=</span>&quot;000000&quot;);</span><br><span class="line"><span class="comment">-- 添加一名用户</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> <span class="keyword">values</span>(&quot;用户名&quot;,&quot;密码&quot;);</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python</span></span><br><span class="line"><span class="comment"># 使用pymysql包</span></span><br><span class="line"><span class="comment"># connect()连接库  connect().cursor() 连接游标</span></span><br><span class="line"><span class="comment"># connect().close() 断开库连接  connect().cursor.close() 断开游标连接</span></span><br><span class="line"><span class="comment"># connect().cursor.execute(`sql代码`) 向数据库发送指令</span></span><br><span class="line"><span class="comment"># connect().cursor.fetchone()/fetchmany(num)/fetchall() 得到查询的一条/num条/所有的信息</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">功能实现基本要求：</span></span><br><span class="line"><span class="string">1.能够用户登录</span></span><br><span class="line"><span class="string">2.用户能够查询所有商品信息</span></span><br><span class="line"><span class="string">3.用户可以查询所有品牌</span></span><br><span class="line"><span class="string">4.用户可以查询指定品牌商品信息</span></span><br><span class="line"><span class="string">5.用户可以查询指定品牌的平均价格</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">from</span> pymysql <span class="keyword">import</span> connect</span><br><span class="line"><span class="comment"># 一般类名大写</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JD</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment">#类下函数调用开始前连接数据库</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 创建connection连接，输入端口，用户名，密码和使用的库</span></span><br><span class="line">        self.conn = connect(host=<span class="string">&#x27;localhost&#x27;</span>, port=<span class="number">3306</span>, user=<span class="string">&#x27;root&#x27;</span>, \</span><br><span class="line">                       password=<span class="string">&#x27;******&#x27;</span>, database=<span class="string">&#x27;jing_dong&#x27;</span>, charset=<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">        <span class="comment"># 获得游标cursor对象</span></span><br><span class="line">        self.cursor = self.conn.cursor()</span><br><span class="line">    <span class="comment">#类下函数调用结束后关闭数据库</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 关闭游标对象和连接</span></span><br><span class="line">        self.cursor.close()</span><br><span class="line">        self.conn.close()</span><br><span class="line">    <span class="comment">#用户登录    </span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">link</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># 链接用户表，查询用户是否存在</span></span><br><span class="line">            user_name=<span class="built_in">input</span>(<span class="string">&#x27;请输入用户名（回车确认）：&#x27;</span>)</span><br><span class="line">            count = self.cursor.execute(<span class="string">&#x27;select name from user where name=&quot;%s&quot;;&#x27;</span>% user_name)</span><br><span class="line">            <span class="comment"># 在引号内还存在引号的情况，最外面括号最好是&quot;&quot;&quot; %s &quot;&quot;&quot;</span></span><br><span class="line">            <span class="comment"># 用户存在对照密码，验证是否正确</span></span><br><span class="line">            <span class="keyword">if</span> count:</span><br><span class="line">                user_pass = <span class="built_in">input</span>(<span class="string">&#x27;请输入密码（回车确认）：&#x27;</span>)</span><br><span class="line">                self.cursor.execute(<span class="string">&#x27;select pass from user where name=&quot;%s&quot;;&#x27;</span> % user_name)</span><br><span class="line">                <span class="keyword">if</span> self.cursor.fetchone()[<span class="number">0</span>]==user_pass:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;登录成功&quot;</span>)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;请重新尝试&quot;</span>)</span><br><span class="line">            <span class="comment"># 用户不存在，是否添加信息</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;无用户名&quot;</span>)</span><br><span class="line">    <span class="comment">#1.查询所有商品            </span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search_all</span>(<span class="params">self</span>):</span><br><span class="line">        self.cursor.execute(<span class="string">&#x27;select name 名称,brand_name 品牌,price 价格 from goods;&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self.cursor.fetchall():</span><br><span class="line">            <span class="built_in">print</span>(i)</span><br><span class="line">    <span class="comment">#2.查询所有品牌        </span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search_brand</span>(<span class="params">self</span>):</span><br><span class="line">        self.cursor.execute(<span class="string">&#x27;select distinct brand_name from goods;&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self.cursor.fetchall():</span><br><span class="line">            <span class="built_in">print</span>(i)</span><br><span class="line">    <span class="comment">#3.查询一个品牌的所有商品        </span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search_brand_all</span>(<span class="params">self</span>):</span><br><span class="line">        brand = <span class="built_in">input</span>(<span class="string">&quot;品牌（回车确认）：&quot;</span>)</span><br><span class="line">        self.cursor.execute(<span class="string">&#x27;select name 名称,price 价格 from goods where brand_name=&quot;%s&quot;;&#x27;</span>%brand)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self.cursor.fetchall():</span><br><span class="line">            <span class="built_in">print</span>(i)</span><br><span class="line">    <span class="comment">#4.查询某一品牌商品的平均价格        </span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search_price</span>(<span class="params">self</span>):</span><br><span class="line">        brand = <span class="built_in">input</span>(<span class="string">&quot;品牌（回车确认）：&quot;</span>)</span><br><span class="line">        self.cursor.execute(<span class="string">&#x27;select avg(price)  from goods where brand_name=&quot;%s&quot;;&#x27;</span>%brand)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s的价格是%f&quot;</span>%(brand,self.cursor.fetchone()[<span class="number">0</span>]))</span><br><span class="line">    <span class="comment">#打印菜单,静态类放在静态块</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mune_print</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;-------欢迎--------&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;#1.查询所有商品&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;#2.查询所有品牌&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;#3.查询一个品牌的所有商品&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;#4.查询某一品牌商品的平均价格&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;#5.退出&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">input</span>(<span class="string">&quot;请输入指令序号（回车确认）：&quot;</span>)</span><br><span class="line">    <span class="comment">#串联功能</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        self.link()</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            user_cmd = self.mune_print()</span><br><span class="line">            <span class="keyword">if</span> user_cmd==<span class="string">&quot;1&quot;</span>:</span><br><span class="line">                self.search_all()</span><br><span class="line">            <span class="keyword">elif</span> user_cmd==<span class="string">&quot;2&quot;</span>:</span><br><span class="line">                self.search_brand()</span><br><span class="line">            <span class="keyword">elif</span> user_cmd==<span class="string">&quot;3&quot;</span>:</span><br><span class="line">                self.search_brand_all()</span><br><span class="line">            <span class="keyword">elif</span> user_cmd==<span class="string">&quot;4&quot;</span>:</span><br><span class="line">                self.search_price()</span><br><span class="line">            <span class="keyword">elif</span> user_cmd==<span class="string">&quot;5&quot;</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line"><span class="comment">#实现功能</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 创建京东商城对象</span></span><br><span class="line">    jd = JD()</span><br><span class="line">    <span class="comment"># 调用对象run方法，让其运行</span></span><br><span class="line">    jd.run()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;退出成功&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h3 id="4-增删改练习"><a href="#4-增删改练习" class="headerlink" title="4.增删改练习"></a>4.增删改练习</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># python</span></span><br><span class="line"><span class="comment"># 增删改操作相对于查询操作来说，改动了数据库</span></span><br><span class="line"><span class="comment"># 新增方法connect().commit() 提交 connect().rollback() 回滚</span></span><br><span class="line"><span class="comment"># 对于输入的增删改指令，不会直接生效，commit之后才会生效</span></span><br><span class="line"><span class="comment"># rollback会回滚到上次commit后</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">在查询功能下，新添加功能</span></span><br><span class="line"><span class="string">1.不存在用户提供注册</span></span><br><span class="line"><span class="string">2.向商品列表添加新商品</span></span><br><span class="line"><span class="string">3.向品牌列表添加新商品类型</span></span><br><span class="line"><span class="string">4.修改商品价格</span></span><br><span class="line"><span class="string">5.删除某个商品</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">from</span> pymysql <span class="keyword">import</span> connect</span><br><span class="line"><span class="comment"># 一般类名大写</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JD</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment"># 类下函数调用开始前连接数据库</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 创建connection连接，输入端口，用户名，密码和使用的库</span></span><br><span class="line">        self.conn = connect(host=<span class="string">&#x27;localhost&#x27;</span>, port=<span class="number">3306</span>, user=<span class="string">&#x27;root&#x27;</span>, \</span><br><span class="line">                            password=<span class="string">&#x27;password&#x27;</span>, database=<span class="string">&#x27;jing_dong&#x27;</span>, charset=<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">        <span class="comment"># 获得游标cursor对象</span></span><br><span class="line">        self.cursor = self.conn.cursor()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 类下函数调用结束后关闭数据库</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 关闭游标对象和连接</span></span><br><span class="line">        self.cursor.close()</span><br><span class="line">        self.conn.close()</span><br><span class="line">    <span class="comment"># 用户登录</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">link</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># 链接用户表，查询用户是否存在</span></span><br><span class="line">            user_name = <span class="built_in">input</span>(<span class="string">&#x27;请输入用户名（回车确认）：&#x27;</span>)</span><br><span class="line">            count = self.cursor.execute(<span class="string">&quot;&quot;&quot;select name from user where name=&quot;%s&quot;;&quot;&quot;&quot;</span> % user_name)</span><br><span class="line">            <span class="comment"># 在引号内还存在引号的情况，最外面括号最好是&quot;&quot;&quot; %s &quot;&quot;&quot;</span></span><br><span class="line">            <span class="comment"># 用户存在对照密码，验证是否正确</span></span><br><span class="line">            <span class="keyword">if</span> count:</span><br><span class="line">                user_pass = <span class="built_in">input</span>(<span class="string">&#x27;请输入密码（回车确认）：&#x27;</span>)</span><br><span class="line">                self.cursor.execute(<span class="string">&#x27;select pass from user where name=%s;&#x27;</span>, [user_name])</span><br><span class="line">                <span class="comment"># --------------&gt;PS:简单防止sql注入，如果自己先拼好sql代码有可能会被识别成其他代码，但函数自己拼装不会</span></span><br><span class="line">                <span class="keyword">if</span> self.cursor.fetchone()[<span class="number">0</span>] == user_pass:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;登录成功&quot;</span>)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;请重新尝试&quot;</span>)</span><br><span class="line">            <span class="comment"># 用户不存在，是否添加信息</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line"><span class="comment"># ----------------------&gt;添加用户注册&lt;-----------------------#</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;无用户名---&gt;0.返回\n----------&gt;1.注册&#x27;</span>)</span><br><span class="line">                user_cmd = <span class="built_in">input</span>(<span class="string">&quot;请输入指令（回车确认）：&quot;</span>)</span><br><span class="line">                <span class="keyword">if</span> user_cmd == <span class="string">&quot;0&quot;</span>:</span><br><span class="line">                    <span class="keyword">pass</span></span><br><span class="line">                <span class="keyword">elif</span> user_cmd == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                    user_pass = <span class="built_in">input</span>(<span class="string">&#x27;请输入密码（回车确认）：&#x27;</span>)</span><br><span class="line">                    self.cursor.execute(<span class="string">&#x27;insert into user values(%s,%s);&#x27;</span>, [user_name, user_pass])</span><br><span class="line">                    self.conn.commit()</span><br><span class="line"><span class="comment"># ---------------------------------------------------------#</span></span><br><span class="line">    <span class="comment"># 1.查询所有商品</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search_all</span>(<span class="params">self</span>):</span><br><span class="line">        self.cursor.execute(<span class="string">&#x27;select name 名称,brand_name 品牌,price 价格 from goods;&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self.cursor.fetchall():</span><br><span class="line">            <span class="built_in">print</span>(i)</span><br><span class="line">    <span class="comment"># 2.查询所有品牌</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search_brand</span>(<span class="params">self</span>):</span><br><span class="line">        self.cursor.execute(<span class="string">&#x27;select distinct brand_name from goods;&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self.cursor.fetchall():</span><br><span class="line">            <span class="built_in">print</span>(i)</span><br><span class="line">    <span class="comment"># 3.查询一个品牌的所有商品</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search_brand_all</span>(<span class="params">self</span>):</span><br><span class="line">        brand = <span class="built_in">input</span>(<span class="string">&quot;品牌（回车确认）：&quot;</span>)</span><br><span class="line">        self.cursor.execute(<span class="string">&#x27;select name 名称,price 价格 from goods where brand_name=%s;&#x27;</span>, [brand])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self.cursor.fetchall():</span><br><span class="line">            <span class="built_in">print</span>(i)</span><br><span class="line">    <span class="comment"># 4.查询某一品牌商品的平均价格</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search_price</span>(<span class="params">self</span>):</span><br><span class="line">        brand = <span class="built_in">input</span>(<span class="string">&quot;品牌（回车确认）：&quot;</span>)</span><br><span class="line">        self.cursor.execute(<span class="string">&#x27;select avg(price)  from goods where brand_name=%s;&#x27;</span>,[brand])</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s的价格是%.2f&quot;</span> % (brand, self.cursor.fetchone()[<span class="number">0</span>]))</span><br><span class="line"><span class="comment"># ---------------&gt;添加新添功能说明&lt;-----------------#</span></span><br><span class="line">    <span class="comment"># 5.向商品列表添加新商品</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_one</span>(<span class="params">self</span>):</span><br><span class="line">        goods_name = <span class="built_in">input</span>(<span class="string">&quot;添加商品名称（回车确认）：&quot;</span>)</span><br><span class="line">        goods_brand = <span class="built_in">input</span>(<span class="string">&quot;添加商品品牌（回车确认）：&quot;</span>)</span><br><span class="line">        goods_type = <span class="built_in">input</span>(<span class="string">&quot;添加商品类型（回车确认）：&quot;</span>)</span><br><span class="line">        goods_price = <span class="built_in">round</span>(<span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;添加商品价格（回车确认）：&quot;</span>)),<span class="number">2</span>)</span><br><span class="line">        self.cursor.execute(<span class="string">&#x27;select id from name_type where name=%s&#x27;</span>, [goods_type])</span><br><span class="line">        goods_type_id = self.cursor.fetchone()[<span class="number">0</span>]</span><br><span class="line">        count = self.cursor.execute(\</span><br><span class="line">               <span class="string">&#x27;insert into goods(name,name_id,brand_name,price) values(%s,%s,%s,%s);&#x27;</span>,\</span><br><span class="line">                   [goods_name,goods_type_id, goods_brand, goods_price])</span><br><span class="line"><span class="comment">#-------------------&gt;指令中只用%s即可,无需关注类型</span></span><br><span class="line">        self.conn.commit()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;成功添加%d行&quot;</span> % count)</span><br><span class="line">    <span class="comment"># 6.向品牌列表添加商品类型</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_type</span>(<span class="params">self</span>):</span><br><span class="line">        goods_type = <span class="built_in">input</span>(<span class="string">&quot;添加商品类型（回车确认）：&quot;</span>)</span><br><span class="line">        count = self.cursor.execute(<span class="string">&#x27;select * from name_type where name = %s;&#x27;</span>, [goods_type])</span><br><span class="line">        <span class="keyword">if</span> count:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;添加失败，已存在&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            count = self.cursor.execute(<span class="string">&#x27;insert into name_type values(0,%s) ;&#x27;</span>, [goods_type])</span><br><span class="line">            self.conn.commit()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;成功添加%d行&quot;</span> % count)</span><br><span class="line">    <span class="comment"># 7.修改商品价格</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update_price</span>(<span class="params">self</span>):</span><br><span class="line">        goods_name = <span class="built_in">input</span>(<span class="string">&quot;商品名称（回车确认）：&quot;</span>)</span><br><span class="line">        goods_price = <span class="built_in">round</span>(<span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;新商品价格（回车确认）：&quot;</span>)),<span class="number">2</span>)</span><br><span class="line">        count = self.cursor.execute(<span class="string">&#x27;update goods set price=%s where name=%s;&#x27;</span>,\</span><br><span class="line">                                    [goods_price, goods_name])</span><br><span class="line">        self.conn.commit()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;成功修改%d行&quot;</span> % count)</span><br><span class="line">    <span class="comment"># 8.删除某个商品</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">drop_one</span>(<span class="params">self</span>):</span><br><span class="line">        goods_name = <span class="built_in">input</span>(<span class="string">&quot;删除商品名称（回车确认）：&quot;</span>)</span><br><span class="line">        count = self.cursor.execute(<span class="string">&#x27;delete from goods where name=%s;&#x27;</span>,[goods_name])</span><br><span class="line">        self.conn.commit()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;成功删除%d行&quot;</span> % count)</span><br><span class="line"><span class="comment"># -----------------------------------------------#</span></span><br><span class="line">    <span class="comment"># 打印菜单,静态类放在静态块</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mune_print</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;-------欢迎--------&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;#1.查询所有商品&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;#2.查询所有品牌&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;#3.查询一个品牌的所有商品&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;#4.查询某一品牌商品的平均价格&quot;</span>)</span><br><span class="line"><span class="comment"># ---------------&gt;添加新添功能说明&lt;-----------------#</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;#5.向商品列表添加新商品&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;#6.向品牌列表添加商品类型&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;#7.修改商品价格&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;#8.删除某个商品&quot;</span>)</span><br><span class="line"><span class="comment"># -----------------------------------------------#</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;#9.退出&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">input</span>(<span class="string">&quot;请输入指令序号（回车确认）：&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 串联功能</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        self.link()</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            user_cmd = self.mune_print()</span><br><span class="line">            <span class="keyword">if</span> user_cmd == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                self.search_all()</span><br><span class="line">            <span class="keyword">elif</span> user_cmd == <span class="string">&quot;2&quot;</span>:</span><br><span class="line">                self.search_brand()</span><br><span class="line">            <span class="keyword">elif</span> user_cmd == <span class="string">&quot;3&quot;</span>:</span><br><span class="line">                self.search_brand_all()</span><br><span class="line">            <span class="keyword">elif</span> user_cmd == <span class="string">&quot;4&quot;</span>:</span><br><span class="line">                self.search_price()</span><br><span class="line"><span class="comment"># ---------------&gt;添加新添功能调用&lt;-----------------#</span></span><br><span class="line">            <span class="keyword">elif</span> user_cmd == <span class="string">&quot;5&quot;</span>:</span><br><span class="line">                self.add_one()</span><br><span class="line">            <span class="keyword">elif</span> user_cmd == <span class="string">&quot;6&quot;</span>:</span><br><span class="line">                self.add_type()</span><br><span class="line">            <span class="keyword">elif</span> user_cmd == <span class="string">&quot;7&quot;</span>:</span><br><span class="line">                self.update_price()</span><br><span class="line">            <span class="keyword">elif</span> user_cmd == <span class="string">&quot;8&quot;</span>:</span><br><span class="line">                self.drop_one()</span><br><span class="line"><span class="comment"># -----------------------------------------------#</span></span><br><span class="line">            <span class="keyword">elif</span> user_cmd == <span class="string">&quot;9&quot;</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 实现功能</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 创建京东商城对象</span></span><br><span class="line">    jd = JD()</span><br><span class="line">    <span class="comment"># 调用对象run方法，让其运行</span></span><br><span class="line">    jd.run()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;退出成功&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h2 id="第四章：MySQL高级"><a href="#第四章：MySQL高级" class="headerlink" title="第四章：MySQL高级"></a>第四章：MySQL高级</h2><blockquote>
<p>在使用过程中总会出现各种各样的问题，本章学习的语句将会解决其中一部分。</p>
</blockquote>
<h3 id="1-视图"><a href="#1-视图" class="headerlink" title="1.视图"></a>1.视图</h3><p>​        在实际的开发过程中<strong>存在着数据库结构需要发生变化</strong>的情况，一般情况下数据库结构发生变化，对应的代码也要进行修改，当项目很大的时候，其工作量巨大，<strong><em>视图</em></strong> 便是为了应对这一问题（<strong>仅用于查询</strong>）。类似于软件不同版本对应不同操作系统，其功能代码不变，仅解释器发生变化，<strong>视图</strong>在<strong>程序和数据表之间新建一个虚拟的表将数据库和代码之间隔离开</strong>来，使得<strong>后期更改表结构对代码改动减少</strong>。</p>
<pre class="mermaid">graph LR
a(代码)-->b(视图<br>虚拟表)
b-->c1(数据表1)
b-->c2(数据表2)
b-->c3(......)</pre>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建视图</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> `视图名` <span class="keyword">as</span> `查询语句`</span><br><span class="line"><span class="comment">-- 视图只能进行查询，不能对视图直接进行增删改操作</span></span><br></pre></td></tr></table></figure>
<h3 id="2-事务"><a href="#2-事务" class="headerlink" title="2.事务"></a>2.事务</h3><p>​        对于一些事情必须要两边同时生效，例如银行转账，一边+200，一边-200，只要有一方失败即转账失败，之前的操作就要作废，都成功才算成功，因此引入了事务来确保数据的一致性。事务SQL样本如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 建立一个事务 start trabsaction或者begin</span></span><br><span class="line"><span class="keyword">start</span> trabsaction;</span><br><span class="line"><span class="comment">-- 检查余额数目</span></span><br><span class="line"><span class="keyword">select</span> banlance <span class="keyword">from</span> checking <span class="keyword">where</span> customer_id <span class="operator">=</span> <span class="number">123456</span>;</span><br><span class="line"><span class="keyword">update</span> checking <span class="keyword">set</span> balance<span class="operator">=</span>balance<span class="number">-200</span> <span class="keyword">where</span> customer_id <span class="operator">=</span> <span class="number">123456</span>;</span><br><span class="line"><span class="keyword">update</span> savings <span class="keyword">set</span> balance<span class="operator">=</span>balance<span class="operator">+</span><span class="number">200</span> <span class="keyword">where</span> customer_id <span class="operator">=</span> <span class="number">123456</span>;</span><br><span class="line"><span class="comment">-- 执行完成，提交commit 回滚rollback</span></span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>
<p>一个很好的事务有以下几种特性，简称(<strong>ACID</strong>):</p>
<ul>
<li><strong>原子性(atomicity)</strong></li>
</ul>
<blockquote>
<p>一个事务必须视为一个<strong>不可分割</strong>的最小工作单元</p>
</blockquote>
<ul>
<li><strong>一致性(consistency)</strong></li>
</ul>
<blockquote>
<p>当事务中<strong>某一处</strong>出现问题，<strong>整个事务</strong>都<strong>不会生效</strong>。</p>
</blockquote>
<ul>
<li><strong>隔离性(isolation)</strong></li>
</ul>
<blockquote>
<p>当一个用户开启事务时，在其<strong>提交修改之前</strong>，对数据进行的<strong>修改仅自己可见</strong>，当其他人也对该数据进行修改时，需要<strong>等待前一个人</strong>事务<strong>结束</strong>。</p>
</blockquote>
<ul>
<li><strong>持久性(durbaility)</strong></li>
</ul>
<blockquote>
<p>数据<strong>存储在硬盘</strong>中，具有持久性</p>
</blockquote>
<p>在<strong>python中</strong>使用<strong>pysql默认开启事务</strong>，只有<strong>commit或者rollback</strong>之<strong>后</strong>才会<strong>结束</strong>本次事务。</p>
<h3 id="3-索引"><a href="#3-索引" class="headerlink" title="3.索引"></a>3.索引</h3><p>​       当想要在大量的数据中快速查找数据时，一条条搜索显然效率很低，这时候可以建立一个索引来<strong>提高搜索效率</strong>进行<strong>快速搜索</strong>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建索引</span></span><br><span class="line"><span class="keyword">create</span> index `索引名` <span class="keyword">on</span> `表名`(`列名(类型长度)`);</span><br><span class="line"><span class="comment">-- 显示索引</span></span><br><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> `表名`;</span><br><span class="line"><span class="comment">-- 删除索引</span></span><br><span class="line"><span class="keyword">drop</span> index `索引名` <span class="keyword">on</span> `表名`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 检测语句执行时间</span></span><br><span class="line"><span class="comment">-- 开始时间监控</span></span><br><span class="line"><span class="keyword">set</span> profiling<span class="operator">=</span><span class="string">&#x27;1&#x27;</span></span><br><span class="line"><span class="comment">-- 显示执行时间</span></span><br><span class="line"><span class="keyword">show</span> profiles;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- PS:主键和外键会默认设置为索引，索引会占用磁盘空间</span></span><br><span class="line"><span class="comment">-- 索引虽然能够提高搜索效率，但太多索引会降低更新和插入效率</span></span><br></pre></td></tr></table></figure>
<h3 id="4-权限管理"><a href="#4-权限管理" class="headerlink" title="4.权限管理"></a>4.权限管理</h3><p>​        在数据库的<strong>mysql库</strong>里查看<strong>user表</strong>可以看到能够访问数据库的用户，通过增删改查操作能够<strong>添加用户</strong>，<strong>删除用户</strong>，<strong>修改用户权限</strong>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 进入mysql库</span></span><br><span class="line">use mysql</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看user信息，用户名，登录权限，以及加密后的密码</span></span><br><span class="line"><span class="keyword">select</span> host,<span class="keyword">user</span>,authentication_string <span class="keyword">from</span> <span class="keyword">user</span>;</span><br><span class="line"><span class="comment">-- host信息%代表可以任意地方登录，localhost只能本地登录，固定ip代表只能特定主机登录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建用户并授权</span></span><br><span class="line"><span class="comment">-- 常用权限select insert delete drop update所有权限all privileges</span></span><br><span class="line"><span class="keyword">grant</span> `权限列表` <span class="keyword">on</span> `数据库` <span class="keyword">to</span> `用户名`@`访问主机` indentified <span class="keyword">by</span> `密码`;</span><br><span class="line"><span class="comment">-- 查看用户权限</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">grant</span> <span class="keyword">for</span> `用户名`@`访问主机`;</span><br><span class="line"><span class="comment">-- 修改用户权限</span></span><br><span class="line"><span class="keyword">grant</span> `权限列表` <span class="keyword">on</span> `数据库` <span class="keyword">to</span> `用户名`@`访问主机` <span class="keyword">with</span> <span class="keyword">grant</span> option;</span><br><span class="line"><span class="comment">-- 修改权限后必须刷新权限</span></span><br><span class="line">flush privileges;</span><br><span class="line"><span class="comment">-- 修改用户密码</span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> authentication_string<span class="operator">=</span>password(<span class="string">&#x27;新密码&#x27;</span>) <span class="keyword">where</span> <span class="keyword">user</span><span class="operator">=</span><span class="string">&#x27;用户名&#x27;</span>;</span><br><span class="line"><span class="comment">-- 删除用户</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">user</span> `用户名`@`访问主机`;</span><br></pre></td></tr></table></figure>
<h3 id="5-主从结构"><a href="#5-主从结构" class="headerlink" title="5.主从结构"></a>5.主从结构</h3><p>​        如果一个数据库突然停止工作，很容易造成问题，可以添加从服务器使得<strong>两个数据库数据同步</strong>，这样在一个库不能使用的时候，不会产生很大影响，从服务器也能够为主服务器<strong>分担访问压力</strong>。</p>
<h2 id="第五章：小项目—omyoji碎片互换"><a href="#第五章：小项目—omyoji碎片互换" class="headerlink" title="第五章：小项目—omyoji碎片互换"></a>第五章：小项目—omyoji碎片互换</h2><h3 id="1-创建表"><a href="#1-创建表" class="headerlink" title="1.创建表"></a>1.创建表</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 通过分析，需要有用户表，式神表，碎片数目表，清单表，交换表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>(</span><br><span class="line">    id <span class="type">int</span> unsigned <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">    user_name <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">unique</span>,</span><br><span class="line">    user_passage <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> &quot;000000&quot;</span><br><span class="line">    );</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> shishen(</span><br><span class="line">    id <span class="type">int</span> unsigned <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">    shishen_name <span class="type">varchar</span>(<span class="number">8</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">unique</span></span><br><span class="line">    );  </span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> chip_num(</span><br><span class="line">    id <span class="type">int</span> unsigned <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">    shishen_id <span class="type">int</span> unsigned <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    user_id <span class="type">int</span> unsigned <span class="keyword">not</span> <span class="keyword">null</span> ,</span><br><span class="line">    num <span class="type">int</span> unsigned <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    give_get enum(&quot;供给&quot;,&quot;需求&quot;) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> &quot;供给&quot;</span><br><span class="line">    ); </span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> trans(</span><br><span class="line">    id <span class="type">int</span> unsigned <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">    shishen_id <span class="type">int</span> unsigned <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    user_id <span class="type">int</span> unsigned <span class="keyword">not</span> <span class="keyword">null</span> ,</span><br><span class="line">    num <span class="type">int</span> unsigned <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    list_id <span class="type">int</span> unsigned <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">    ); </span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> list(</span><br><span class="line">    id <span class="type">int</span> unsigned <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">    user_id1 <span class="type">int</span> unsigned <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    user_id2 <span class="type">int</span> unsigned <span class="keyword">not</span> <span class="keyword">null</span> ,</span><br><span class="line">    flag enum(&quot;已确认&quot;,&quot;待确认&quot;,&quot;已取消&quot;) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> &quot;待确认&quot;,</span><br><span class="line">    <span class="type">time</span> datetime <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">    );</span><br><span class="line"><span class="comment">-- 向其中添加几个数据方便后续操作</span></span><br><span class="line"><span class="comment">-- 使用过程中将经常使用的联合调用的几张表做成一个视图，方便使用</span></span><br></pre></td></tr></table></figure>
<h3 id="2-功能实现"><a href="#2-功能实现" class="headerlink" title="2.功能实现"></a>2.功能实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置功能</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">1.用户能登录能注册，可修改密码</span></span><br><span class="line"><span class="string">2.用户可以查询式神碎片的拥有者和数量</span></span><br><span class="line"><span class="string">3.程序可以自动筛选出供需关系对应的数据</span></span><br><span class="line"><span class="string">4.当匹配成功时，用户可以根据信息选择一个提出请求</span></span><br><span class="line"><span class="string">5.请求可以同时提出多个，但一个生效后其余作废</span></span><br><span class="line"><span class="string">6.请求生效后，修改碎片供需表的信息</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> os,time</span><br><span class="line"><span class="keyword">import</span> builtins <span class="keyword">as</span> exceptions</span><br><span class="line"><span class="keyword">from</span> pymysql <span class="keyword">import</span> connect</span><br><span class="line"><span class="keyword">from</span> prettytable <span class="keyword">import</span> PrettyTable</span><br><span class="line"><span class="comment"># 一般类名大写</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OMYOJI</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment">#函数调用开始前连接数据库</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 创建connection连接，输入端口，用户名，密码和使用的库</span></span><br><span class="line">        self.conn = connect(host=<span class="string">&#x27;数据库外网地址&#x27;</span>, port=<span class="number">3306</span>, user=<span class="string">&#x27;用户名&#x27;</span>, \</span><br><span class="line">                       password=<span class="string">&#x27;密码&#x27;</span>, database=<span class="string">&#x27;omyoji&#x27;</span>, charset=<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">        <span class="comment"># 获得游标cursor对象</span></span><br><span class="line">        self.cursor = self.conn.cursor()</span><br><span class="line">    <span class="comment">#类下函数调用结束后关闭数据库</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 关闭游标对象和连接</span></span><br><span class="line">        self.cursor.close()</span><br><span class="line">        self.conn.close()</span><br><span class="line">    <span class="comment">#用户登录</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">link</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># 链接用户表，查询用户是否存在</span></span><br><span class="line">            user_name=<span class="built_in">input</span>(<span class="string">&#x27;请输入用户名（回车确认）：&#x27;</span>)</span><br><span class="line">            count = self.cursor.execute(<span class="string">&quot;select user_name from user where user_name=%s;&quot;</span>,[user_name])</span><br><span class="line">            <span class="comment"># 用户存在对照密码，验证是否正确</span></span><br><span class="line">            <span class="keyword">if</span> count:</span><br><span class="line">                user_pass = <span class="built_in">input</span>(<span class="string">&#x27;请输入密码（回车确认）：&#x27;</span>)</span><br><span class="line">                self.cursor.execute(<span class="string">&quot;select user_passage from user where user_name=%s;&quot;</span> ,[user_name])</span><br><span class="line">                <span class="keyword">if</span> self.cursor.fetchone()[<span class="number">0</span>]==user_pass:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;登录成功&quot;</span>)</span><br><span class="line">                    os.system(<span class="string">&#x27;cls&#x27;</span>)</span><br><span class="line">                    <span class="keyword">return</span> user_name</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;请重新尝试&quot;</span>)</span><br><span class="line">            <span class="comment"># 用户不存在，是否添加信息</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;无用户名---&gt;0.返回\n----------&gt;1.使用该用户注册&#x27;</span>)</span><br><span class="line">                user_cmd = <span class="built_in">input</span>(<span class="string">&quot;请输入指令（回车确认）：&quot;</span>)</span><br><span class="line">                <span class="keyword">if</span> user_cmd == <span class="string">&quot;0&quot;</span>:</span><br><span class="line">                    <span class="keyword">pass</span></span><br><span class="line">                <span class="keyword">elif</span> user_cmd == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                        user_pass = <span class="built_in">input</span>(<span class="string">&#x27;请输入密码（回车确认）：&#x27;</span>)</span><br><span class="line">                        user_pass1 = <span class="built_in">input</span>(<span class="string">&#x27;请再次输入密码（回车确认）：&#x27;</span>)</span><br><span class="line">                        <span class="keyword">if</span> user_pass1==user_pass:</span><br><span class="line">                            <span class="keyword">pass</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            <span class="built_in">print</span>(<span class="string">&quot;两次密码不一致，重新输入&quot;</span>)</span><br><span class="line">                            <span class="keyword">continue</span></span><br><span class="line">                        self.cursor.execute(<span class="string">&#x27;insert into user values(0,%s,%s);&#x27;</span>, [user_name, user_pass])</span><br><span class="line">                        self.conn.commit()</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">&quot;添加成功，重新登录&quot;</span>)</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">    <span class="comment">#查询用户/式神id</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">name_id</span>(<span class="params">self,name,shishen_user</span>):</span><br><span class="line">        <span class="keyword">if</span> shishen_user:</span><br><span class="line">            count = self.cursor.execute(<span class="string">&quot;&quot;&quot;select id from user where user_name=%s;&quot;&quot;&quot;</span>, [name])</span><br><span class="line">            <span class="keyword">if</span> count:</span><br><span class="line">                <span class="keyword">return</span> self.cursor.fetchone()[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;查询不存在&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            count = self.cursor.execute(<span class="string">&quot;select id from shishen where shishen_name=%s;&quot;</span>, [name])</span><br><span class="line">            <span class="keyword">if</span> count:</span><br><span class="line">                <span class="keyword">return</span> self.cursor.fetchone()[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;查询不存在&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="comment">#返回上一级菜单</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">return_mune</span>(<span class="params">self</span>):</span><br><span class="line">        flag = <span class="built_in">input</span>(<span class="string">&quot;是否返回上层（y/n 回车确认）：&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> flag == <span class="string">&quot;y&quot;</span>:</span><br><span class="line">            os.system(<span class="string">&#x27;cls&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="comment">#添加/更新碎片供需信息</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_give_get</span>(<span class="params">self,user,give_get</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            shishen_name = <span class="built_in">input</span>(<span class="string">&#x27;请输入式神名（回车确认）：&#x27;</span>)</span><br><span class="line">            count = self.cursor.execute(<span class="string">&quot;select id from shishen where shishen_name=%s;&quot;</span>, [shishen_name])</span><br><span class="line">            <span class="keyword">if</span> count:</span><br><span class="line">                shishen_id = self.cursor.fetchone()[<span class="number">0</span>]</span><br><span class="line">                user_id = self.name_id(user,<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    num = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入碎片数量（回车确认）：&#x27;</span>))</span><br><span class="line">                <span class="keyword">except</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;输入格式错误&quot;</span>)</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                count = self.cursor.execute(<span class="string">&quot;select * from chip_num where shishen_id=%s and user_id=%s;&quot;</span>, \</span><br><span class="line">                                            [shishen_id, user_id])</span><br><span class="line">                <span class="keyword">if</span> count:</span><br><span class="line">                    count = self.cursor.execute(<span class="string">&quot;update chip_num set num=%s where shishen_id=%s \</span></span><br><span class="line"><span class="string">                        and user_id=%s;&quot;</span>,[num, shishen_id, user_id])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    count=self.cursor.execute(<span class="string">&quot;insert into chip_num values (0,%s,%s,%s,%s);&quot;</span>,\</span><br><span class="line">                                          [shishen_id,user_id,num,give_get])</span><br><span class="line">                <span class="keyword">if</span> count:</span><br><span class="line">                    self.conn.commit()</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;添加/更新成功&quot;</span>)</span><br><span class="line">                    <span class="keyword">if</span> self.return_mune(): <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self.conn.rollback()</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;添加/更新失败&quot;</span>)</span><br><span class="line">                    <span class="keyword">if</span> self.return_mune(): <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;没有该式神&quot;</span>)</span><br><span class="line">                <span class="keyword">if</span> self.return_mune(): <span class="keyword">break</span></span><br><span class="line">    <span class="comment">#查看自己需要式神的碎片信息，选择人进行交换</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search_msg</span>(<span class="params">self,user</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            shishen_name = <span class="built_in">input</span>(<span class="string">&#x27;请输入所需碎片的式神（回车确认）：&#x27;</span>)</span><br><span class="line">            shishen_id = self.name_id(shishen_name,<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> shishen_id: <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> self.return_mune():<span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:<span class="keyword">continue</span></span><br><span class="line">            self.cursor.execute(<span class="string">&quot;&quot;&quot;select u.user_name,c.num,g.name,g.num from chip_num c inner join\</span></span><br><span class="line"><span class="string">             user u on u.id=c.user_id inner join(select m.user_id id,group_concat(s.shishen_name)\</span></span><br><span class="line"><span class="string">                        name,group_concat(m.num) num from chip_num m inner join shishen s on s.id=m.shishen_id\</span></span><br><span class="line"><span class="string">                          and m.give_get=&quot;需求&quot; group by m.user_id) as g on c.user_id=g.id\</span></span><br><span class="line"><span class="string">                           where c.shishen_id=%s and c.give_get=&quot;供给&quot;;&quot;&quot;&quot;</span>, [shishen_id])</span><br><span class="line">            message = self.cursor.fetchall()</span><br><span class="line">            table = PrettyTable([<span class="string">&quot;寮友&quot;</span>, <span class="string">&quot;提供数量&quot;</span>, <span class="string">&quot;需求式神&quot;</span>,<span class="string">&quot;需求数量&quot;</span>])</span><br><span class="line">            table.align[<span class="string">&quot;寮友&quot;</span>] = <span class="string">&quot;l&quot;</span>  <span class="comment"># 以式神字段左对齐</span></span><br><span class="line">            table.padding_width = <span class="number">1</span>  <span class="comment"># 填充宽度</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> message:</span><br><span class="line">                table.add_row(<span class="built_in">list</span>(i))</span><br><span class="line">            <span class="built_in">print</span>(table)</span><br><span class="line">            flag = <span class="built_in">input</span>(<span class="string">&quot;是否进行交换（y/n 回车确认）：&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> flag ==<span class="string">&quot;y&quot;</span>:</span><br><span class="line">                <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                    give_name = <span class="built_in">input</span>(<span class="string">&quot;请输入选择交换人的名称（回车确认）：&quot;</span>)</span><br><span class="line">                    give_name_id = self.name_id(give_name,<span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">if</span> give_name_id:</span><br><span class="line">                        <span class="keyword">pass</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">if</span> self.return_mune():</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            <span class="keyword">continue</span></span><br><span class="line">                    give_shishen = <span class="built_in">input</span>(<span class="string">&quot;请输入你提供碎片的式神（回车确认）：&quot;</span>)</span><br><span class="line">                    give_shishen_id = self.name_id(give_shishen, <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">if</span> give_shishen_id:</span><br><span class="line">                        <span class="keyword">pass</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">if</span> self.return_mune():</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            <span class="keyword">continue</span></span><br><span class="line">                    count = self.cursor.execute(<span class="string">&quot;&quot;&quot;select * from chip_num where user_id=%s \</span></span><br><span class="line"><span class="string">                                    and shishen_id=%s and give_get=&quot;需求&quot;;&quot;&quot;&quot;</span>,[give_name_id, give_shishen_id])</span><br><span class="line">                    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                        <span class="keyword">try</span>:</span><br><span class="line">                            shishen_num = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入你提供碎片的数量（回车确认）：&quot;</span>))</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                        <span class="keyword">except</span>:</span><br><span class="line">                            <span class="built_in">print</span>(<span class="string">&quot;输入格式错误&quot;</span>)</span><br><span class="line">                    user_id = self.name_id(user, <span class="number">1</span>)</span><br><span class="line">                    self.cursor.execute(<span class="string">&quot;&quot;&quot;select num from chip_num where user_id=%s and\</span></span><br><span class="line"><span class="string">                     shishen_id=%s and give_get=&quot;供给&quot;;&quot;&quot;&quot;</span>,[user_id,give_shishen_id])</span><br><span class="line">                    num1= self.cursor.fetchone()[<span class="number">0</span>]</span><br><span class="line">                    self.cursor.execute(<span class="string">&quot;&quot;&quot;select num from chip_num where user_id=%s and\</span></span><br><span class="line"><span class="string">                     shishen_id=%s and give_get=&quot;供给&quot;;&quot;&quot;&quot;</span>, [give_name_id,shishen_id])</span><br><span class="line">                    num2 = self.cursor.fetchone()[<span class="number">0</span>]</span><br><span class="line">                    <span class="keyword">if</span> shishen_num&gt;num1 <span class="keyword">or</span> <span class="built_in">int</span>(shishen_num)&gt;num2:</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">&quot;碎片数量不足&quot;</span>)</span><br><span class="line">                        <span class="keyword">if</span> self.return_mune(): <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        l_time=time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, time.localtime())</span><br><span class="line">                        self.cursor.execute(<span class="string">&quot;insert into list values (0,%s,%s,default,%s);&quot;</span>,[user_id,give_name_id,l_time])</span><br><span class="line">                        self.cursor.execute(<span class="string">&quot;select max(id) from list where user_id1=%s;&quot;</span>,[user_id])</span><br><span class="line">                        list_id = self.cursor.fetchone()[<span class="number">0</span>]</span><br><span class="line">                        self.cursor.execute(<span class="string">&quot;insert into trans values (0,%s,%s,%s,%s);&quot;</span>,\</span><br><span class="line">                                                  [give_shishen_id,user_id,shishen_num,list_id])</span><br><span class="line">                        count = self.cursor.execute(<span class="string">&quot;insert into trans values (0,%s,%s,%s,%s);&quot;</span>,\</span><br><span class="line">                                                    [shishen_id, give_name_id, shishen_num, list_id])</span><br><span class="line">                        <span class="keyword">if</span> count:</span><br><span class="line">                            self.conn.commit()</span><br><span class="line">                            <span class="built_in">print</span>(<span class="string">&quot;交换单号生成&quot;</span>)</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            self.conn.rollback()</span><br><span class="line">                            <span class="built_in">print</span>(<span class="string">&quot;申请失败&quot;</span>)</span><br><span class="line">                        <span class="keyword">if</span> self.return_mune():</span><br><span class="line">                            <span class="built_in">print</span>(<span class="string">&quot;继续填写交换申请&quot;</span>)</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                os.system(<span class="string">&#x27;cls&#x27;</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;返回主界面&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> self.return_mune(): <span class="keyword">break</span></span><br><span class="line">    <span class="comment">#查看申请，处理申请</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search_trans</span>(<span class="params">self,user</span>):</span><br><span class="line">        user_id = self.name_id(user, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;#1.查看我提交的请求（可取消）&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;#2.查看我需要处理的请求（可接受或取消)&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;#3.查看关于我的所有请求&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;#4.其他键返回菜单&quot;</span>)</span><br><span class="line">            num = <span class="built_in">input</span>(<span class="string">&quot;请输入指令（回车确认）：&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> num==<span class="string">&quot;1&quot;</span>:</span><br><span class="line">                self.cursor.execute(<span class="string">&quot;select id,shishen1,trans2,shishen2,num2,flag,time from trans_list\</span></span><br><span class="line"><span class="string">                 where trans1=%s;&quot;</span>, [user])</span><br><span class="line">                self.conn.commit()</span><br><span class="line">                message = self.cursor.fetchall()</span><br><span class="line">                table = PrettyTable([<span class="string">&quot;单号&quot;</span>,<span class="string">&quot;交换式神&quot;</span>,<span class="string">&quot;交易对象&quot;</span>,<span class="string">&quot;式神&quot;</span>,<span class="string">&quot;碎片数量&quot;</span>,<span class="string">&quot;状态&quot;</span>,<span class="string">&quot;时间&quot;</span>])</span><br><span class="line">                table.align[<span class="string">&quot;单号&quot;</span>] = <span class="string">&quot;l&quot;</span>  <span class="comment"># 以式神字段左对齐</span></span><br><span class="line">                table.padding_width = <span class="number">1</span>  <span class="comment"># 填充宽度</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> message:</span><br><span class="line">                    table.add_row(<span class="built_in">list</span>(i))</span><br><span class="line">                <span class="built_in">print</span>(table)</span><br><span class="line">                flag=<span class="built_in">input</span>(<span class="string">&quot;是否更改请求状态（y/n 回车确认）：&quot;</span>)</span><br><span class="line">                <span class="keyword">if</span> flag==<span class="string">&quot;y&quot;</span>:</span><br><span class="line">                    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                            <span class="keyword">try</span>:</span><br><span class="line">                                change_list = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入要取消的订单号：&quot;</span>))</span><br><span class="line">                                <span class="keyword">break</span></span><br><span class="line">                            <span class="keyword">except</span>:</span><br><span class="line">                                <span class="built_in">print</span>(<span class="string">&quot;输入格式错误&quot;</span>)</span><br><span class="line">                        count=self.cursor.execute(<span class="string">&quot;update list set flag=&#x27;已取消&#x27; where (flag=&#x27;待确认&#x27; or flag=&#x27;已确认&#x27;)\</span></span><br><span class="line"><span class="string">                          and user_id1=%s and id=%s&quot;</span>,[user_id,change_list])</span><br><span class="line">                        self.conn.commit()</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">&quot;成功修改%d行&quot;</span>%count)</span><br><span class="line">                        <span class="keyword">if</span> self.return_mune():</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> num==<span class="string">&quot;2&quot;</span>:</span><br><span class="line">                self.cursor.execute(<span class="string">&quot;select id,shishen2,trans1,shishen1,num1,flag,time from trans_list\</span></span><br><span class="line"><span class="string">                 where trans2=%s;&quot;</span>, [user])</span><br><span class="line">                self.conn.commit()</span><br><span class="line">                message = self.cursor.fetchall()</span><br><span class="line">                table = PrettyTable([<span class="string">&quot;单号&quot;</span>,<span class="string">&quot;交换式神&quot;</span>,<span class="string">&quot;提出方&quot;</span>,<span class="string">&quot;式神&quot;</span>,<span class="string">&quot;碎片数量&quot;</span>,<span class="string">&quot;状态&quot;</span>,<span class="string">&quot;时间&quot;</span>])</span><br><span class="line">                table.align[<span class="string">&quot;单号&quot;</span>] = <span class="string">&quot;l&quot;</span>  <span class="comment"># 以式神字段左对齐</span></span><br><span class="line">                table.padding_width = <span class="number">1</span>  <span class="comment"># 填充宽度</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> message:</span><br><span class="line">                    table.add_row(<span class="built_in">list</span>(i))</span><br><span class="line">                <span class="built_in">print</span>(table)</span><br><span class="line">                flag = <span class="built_in">input</span>(<span class="string">&quot;是否更改请求状态\n#1.取消订单\n#2.确认订单\n#其他.返回上层\n请输入指令序号：&quot;</span>)</span><br><span class="line">                <span class="keyword">if</span> flag <span class="keyword">in</span> (<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>):</span><br><span class="line">                    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                            <span class="keyword">try</span>:</span><br><span class="line">                                <span class="keyword">if</span> flag == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                                    change_list = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入要取消的订单号：&quot;</span>))</span><br><span class="line">                                <span class="keyword">elif</span> flag == <span class="string">&quot;2&quot;</span>:</span><br><span class="line">                                    change_list = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入要确定的订单号：&quot;</span>))</span><br><span class="line">                                <span class="keyword">break</span></span><br><span class="line">                            <span class="keyword">except</span>:</span><br><span class="line">                                <span class="built_in">print</span>(<span class="string">&quot;输入格式错误&quot;</span>)</span><br><span class="line">                        <span class="keyword">if</span> flag == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                            count = self.cursor.execute(<span class="string">&quot;update list set flag=&#x27;已取消&#x27; where (flag=&#x27;待确认&#x27; or flag=&#x27;已确认&#x27;)\</span></span><br><span class="line"><span class="string">                                          and user_id2=%s and id=%s&quot;</span>, [user_id, change_list])</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            count = self.cursor.execute(<span class="string">&quot;update list set flag=&#x27;已确认&#x27; where flag=&#x27;待确认&#x27;\</span></span><br><span class="line"><span class="string">                             and user_id2=%s and id=%s&quot;</span>, [user_id, change_list])</span><br><span class="line">                        self.conn.commit()</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">&quot;成功修改%d行&quot;</span> % count)</span><br><span class="line">                        <span class="keyword">if</span> self.return_mune():</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> num==<span class="string">&quot;3&quot;</span>:</span><br><span class="line">                self.cursor.execute(<span class="string">&quot;select * from trans_list where trans1=%s or trans2=%s;&quot;</span>,[user,user])</span><br><span class="line">                self.conn.commit()</span><br><span class="line">                message = self.cursor.fetchall()</span><br><span class="line">                table = PrettyTable([<span class="string">&quot;单号&quot;</span>, <span class="string">&quot;提出方&quot;</span>,<span class="string">&quot;提供碎片&quot;</span>,<span class="string">&quot;数量&quot;</span>, <span class="string">&quot;处理方&quot;</span>,<span class="string">&quot;提供碎片 &quot;</span>,<span class="string">&quot;数量 &quot;</span>,<span class="string">&quot;状态&quot;</span>,<span class="string">&quot;时间&quot;</span>])</span><br><span class="line">                table.align[<span class="string">&quot;单号&quot;</span>] = <span class="string">&quot;l&quot;</span>  <span class="comment"># 以式神字段左对齐</span></span><br><span class="line">                table.padding_width = <span class="number">1</span>  <span class="comment"># 填充宽度</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> message:</span><br><span class="line">                    table.add_row(<span class="built_in">list</span>(i))</span><br><span class="line">                <span class="built_in">print</span>(table)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> self.return_mune():</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">    <span class="comment">#查看个人发布的所有碎片信息</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mine_all_chip</span>(<span class="params">self,user</span>):</span><br><span class="line">        self.cursor.execute(<span class="string">&quot;select s.shishen_name,c.num,c.give_get from chip_num c inner join user u \</span></span><br><span class="line"><span class="string">                on c.user_id=u.id inner join shishen s on c.shishen_id=s.id \</span></span><br><span class="line"><span class="string">                where u.user_name=%s order by c.give_get;&quot;</span>, [user])</span><br><span class="line">        self.conn.commit()</span><br><span class="line">        message = self.cursor.fetchall()</span><br><span class="line">        table = PrettyTable([<span class="string">&quot;式神&quot;</span>, <span class="string">&quot;数目&quot;</span>, <span class="string">&quot;供需&quot;</span>])</span><br><span class="line">        table.align[<span class="string">&quot;式神&quot;</span>] = <span class="string">&quot;l&quot;</span>  <span class="comment"># 以式神字段左对齐</span></span><br><span class="line">        table.padding_width = <span class="number">1</span>  <span class="comment"># 填充宽度</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> message:</span><br><span class="line">            table.add_row(<span class="built_in">list</span>(i))</span><br><span class="line">        <span class="built_in">print</span>(table)</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> self.return_mune(): <span class="keyword">break</span></span><br><span class="line">    <span class="comment">#修改密码</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update_passage</span>(<span class="params">self,user</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            new_passage = <span class="built_in">input</span>(<span class="string">&quot;请输入新密码（回车确认）：&quot;</span>)</span><br><span class="line">            count = self.cursor.execute(<span class="string">&quot;update user set user_passage=%s where user_name=%s;&quot;</span>\</span><br><span class="line">                                           ,[new_passage,user])</span><br><span class="line">            <span class="keyword">if</span> count:</span><br><span class="line">                self.conn.commit()</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;密码修改成功&quot;</span>)</span><br><span class="line">                os.system(<span class="string">&#x27;cls&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.conn.rollback()</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;密码修改失败&quot;</span>)</span><br><span class="line">                <span class="keyword">if</span> self.return_mune(): <span class="keyword">break</span></span><br><span class="line">    <span class="comment">#打印菜单,静态类放在静态块</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mune_print</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;-------欢迎--------&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;#1.添加/修改碎片提供信息&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;#2.添加/修改碎片需求信息&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;#3.查询需求碎片信息&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;#4.查看交换请求&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;#5.查看自己所有碎片&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;#6.修改密码&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;#7.退出&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">input</span>(<span class="string">&quot;请输入指令序号（回车确认）：&quot;</span>)</span><br><span class="line">    <span class="comment">#串联功能</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        user_name = self.link()</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            user_cmd = self.mune_print()</span><br><span class="line">            os.system(<span class="string">&#x27;cls&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> user_cmd == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                self.add_give_get(user_name,<span class="string">&quot;供给&quot;</span>)</span><br><span class="line">                os.system(<span class="string">&#x27;cls&#x27;</span>)</span><br><span class="line">            <span class="keyword">elif</span> user_cmd==<span class="string">&quot;2&quot;</span>:</span><br><span class="line">                self.add_give_get(user_name,<span class="string">&quot;需求&quot;</span>)</span><br><span class="line">                os.system(<span class="string">&#x27;cls&#x27;</span>)</span><br><span class="line">            <span class="keyword">elif</span> user_cmd==<span class="string">&quot;3&quot;</span>:</span><br><span class="line">                self.search_msg(user_name)</span><br><span class="line">            <span class="keyword">elif</span> user_cmd==<span class="string">&quot;4&quot;</span>:</span><br><span class="line">                self.search_trans(user_name)</span><br><span class="line">            <span class="keyword">elif</span> user_cmd==<span class="string">&quot;5&quot;</span>:</span><br><span class="line">                self.mine_all_chip(user_name)</span><br><span class="line">            <span class="keyword">elif</span> user_cmd==<span class="string">&quot;6&quot;</span>:</span><br><span class="line">                self.update_passage(user_name)</span><br><span class="line">            <span class="keyword">elif</span> user_cmd==<span class="string">&quot;7&quot;</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    omyoji = OMYOJI()</span><br><span class="line">    omyoji.run()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;退出成功&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="3-问题总结"><a href="#3-问题总结" class="headerlink" title="3.问题总结"></a>3.问题总结</h3><ol>
<li><strong>数据库结构</strong>: 首先需要先想好需要建立的表单，建立完成后再进行程序编写，如有需要要建立<em>视图</em>，方便后面数据库变动。</li>
<li><strong>python语法</strong>: 在python中使用sql语句换行时要注意空格数目，实时查询数据要每次查完后提交事务。</li>
<li><strong>python版本问题</strong>：在python 3中的异常类更新为新库<code>import builtins as exceptions</code></li>
<li><strong>数据库远程连接</strong>: 自己做需要用的ssh、内网穿透相关知识，使用云数据库可省去该过程，使用方便。</li>
<li><strong>exe文件打包</strong>: 在使用pyinstaller进行打包时该路径下python要安装过使用的所有包，否则exe文件报错找不到模块。</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>docker基础</title>
    <url>/link/327177db.html</url>
    <content><![CDATA[<h2 id="关于docker的使用"><a href="#关于docker的使用" class="headerlink" title="关于docker的使用"></a>关于docker的使用</h2><h3 id="第一节：-docker概述"><a href="#第一节：-docker概述" class="headerlink" title="第一节： docker概述"></a>第一节： docker概述</h3><h4 id="1-使用原因"><a href="#1-使用原因" class="headerlink" title="1.使用原因"></a>1.使用原因</h4><p>一款产品  从开发到上线  两套环境  应用环境，应用配置不同</p>
<p>开发——-&gt;运维  环境不同导致不同电脑不能执行</p>
<p>docker就能将项目和环境一同打包</p>
<p>传统：开发jar，运维做其他</p>
<p>现在：开发打包部署上线，一套流程做完</p>
<p>dokcer提出镜像来进行传输，使用容器来对多个程序进行隔离</p>
<h4 id="2-docker历史"><a href="#2-docker历史" class="headerlink" title="2.docker历史"></a>2.docker历史</h4><p>2010年，几个年轻人创立公司，成立公司，使用容器LXC技术，将容器化技术称为docker。</p>
<p>2013年，运营困难，docker开源，docker的优点显现</p>
<p>2014年，docker1.0发布</p>
<p>docker对比虚拟机十分轻巧，也是一个虚拟化技术</p>
<h4 id="3-有关docker"><a href="#3-有关docker" class="headerlink" title="3.有关docker"></a>3.有关docker</h4><p>docker基于go语言开发，开源代码</p>
<p>官网：<a href="https://www.docker.com/">https://www.docker.com/</a></p>
<p>文档网站：<a href="https://docs.docker.com/">https://docs.docker.com/</a> </p>
<p>仓库地址：<a href="https://hub.docker.com/">https://hub.docker.com/</a>    </p>
<h4 id="4-docker能做什么？"><a href="#4-docker能做什么？" class="headerlink" title="4.docker能做什么？"></a>4.docker能做什么？</h4><blockquote>
<p>虚拟机技术</p>
</blockquote>
<p>模拟一个真实的物理机器</p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202302052217921.png" alt="image-20230205221713905"></p>
<p>缺点：占用资源多，冗余步骤多，启动慢</p>
<blockquote>
<p>容器化技术</p>
</blockquote>
<p>容器化技术内的容器没有自己的内核</p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202302052218490.png" alt="image-20230205221800271"></p>
<p>优点：</p>
<ul>
<li><p>应用和快速的交付和部署</p>
</li>
<li><p>更快捷的升级和扩缩容</p>
</li>
<li><p>更简单的系统运维</p>
</li>
<li><p>更高效的资源利用</p>
</li>
</ul>
<h4 id="5-docker的基本组成"><a href="#5-docker的基本组成" class="headerlink" title="5.docker的基本组成"></a>5.docker的基本组成</h4><p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202302052217652.png" alt="image-20230205221740846"></p>
<ul>
<li><strong>镜像(image)：</strong>docker镜像就好像一个模板，可以通过模板来创建容器服务。</li>
<li><strong>容器(container)：</strong>docker利用容器技术去独立运行一个或一组应用。</li>
<li><strong>仓库(repository)：</strong>存放镜像的地方，默认国外地址，可配置国内源镜像加速。</li>
</ul>
<h3 id="第二节：docker安装"><a href="#第二节：docker安装" class="headerlink" title="第二节：docker安装"></a>第二节：docker安装</h3><ul>
<li><a href="https://www.liumeng.top/link/docker0228.html">https://www.liumeng.top/link/docker0228.html</a></li>
</ul>
<h3 id="第三节：docker镜像"><a href="#第三节：docker镜像" class="headerlink" title="第三节：docker镜像"></a>第三节：docker镜像</h3><blockquote>
<p>运行命令前，可先检查docker的运行情况，<code>docker version</code>正常会出现客户端和服务端的信息，如果不是在管理员环境下运行，则需要加<code>sudo</code>，也可使用<code>sudo su</code>命令使用root权限。</p>
</blockquote>
<h4 id="0-帮助命令"><a href="#0-帮助命令" class="headerlink" title="0.帮助命令"></a>0.帮助命令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>操作</th>
<th>命令</th>
</tr>
</thead>
<tbody>
<tr>
<td>显示docker的版本信息</td>
<td><code>docker version</code></td>
</tr>
<tr>
<td>显示docker的系统信息</td>
<td><code>docker info</code></td>
</tr>
<tr>
<td>查看操作的帮助文档</td>
<td><code>docker 命令 --help</code></td>
</tr>
</tbody>
</table>
</div>
<p>官网的帮助文档：<a href="https://docs.docker.com/engine/reference/commandline/">https://docs.docker.com/engine/reference/commandline/</a></p>
<h4 id="1-镜像操作"><a href="#1-镜像操作" class="headerlink" title="1.镜像操作"></a>1.镜像操作</h4><div class="table-container">
<table>
<thead>
<tr>
<th>操作</th>
<th>命令</th>
</tr>
</thead>
<tbody>
<tr>
<td>显示镜像</td>
<td><code>docker images</code></td>
</tr>
<tr>
<td>搜索镜像</td>
<td><code>docker search 镜像</code></td>
</tr>
<tr>
<td>拉取镜像</td>
<td><code>docker pull 镜像:tag</code></td>
</tr>
<tr>
<td>删除镜像，-f为强制删除</td>
<td><code>docker rmi -f 镜像ID</code></td>
</tr>
<tr>
<td>批量删除</td>
<td><code>docker rmi -f $(docker images -q)</code></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>拉取镜像时会出现一串的pull，这是docker里的文件分层，当后续的需下载的镜像用到之前下载的文件时，就不再下载，减少了内存的使用，使用的是docker的联合文件系统。</li>
<li><code>$()</code>可以使用此符号将括号内的参数传递给上级命令</li>
</ul>
<blockquote>
<p>镜像提交</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">提交到本地</span></span><br><span class="line">docker commit -a=&quot;作者&quot; -m=&quot;描述&quot; 容器id 提交的镜像名称:版本号</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">绑定的本地文件不会被打包到镜像中</span></span><br></pre></td></tr></table></figure>
<h4 id="2-容器操作"><a href="#2-容器操作" class="headerlink" title="2.容器操作"></a>2.容器操作</h4><blockquote>
<p>下面的命令可进行简化，去掉中间的container。ctrl+p+q退出容器保持容器运行</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th>操作</th>
<th>命令</th>
</tr>
</thead>
<tbody>
<tr>
<td>拉取镜像创建运行容器</td>
<td><code>docker container run -dit 名称 /bin/bash</code></td>
</tr>
<tr>
<td>查看所有容器</td>
<td><code>docker ps/ls -a</code></td>
</tr>
<tr>
<td>查看正在运行的容器</td>
<td><code>docker ps/ls</code></td>
</tr>
<tr>
<td>启动/重启/停止/强制停止容器</td>
<td><code>docker start/restart/stop/kill 容器ID</code></td>
</tr>
<tr>
<td>删除容器</td>
<td><code>docker rm 容器ID</code></td>
</tr>
<tr>
<td>查找指定名称的容器</td>
<td><code>docker ps --filter &quot;name=gitlab&quot;</code></td>
</tr>
<tr>
<td>列出最近创建的5个容器的信息</td>
<td><code>docker ps -n 5</code></td>
</tr>
<tr>
<td>进入容器打开新终端/正在运行的终端</td>
<td><code>docker exec/attach -it 容器ID</code></td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docke run [命令参数] image</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">参数说明</span></span><br><span class="line">--name 容器名称</span><br><span class="line">-d     后台方式运行</span><br><span class="line">-it    使用交互方式运行</span><br><span class="line">-p     指定容器的端口</span><br><span class="line">-v,--volume=&quot;$PWD:/app&quot;  绑定当前目录到容器的/app下</span><br><span class="line">-e     修改配置</span><br></pre></td></tr></table></figure>
<h4 id="3-常用命令"><a href="#3-常用命令" class="headerlink" title="3.常用命令"></a>3.常用命令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>操作</th>
<th>命令</th>
</tr>
</thead>
<tbody>
<tr>
<td>查看容器日志信息</td>
<td><code>docker -f -t --tail 10 容器ID</code></td>
</tr>
<tr>
<td>查看容器的进程信息</td>
<td><code>docker top 容器ID</code></td>
</tr>
<tr>
<td>查看容器的元数据</td>
<td><code>docker inspect 容器ID</code></td>
</tr>
<tr>
<td>从容器拷贝数据到主系统</td>
<td><code>docker cp 容器ID:路径 主系统路径</code></td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202302052220685.png" alt="查看源图像"></p>
<h3 id="第四节：容器数据卷"><a href="#第四节：容器数据卷" class="headerlink" title="第四节：容器数据卷"></a>第四节：容器数据卷</h3><h4 id="1-容器数据卷概述"><a href="#1-容器数据卷概述" class="headerlink" title="1.容器数据卷概述"></a>1.容器数据卷概述</h4><p>​        当数据存储在容器中时，容器删掉后数据也会跟着删掉，我们希望数据能够存在本地，数据能够在容器中共享。这个就是卷技术，目录的挂载。</p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202302052224472.png" alt="docker数据卷如何挂载 - 大数据 - 亿速云"></p>
<h4 id="2-容器数据卷挂载"><a href="#2-容器数据卷挂载" class="headerlink" title="2.容器数据卷挂载"></a>2.容器数据卷挂载</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">挂载分为具名挂载和匿名挂载</span></span><br><span class="line">-v 容器路径  # 匿名挂载，自动生成一串符号来表示名字</span><br><span class="line">-v 名称：容器路径  # 具名挂载，自己指定名字</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以上两种不指定宿主机的挂载路径，容器自己选择挂载路径</span></span><br><span class="line">docker volume ls  # 查找挂载的容器路径</span><br><span class="line">docker volume inspect 查找到的容器挂载名  # 查看宿主机的挂载路径</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一般来讲是挂载到宿主机的docker/volume路径下</span></span><br><span class="line">-v 宿主机路径：容器路径  # 指定路径挂载</span><br><span class="line">-v 容器路径:ro/rw  # 可以在容器路径后:ro(只读)或者:rw(读写)来指定对路径的权限</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当为只读时，容器不能修改文件内容</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过的dockerfile来进行挂载，简单的使用，建立dockerfile文件，如下</span></span><br><span class="line"></span><br><span class="line">FROM centos  # 用centos作为基础镜像</span><br><span class="line">VOLUME [&quot;volume01&quot;,&quot;volume02&quot;]  # 将指定的两个文件匿名挂载出去</span><br><span class="line">CMD /bin/bash  # 默认启动的为bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以上即为一个简单dockerfile文件，下面执行文件</span></span><br><span class="line">docker build -f `dockerfile的路径` -t `创建的容器名称:版本号` . </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行结束即可得到镜像</span></span><br></pre></td></tr></table></figure>
<h4 id="3-多容器数据同步"><a href="#3-多容器数据同步" class="headerlink" title="3.多容器数据同步"></a>3.多容器数据同步</h4><p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202302052226525.png" alt="img"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用--volume-from来从父容器中继承挂载的信息，实现两个容器的挂载同步</span></span><br><span class="line">docker run -it --volume-from `副容器名称` `镜像id`</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当删除父容器时，其他容器的数据挂载不受影响</span></span><br></pre></td></tr></table></figure>
<h3 id="第五节：dockerfile"><a href="#第五节：dockerfile" class="headerlink" title="第五节：dockerfile"></a>第五节：dockerfile</h3><blockquote>
<p>docker就是使用自制的命令脚本，是用来制作一个镜像构建文件</p>
</blockquote>
<ul>
<li>一般来讲dockerfile的文件夹名称都是Dockerfile，这样在创建时就不需要添加额外的参数，以下是dockerfile的常用的一些指令</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>指令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>FROM</td>
<td>作为基础的镜像</td>
</tr>
<tr>
<td>MAINTAINER</td>
<td>管理镜像的人的信息</td>
</tr>
<tr>
<td>RUN</td>
<td>RUN &lt;命令行命令&gt;，一个RUN添加一层镜像，为了减少镜像冗余，<br>可使用&amp;&amp;运行一系列的指令</td>
</tr>
<tr>
<td>CMD</td>
<td>容器创建后运行的指令，不可追加，仅最后一个有效</td>
</tr>
<tr>
<td>VOLUME</td>
<td>定义数据卷，匿名挂载</td>
</tr>
<tr>
<td>WORKDIR</td>
<td>切换默认的工作路径</td>
</tr>
<tr>
<td>EXPOSE</td>
<td>暴露端口</td>
</tr>
<tr>
<td>ADD</td>
<td>添加文件，如果是压缩文件，自动解压</td>
</tr>
<tr>
<td>COPY</td>
<td>复制文件</td>
</tr>
</tbody>
</table>
</div>
<h4 id="yolov5-Dockerfile-搭建练习"><a href="#yolov5-Dockerfile-搭建练习" class="headerlink" title="yolov5 Dockerfile 搭建练习"></a>yolov5 Dockerfile 搭建练习</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM anibali/pytorch:1.7.0-cuda11.0</span><br><span class="line">COPY requirements.txt .</span><br><span class="line">RUN pip config set global.index-url https://mirrors.aliyun.com/pypi/simple/ &amp;&amp; pip install -r requirements.txt</span><br><span class="line">RUN sudo apt update &amp;&amp; sudo apt install -y libgl1-mesa-glx &amp;&amp; sudo DEBIAN_FRONTEND=&quot;noninteractive&quot; apt install libglib2.0-dev</span><br><span class="line">COPY Arial.ttf home/user/.config/Ultralytics/Arial.ttf</span><br><span class="line">COPY . /app</span><br><span class="line">WORKDIR /app</span><br></pre></td></tr></table></figure>
<h3 id="附录：遇到的问题"><a href="#附录：遇到的问题" class="headerlink" title="附录：遇到的问题"></a>附录：遇到的问题</h3><ul>
<li>ImportError: libGL.so.1: cannot open shared object file: No such file or directory</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install libgl1-mesa-glx</span><br></pre></td></tr></table></figure>
<ul>
<li>ImportError: libgthread-2.0.so.0: cannot open shared object file: No such file or directory</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install libglib2.0-dev</span><br></pre></td></tr></table></figure>
<ul>
<li>dockerfile 运行安装指令时碰到时区选择</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">RUN sudo DEBIAN_FRONTEND=&quot;noninteractive&quot; apt install</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>PDF添加图片与文字</title>
    <url>/link/pdfaddpicture.html</url>
    <content><![CDATA[<h1 id="PDF添加图片与文字"><a href="#PDF添加图片与文字" class="headerlink" title="PDF添加图片与文字"></a>PDF添加图片与文字</h1><blockquote>
<p>由于某些需要，需要在pdf上添加图片和文字，但wps需要收费，囊中羞涩，使用python简单处理一下</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 需要安装用到的库</span></span><br><span class="line"><span class="keyword">import</span> fitz  <span class="comment"># PyMuPDF</span></span><br><span class="line"><span class="keyword">import</span> PyPDF2</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_image_to_pdf</span>(<span class="params">existing_pdf_path, new_pdf_path, image_path, x, y, width, height</span>):</span><br><span class="line">    <span class="comment"># 打开现有的PDF文件</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(existing_pdf_path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> existing_file:</span><br><span class="line">        <span class="comment"># 创建一个PDF写入器</span></span><br><span class="line">        pdf_writer = PyPDF2.PdfWriter()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 创建一个PDF读取器</span></span><br><span class="line">        pdf_reader = PyPDF2.PdfReader(existing_file)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将现有的页面复制到新的PDF中</span></span><br><span class="line">        <span class="keyword">for</span> page_num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(pdf_reader.pages)):</span><br><span class="line">            page = pdf_reader.pages[page_num]</span><br><span class="line">            pdf_writer.add_page(page)</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 创建一个PDF文件对象</span></span><br><span class="line">        new_pdf = <span class="built_in">open</span>(new_pdf_path, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 打开现有的PDF文件</span></span><br><span class="line">        pdf_document = fitz.<span class="built_in">open</span>(existing_pdf_path)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 获取第一页</span></span><br><span class="line">        pdf_page = pdf_document[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 创建一个Pixmap对象</span></span><br><span class="line">        rotate = <span class="built_in">int</span>(<span class="number">90</span>)  <span class="comment"># 设置图片的旋转角度为0</span></span><br><span class="line">        img = Image.<span class="built_in">open</span>(image_path)</span><br><span class="line">        img = img.rotate(rotate, expand=<span class="literal">True</span>) <span class="comment"># 旋转图片</span></span><br><span class="line">        img.save(<span class="string">&quot;test.jpg&quot;</span>)</span><br><span class="line">        pixmap = fitz.Pixmap(<span class="string">&quot;test.jpg&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算右下角坐标</span></span><br><span class="line">        x1 = x + width</span><br><span class="line">        y1 = y + height</span><br><span class="line"></span><br><span class="line">        pdf_page.insert_image((x, y, x1, y1), pixmap=pixmap)</span><br><span class="line">        </span><br><span class="line">        ttf_font_path = <span class="string">&quot;SimHei.ttf&quot;</span>  <span class="comment"># 中文字体文件名</span></span><br><span class="line">        </span><br><span class="line">        pdf_page.insert_font(fontname=<span class="string">&quot;HT&quot;</span>,fontfile=ttf_font_path, fontbuffer=<span class="literal">None</span> , set_simple=<span class="literal">False</span> )</span><br><span class="line">        pdf_page.insert_text((x-<span class="number">13</span>, y+<span class="number">73</span>), <span class="string">&quot;添加文字&quot;</span>,fontname=<span class="string">&quot;HT&quot;</span>,fontsize=<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 保存新的PDF文件</span></span><br><span class="line">        pdf_document.save(new_pdf)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 关闭文件</span></span><br><span class="line">        new_pdf.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例用法</span></span><br><span class="line">existing_pdf_path = <span class="string">&quot;test.pdf&quot;</span></span><br><span class="line">image_path = <span class="string">&quot;picture.jpg&quot;</span></span><br><span class="line">new_pdf_path = <span class="string">&quot;output.pdf&quot;</span>  <span class="comment"># 新的PDF文件路径</span></span><br><span class="line"></span><br><span class="line">x_position = <span class="number">450</span>  <span class="comment"># X坐标偏移量</span></span><br><span class="line">y_position = <span class="number">700</span>  <span class="comment"># Y坐标偏移量/</span></span><br><span class="line">image_width = <span class="number">60</span>  <span class="comment"># 图片宽度</span></span><br><span class="line">image_height = <span class="number">60</span>  <span class="comment"># 图片高度</span></span><br><span class="line"></span><br><span class="line">add_image_to_pdf(existing_pdf_path, new_pdf_path, image_path, x_position, y_position, image_width, image_height)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>办公</tag>
      </tags>
  </entry>
  <entry>
    <title>堆与优先队列</title>
    <url>/link/topset.html</url>
    <content><![CDATA[<blockquote>
<p>题目来源：<a href="https://leetcode.cn/problems/binary-search">力扣（LeetCode）</a></p>
</blockquote>
<h1 id="堆与优先队列"><a href="#堆与优先队列" class="headerlink" title="堆与优先队列"></a>堆与优先队列</h1>]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++算法</tag>
      </tags>
  </entry>
  <entry>
    <title>代码随想录(day20)</title>
    <url>/link/suixiangluday20.html</url>
    <content><![CDATA[<blockquote>
<p>刷题参考：<a href="https://www.programmercarl.com/">代码随想录 (programmercarl.com)</a></p>
<p>题目来源：<a href="https://leetcode.cn/problems/binary-search">力扣（LeetCode）</a></p>
</blockquote>
<h1 id="Day-20：图论（二）"><a href="#Day-20：图论（二）" class="headerlink" title="Day 20：图论（二）"></a>Day 20：图论（二）</h1>]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++算法</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法n方</title>
    <url>/link/paixun2.html</url>
    <content><![CDATA[<h1 id="排序算法-n-2"><a href="#排序算法-n-2" class="headerlink" title="排序算法$n^2$"></a>排序算法$n^2$</h1>]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++算法</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法nlogn</title>
    <url>/link/paixunlogn.html</url>
    <content><![CDATA[<h1 id="排序算法-nlogn"><a href="#排序算法-nlogn" class="headerlink" title="排序算法$nlogn$"></a>排序算法$nlogn$</h1>]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++算法</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法n</title>
    <url>/link/paixun.html</url>
    <content><![CDATA[<h1 id="排序算法n"><a href="#排序算法n" class="headerlink" title="排序算法n"></a>排序算法n</h1>]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++算法</tag>
      </tags>
  </entry>
  <entry>
    <title>查找算法</title>
    <url>/link/chazhao.html</url>
    <content><![CDATA[<h1 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h1>]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++算法</tag>
      </tags>
  </entry>
  <entry>
    <title>平衡树</title>
    <url>/link/avltree.html</url>
    <content><![CDATA[<h1 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h1>]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++算法</tag>
      </tags>
  </entry>
  <entry>
    <title>ACM输入</title>
    <url>/link/acminput.html</url>
    <content><![CDATA[<h1 id="ACM输入"><a href="#ACM输入" class="headerlink" title="ACM输入"></a>ACM输入</h1>]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++算法</tag>
      </tags>
  </entry>
  <entry>
    <title>代码随想录(day19)</title>
    <url>/link/suixiangluday19.html</url>
    <content><![CDATA[<blockquote>
<p>刷题参考：<a href="https://www.programmercarl.com/">代码随想录 (programmercarl.com)</a></p>
<p>题目来源：<a href="https://leetcode.cn/problems/binary-search">力扣（LeetCode）</a></p>
</blockquote>
<h1 id="Day-19：图论（一）"><a href="#Day-19：图论（一）" class="headerlink" title="Day 19：图论（一）"></a>Day 19：图论（一）</h1>]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++算法</tag>
      </tags>
  </entry>
  <entry>
    <title>代码随想录(day18)</title>
    <url>/link/suixiangluday18.html</url>
    <content><![CDATA[<blockquote>
<p>刷题参考：<a href="https://www.programmercarl.com/">代码随想录 (programmercarl.com)</a></p>
<p>题目来源：<a href="https://leetcode.cn/problems/binary-search">力扣（LeetCode）</a></p>
</blockquote>
<h1 id="Day-18：单调栈"><a href="#Day-18：单调栈" class="headerlink" title="Day 18：单调栈"></a>Day 18：单调栈</h1>]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++算法</tag>
      </tags>
  </entry>
  <entry>
    <title>训练网络笔记</title>
    <url>/link/e89475e6.html</url>
    <content><![CDATA[<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ul>
<li>当前问题是否可以使用深度神经网络解决，比如针对一些表格数据，随机森林的表现普遍优于深度神经网络</li>
<li>是否有人已经研究，在别人的基础上进行研究会更简单，而且能够避免研究了半天，还不如别人好的情况</li>
<li>数据集的准备，是否有现成的数据集，一个现成的数据集能够省去很多麻烦，如果没有现成的数据集，需要自己创建数据集，需要考虑数据的质量是否达标</li>
<li>是否有现成的指标，如果没有则需要选择合适的指标对数据集进行评估</li>
<li>建立一个简单但完整的训练评估框架，首先选择简单的模型，比如全连接层，cnn，对损失进行可视化，并且获得准确度等衡量模型的标准，完成模型的训练和测试流程</li>
</ul>
<h1 id="训练技巧"><a href="#训练技巧" class="headerlink" title="训练技巧"></a>训练技巧</h1><ul>
<li>固定随机种子，保证可复用性</li>
<li>小网络+小数据集，先确保代码没有bug</li>
<li>可以先只训练一张或几张图片，观察能否正常过拟合</li>
<li>将所有数据输入设置为0，观察是否有不同的输出，如果有，证明能提取到信息</li>
<li>一般初始化和归一化不会有太大影响，因为现在框架和算法都比较成熟，自己写的算法需要注意</li>
<li>常用的配置：优化器 adamw ；学习率 3e-4；学习率曲线 cosine；激活函数 prelu；batchsize 64；distributeddataparallel；BN层 有时好用，有时不好用；warm up；grad clip；半精度训练</li>
<li>sgd+momentum往往能获得更好的解，但需要花时间调lr和init weights</li>
<li>将某一样本的损失设置为0，运用反向传播，可以观察依赖</li>
<li>数据增强，旋转，翻转，mixup，马赛克等，最好进行可视化，观察是否满足预期，可用一些有创意的数据增广方法，比如Domain Randomization，Simulation，Hybrids，GAN等</li>
<li>当场景不需要太多细节时，可以降低输入的维度，减少干扰</li>
<li>每次优化只改变一处</li>
<li>回归一些平均值为50的值，最后一层bias可以设置为50，分类比例为1:10的不平衡数据，设置bias使网络开始的预测概率为1:10，能够加速收敛</li>
<li>小batchsize可能能带来更好的正则化，大的batchsize收敛的精度会更高，单batch的噪声更小，可以使用更大的学习率</li>
<li>dropout，droppath，drop decay</li>
<li>weight decay，标签平滑</li>
<li>zero $\gamma$ : resnet中残差结构的block部分最后一层BN层通常参数设置为1,0，改为全部初始化为0</li>
<li>no bias decay：只对卷积和全连接层中的weight参数进行正则化，不对bias参数进行正则化</li>
<li>超参数随机网格搜索</li>
<li>模型集成</li>
<li>知识蒸馏，量化剪枝</li>
<li>难例挖掘</li>
<li>差分学习率</li>
<li>余弦退火，热启动</li>
<li>激活函数低复杂度一般使用hard_swish有更好的效果，高复杂度模型更多使用relu</li>
<li>网络模块的修改：小卷积替代大卷积核，大卷积strid保证不丢失细节的情况下增加正则化，大卷积核降维改为1*1通道卷积+平均池化降维</li>
<li>常用的一些模块：se模块，ghost模块等</li>
</ul>
]]></content>
      <categories>
        <category>网络优化</category>
      </categories>
      <tags>
        <tag>调参</tag>
      </tags>
  </entry>
  <entry>
    <title>手势识别分类总结</title>
    <url>/link/kaggle0502.html</url>
    <content><![CDATA[<h1 id="手势识别分类总结"><a href="#手势识别分类总结" class="headerlink" title="手势识别分类总结"></a><a href="https://www.kaggle.com/competitions/asl-signs/overview">手势识别分类总结</a></h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202306291115138.png" alt="image-20230629111531383"></p>
<p>​        第二次参加kaggle比赛，中间生病，参加时间较短，最后成绩为铜牌。公榜76，私榜78。</p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202306291136458.png" alt="image-20230629113602476"></p>
<p>​        参加这个比赛主要是因为他是一个最终提交部署模型TF Lite的任务，当然他不是个视觉的任务，这点和开始想的不一样，得到的数据是关键点坐标的形式，直接对数据进行处理，这些数据来自于不同手语者录制的视频通过MediaPipe直接生成的坐标点。</p>
<p>​        技术基础上的难题有以下几点：</p>
<ul>
<li>不是很熟悉tensorflow框架，生成tensorflow lite模型需要从pytorch-&gt;onnx-&gt;tensorflow-&gt;tensorflow lite</li>
<li>对数据类型的数据处理经验较少，题目对模型的大小和速度有要求</li>
</ul>
<p>​    接下来的部分，从数据集EDA分析，基本模型的选择，框架转换，数据增强，模型改进几个方面分别总结</p>
<h2 id="数据集EDA分析"><a href="#数据集EDA分析" class="headerlink" title="数据集EDA分析"></a>数据集EDA分析</h2><p>​        首先需要对数据进行分析，主要分析以下内容：数据的坐标点含义，数据坐标的丢失情况，贡献者id分布，相同类别下的对比，手势的可视化。</p>
<p>​        通过分析可以得到很多有用的信息，比如说：</p>
<ul>
<li>534个坐标对应的左右各21个双手坐标，33个姿态坐标以及468个面部坐标</li>
<li>虽然要求单手拍摄，但是存在双手都在的情况，需要进一步分析</li>
<li>不同的贡献者可能对一个手语有着不同的展示</li>
</ul>
<p>​        进行初步的数据分析后，开始选择模型，之后在数据增强时，也会不断对数据进行分析。</p>
<h2 id="基本模型的选择"><a href="#基本模型的选择" class="headerlink" title="基本模型的选择"></a>基本模型的选择</h2><p>​        由于之前做的内容大多是图像相关的内容，这里的选择参考了讨论区大佬的讨论后，最终确定了两个方案，一个是全连接，另外一个是自注意力模型。</p>
<p>​        这里需要对数据进行归一化处理，以及挑选出与手势有关的特征，由于是刚开始，直接就选择了双手和姿势的所有点，使用毫无技巧，全是感情的三层全连接达到0.616的精度，选择自注意力模型能够达到0.67的精度，自注意力模型也能有更好的改进空间，最终确定为自注意力模型。</p>
<p>​        以下是所使用的的模型，x_mask是因为长度不一致对多头注意力模块进行通道的选通。</p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202306291230790.png" alt="image-20230629123001198"></p>
<h2 id="框架的转换"><a href="#框架的转换" class="headerlink" title="框架的转换"></a>框架的转换</h2><p>​        由于使用的操作都是一些基础的网络操作，没有太多的版本兼容性问题，步骤如下：</p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202306291237563.png" alt="image-20230629123710757"></p>
<p>为了减小模型的大小又不损失精度，使用了单精度的模型，以下是转换使用的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#https://www.kaggle.com/code/dschettler8845/gislr-how-to-ensemble/notebook</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InputNet</span>(tf.keras.layers.Layer):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, </span>):</span><br><span class="line">        <span class="built_in">super</span>(InputNet, self).__init__()</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">call</span>(<span class="params">self, xyz</span>):</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span>  x</span><br><span class="line"></span><br><span class="line"><span class="comment">#https://stackoverflow.com/questions/59142040/tensorflow-2-0-how-to-change-the-output-signature-while-using-tf-saved-model</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TFModel</span>(tf.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,</span>):</span><br><span class="line">        <span class="built_in">super</span>(TFModel, self).__init__()</span><br><span class="line">        self.input_net = InputNet()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @tf.function(<span class="params">input_signature=[tf.TensorSpec(<span class="params">shape=[<span class="literal">None</span>, <span class="number">543</span>, <span class="number">3</span>], dtype=tf.float32, name=<span class="string">&#x27;inputs&#x27;</span></span>)]</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, inputs</span>):</span><br><span class="line">        outputs = self.input_net(inputs)</span><br><span class="line">        <span class="keyword">return</span> outputs</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_convert_input_net_tf</span>(<span class="params">input_net_k_tf_file</span>):</span><br><span class="line">    tf_model = TFModel()</span><br><span class="line">    tf.saved_model.save(tf_model, input_net_k_tf_file, signatures=&#123;</span><br><span class="line">        <span class="string">&#x27;serving_default&#x27;</span>: tf_model.__call__,&#125;) <span class="comment">#name=&#x27;inputs&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_check_input_net</span>():</span><br><span class="line">    input_net = InputNet()</span><br><span class="line">    xyz =np.random.rand(<span class="number">512</span>,<span class="number">543</span>,<span class="number">3</span>)</span><br><span class="line">    x=input_net(xyz)</span><br><span class="line">    <span class="built_in">print</span>(x.shape)</span><br><span class="line"></span><br><span class="line">run_check_input_net()</span><br><span class="line">run_convert_input_net_tf(input_net_k_tf_file)</span><br><span class="line"></span><br><span class="line"><span class="comment">#pytorch to onnx to tflite</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_convert_onnx</span>(<span class="params">single_net,single_onnx_file,fold</span>): </span><br><span class="line">    <span class="keyword">if</span> <span class="number">1</span>:</span><br><span class="line">        torch.onnx.export(</span><br><span class="line">            single_net,         </span><br><span class="line">            <span class="comment">#torch.jit.script(single_net),</span></span><br><span class="line">            <span class="comment">#torch.jit.trace(single_net, torch.zeros(max_length,82,3)),           </span></span><br><span class="line"></span><br><span class="line">            torch.zeros((max_length,point_dim)).cuda(), </span><br><span class="line">            single_onnx_file+<span class="built_in">str</span>(fold),             </span><br><span class="line">            export_params = <span class="literal">True</span>,         </span><br><span class="line">            opset_version = <span class="number">12</span>, </span><br><span class="line">            do_constant_folding=<span class="literal">True</span>,      </span><br><span class="line">            input_names =  [<span class="string">&#x27;inputs&#x27;</span>],     </span><br><span class="line">            output_names = [<span class="string">&#x27;outputs&#x27;</span>],  </span><br><span class="line">            dynamic_axes=&#123;</span><br><span class="line">                <span class="string">&#x27;inputs&#x27;</span>: &#123;<span class="number">0</span>: <span class="string">&#x27;length&#x27;</span>&#125;,</span><br><span class="line">                <span class="comment"># &#x27;output&#x27;: &#123;0: &#x27;length&#x27;&#125;,</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">#verbose = True,</span></span><br><span class="line">        )</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;torch.onnx.export() passed !!&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    model = onnx.load(single_onnx_file+<span class="built_in">str</span>(fold))</span><br><span class="line">    onnx.checker.check_model(model)</span><br><span class="line">    model_simple, check = onnxsim.simplify(model)</span><br><span class="line">    onnx.save(model_simple, single_onnx_file+<span class="built_in">str</span>(fold))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;onnx simplify() passed !!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_convert_tflite</span>(<span class="params">tf_file</span>):</span><br><span class="line">    <span class="keyword">for</span> fold <span class="keyword">in</span> <span class="built_in">range</span>(FOLD):</span><br><span class="line">        tf_rep = prepare(onnx.load(single_onnx_file+<span class="built_in">str</span>(fold)))</span><br><span class="line">        tf_rep.export_graph(single_tf_file+<span class="built_in">str</span>(fold)) </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;tf_rep.export_graph() passed !!&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">TFModel</span>(tf.Module):</span><br><span class="line">            <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">                <span class="built_in">super</span>(TFModel, self).__init__()</span><br><span class="line">                self.<span class="built_in">input</span>  = tf.saved_model.load(input_net_k_tf_file)</span><br><span class="line">                self.single0 = tf.saved_model.load(single_tf_file+<span class="built_in">str</span>(<span class="number">0</span>))</span><br><span class="line">                self.<span class="built_in">input</span>.trainable = <span class="literal">False</span></span><br><span class="line">                self.single0.trainable = <span class="literal">False</span></span><br><span class="line">			   ...</span><br><span class="line"></span><br><span class="line"><span class="meta">            @tf.function(<span class="params">input_signature=[</span></span></span><br><span class="line"><span class="params"><span class="meta">                tf.TensorSpec(<span class="params">shape=[<span class="literal">None</span>, <span class="number">543</span>, <span class="number">3</span>], dtype=tf.float32, name=<span class="string">&#x27;inputs&#x27;</span></span>)</span></span></span><br><span class="line"><span class="params"><span class="meta">            ]</span>)</span></span><br><span class="line">            <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, inputs</span>):</span><br><span class="line">                <span class="comment">#x = self.input_net(**&#123;&#x27;inputs&#x27;: inputs&#125;)[&#x27;outputs&#x27;]</span></span><br><span class="line">                x  = self.<span class="built_in">input</span>(inputs)</span><br><span class="line">                y0 = self.single0(inputs=x)[<span class="string">&#x27;outputs&#x27;</span>]  <span class="comment">#messy here &lt;todo&gt; how not to return dict</span></span><br><span class="line">                ...</span><br><span class="line">                outputs = (y0 + y1 + y2 + y3 + y4)/FOLD</span><br><span class="line">                <span class="keyword">return</span> &#123;<span class="string">&#x27;outputs&#x27;</span>: outputs &#125;</span><br><span class="line"></span><br><span class="line">        tfmodel = TFModel()</span><br><span class="line">        tf.saved_model.save(tfmodel, tf_file, signatures=&#123;<span class="string">&#x27;serving_default&#x27;</span>: tfmodel.__call__&#125;)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;tf.saved_model() passed !!&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="number">1</span>:</span><br><span class="line">        converter = tf.lite.TFLiteConverter.from_saved_model(tf_file)</span><br><span class="line">        converter.optimizations = [tf.lite.Optimize.DEFAULT]</span><br><span class="line">        converter.target_spec.supported_types = [tf.float16]</span><br><span class="line">        tf_lite_model = converter.convert()</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(tflite_file, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(tf_lite_model)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;tflite convert() passed !!&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> fold <span class="keyword">in</span> <span class="built_in">range</span>(FOLD):</span><br><span class="line">    pth_path = savepath+<span class="string">&quot;model-f&quot;</span>+<span class="built_in">str</span>(fold)+<span class="string">&quot;_best.pth&quot;</span></span><br><span class="line">    single_net = SingleNet()</span><br><span class="line">    state_dict = torch.load(pth_path)</span><br><span class="line">    single_net.load_state_dict(state_dict[<span class="string">&quot;net&quot;</span>])</span><br><span class="line">    single_net = single_net.cuda()</span><br><span class="line">    run_convert_onnx(single_net,single_onnx_file,fold)</span><br><span class="line">run_convert_tflite(tf_file)</span><br></pre></td></tr></table></figure>
<h2 id="数据增强-amp-模型改进"><a href="#数据增强-amp-模型改进" class="headerlink" title="数据增强&amp;模型改进"></a>数据增强&amp;模型改进</h2><p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202306291305998.png" alt="image-20230629130524762"></p>
<ul>
<li>对称坐标点可以使用一半的坐标代替</li>
<li>使用图像的resize功能能够对序列进行缩放，但缩放不均匀</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然最后的成绩不是很好，但是学到了很多，不同框架下的模型转换，多头注意力的使用，非图像数据的处理。</p>
]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>kaggle比赛</tag>
      </tags>
  </entry>
  <entry>
    <title>代码随想录(day17)</title>
    <url>/link/suixiangluday17.html</url>
    <content><![CDATA[<blockquote>
<p>刷题参考：<a href="https://www.programmercarl.com/">代码随想录 (programmercarl.com)</a></p>
<p>题目来源：<a href="https://leetcode.cn/problems/binary-search">力扣（LeetCode）</a></p>
</blockquote>
<h1 id="Day-17：动态规划（五）"><a href="#Day-17：动态规划（五）" class="headerlink" title="Day 17：动态规划（五）"></a>Day 17：动态规划（五）</h1><h2 id="392-判断子序列"><a href="#392-判断子序列" class="headerlink" title="392. 判断子序列"></a><a href="https://leetcode.cn/problems/is-subsequence/">392. 判断子序列</a></h2><blockquote>
<p>给定字符串 <strong>s</strong> 和 <strong>t</strong> ，判断 <strong>s</strong> 是否为 <strong>t</strong> 的子序列。</p>
<p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，<code>&quot;ace&quot;</code>是<code>&quot;abcde&quot;</code>的一个子序列，而<code>&quot;aec&quot;</code>不是）。</p>
<p><strong>进阶：</strong></p>
<p>如果有大量输入的 S，称作 S1, S2, … , Sk 其中 k &gt;= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？</p>
<p><strong>致谢：</strong></p>
<p>特别感谢 <a href="https://leetcode.com/pbrother/">@pbrother </a>添加此问题并且创建所有测试用例。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;abc&quot;, t = &quot;ahbgdc&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;axc&quot;, t = &quot;ahbgdc&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= s.length &lt;= 100</code></li>
<li>$0 &lt;= t.length &lt;= 10^4$</li>
<li>两个字符串都只由小写字符组成。</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双指针法</span></span><br><span class="line"><span class="comment">// 一个指针指向一个数组，s字符串里的值必须全部在t字符串内且顺序相同</span></span><br><span class="line"><span class="comment">// 当两个字符串中元素相同时同时+1，假如不同则t数组先完成，假如相同则s数组完成</span></span><br><span class="line"><span class="comment">// 最后判断s的index是否为s.size()即可</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubsequence</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;s.<span class="built_in">size</span>()&amp;&amp;right&lt;t.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">while</span>(right&lt;t.<span class="built_in">size</span>()&amp;&amp;s[left]!=t[right]) right++;</span><br><span class="line">            <span class="keyword">if</span>(s[left]==t[right])&#123;</span><br><span class="line">                left++;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left==s.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 两个序列判断子序列，先建一个dp数组</span></span><br><span class="line"><span class="comment">// 当s[i]==t[j] dp[i][j] = dp[i-1][j-1]</span></span><br><span class="line"><span class="comment">// 这样dp[0]初始化应该为true</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubsequence</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">		vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>()+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(t.<span class="built_in">size</span>()+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=t.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=t.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i<span class="number">-1</span>]==t[j<span class="number">-1</span>]) dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = dp[i][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.<span class="built_in">size</span>()][t.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="115-不同的子序列"><a href="#115-不同的子序列" class="headerlink" title="115. 不同的子序列"></a><a href="https://leetcode.cn/problems/distinct-subsequences/">115. 不同的子序列</a></h2><blockquote>
<p>给你两个字符串 <code>s</code> 和 <code>t</code> ，统计并返回在 <code>s</code> 的 <strong>子序列</strong> 中 <code>t</code> 出现的个数。</p>
<p>题目数据保证答案符合 32 位带符号整数范围。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;rabbbit&quot;, t = &quot;rabbit&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">有 3 种可以从 s 中得到 &quot;rabbit&quot; 的方案。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;babgbag&quot;, t = &quot;bag&quot;</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line">有 5 种可以从 s 中得到 &quot;bag&quot; 的方案。 </span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length, t.length &lt;= 1000</code></li>
<li><code>s</code> 和 <code>t</code> 由英文字母组成</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里使用双指针的话需要使用回溯，以每个元素作为起点去进行判断</span></span><br><span class="line"><span class="comment">// 使用动态规划会更直观一些</span></span><br><span class="line"><span class="comment">// 首先确定dp数组是一个[i][j]的int数组，代表个数</span></span><br><span class="line"><span class="comment">// 画表格确定递推关系</span></span><br><span class="line"><span class="comment">// s[i]==s[j] dp[i][j] = dp[i][j-1]+dp[i-1][j-1]</span></span><br><span class="line"><span class="comment">// s[i] != s[j] dp[i][j] = dp[i][j-1]</span></span><br><span class="line"><span class="comment">// int类型有例子过不了，换成unsigned long long</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numDistinct</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">		vector&lt;vector&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">dp</span>(t.<span class="built_in">size</span>()+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt;(s.<span class="built_in">size</span>()+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=s.<span class="built_in">size</span>();i++) dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=s.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(t[i<span class="number">-1</span>]==s[j<span class="number">-1</span>]) dp[i][j] = dp[i][j<span class="number">-1</span>]+dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = dp[i][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[t.<span class="built_in">size</span>()][s.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="583-两个字符串的删除操作"><a href="#583-两个字符串的删除操作" class="headerlink" title="583. 两个字符串的删除操作"></a><a href="https://leetcode.cn/problems/delete-operation-for-two-strings/">583. 两个字符串的删除操作</a></h2><blockquote>
<p>给定两个单词 <code>word1</code> 和 <code>word2</code> ，返回使得 <code>word1</code> 和 <code>word2</code> <strong>相同</strong>所需的<strong>最小步数</strong>。</p>
<p><strong>每步</strong> 可以删除任意一个字符串中的一个字符。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: word1 = &quot;sea&quot;, word2 = &quot;eat&quot;</span><br><span class="line">输出: 2</span><br><span class="line">解释: 第一步将 &quot;sea&quot; 变为 &quot;ea&quot; ，第二步将 &quot;eat &quot;变为 &quot;ea&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例  2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：word1 = &quot;leetcode&quot;, word2 = &quot;etco&quot;</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= word1.length, word2.length &lt;= 500</code></li>
<li><code>word1</code> 和 <code>word2</code> 只包含小写英文字母</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 稍微思考一下发现，这个就是求最长相等的子序列，然后两个序列长度相加-二倍的最长子序列长度就行了</span></span><br><span class="line"><span class="comment">// 求最长子序列，不是连续的，使用递归，和前面的最长子序列题一样</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">		vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(word2.<span class="built_in">size</span>()+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(word1.<span class="built_in">size</span>()+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=word2.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=word1.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(word2[i<span class="number">-1</span>]==word1[j<span class="number">-1</span>]) dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> word2.<span class="built_in">size</span>()+word1.<span class="built_in">size</span>()<span class="number">-2</span>*dp[word2.<span class="built_in">size</span>()][word1.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 使用动态规划直接求解</span></span><br><span class="line"><span class="comment">// 首先是初始化，当一个为空时，另一个想要删除得到必须是字符串的长度</span></span><br><span class="line"><span class="comment">// 然后当两个字符相等时，dp[i][j] = dp[i-1][j-1]</span></span><br><span class="line"><span class="comment">// 不等时，可以删除字符串1，也可以删除字符串2，操作都是1次</span></span><br><span class="line"><span class="comment">// 要求最小的值，所以有dp[i][j] = min(dp[i-1][j]+1,dp[i][j-1]+1)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">		vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(word2.<span class="built_in">size</span>()+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(word1.<span class="built_in">size</span>()+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=word1.<span class="built_in">size</span>();i++) dp[<span class="number">0</span>][i] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=word2.<span class="built_in">size</span>();i++) dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=word2.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=word1.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(word2[i<span class="number">-1</span>]==word1[j<span class="number">-1</span>]) dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j]+<span class="number">1</span>,dp[i][j<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[word2.<span class="built_in">size</span>()][word1.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a><a href="https://leetcode.cn/problems/edit-distance/">72. 编辑距离</a></h2><blockquote>
<p>给你两个单词 <code>word1</code> 和 <code>word2</code>， <em>请返回将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数</em> 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">horse -&gt; rorse (将 &#x27;h&#x27; 替换为 &#x27;r&#x27;)</span><br><span class="line">rorse -&gt; rose (删除 &#x27;r&#x27;)</span><br><span class="line">rose -&gt; ros (删除 &#x27;e&#x27;)</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：word1 = &quot;intention&quot;, word2 = &quot;execution&quot;</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line">intention -&gt; inention (删除 &#x27;t&#x27;)</span><br><span class="line">inention -&gt; enention (将 &#x27;i&#x27; 替换为 &#x27;e&#x27;)</span><br><span class="line">enention -&gt; exention (将 &#x27;n&#x27; 替换为 &#x27;x&#x27;)</span><br><span class="line">exention -&gt; exection (将 &#x27;n&#x27; 替换为 &#x27;c&#x27;)</span><br><span class="line">exection -&gt; execution (插入 &#x27;u&#x27;)</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= word1.length, word2.length &lt;= 500</code></li>
<li><code>word1</code> 和 <code>word2</code> 由小写英文字母组成</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这道题与上题相似度很高，但是出现了增加和替换操作</span></span><br><span class="line"><span class="comment">// 只需要改变不等情况下的递推关系式</span></span><br><span class="line"><span class="comment">// 增加操作其实是删除的逆操作，与删除等价</span></span><br><span class="line"><span class="comment">// 也就是说使用删除和使用增加，最后实现的所需的步骤是一样的</span></span><br><span class="line"><span class="comment">// 混用实现的步骤也是相同的，只有替换是不一样的操作</span></span><br><span class="line"><span class="comment">// 替换其实是在前一个字符串的基础上只需要修改一位得到的</span></span><br><span class="line"><span class="comment">// 因此有dp[i-1][j-1]+1，新的递推关系也就出来了</span></span><br><span class="line"><span class="comment">// dp[i][j] = min(min(dp[i-1][j]+1,dp[i][j-1]+1),dp[i-1][j-1]+1)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(word2.<span class="built_in">size</span>()+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(word1.<span class="built_in">size</span>()+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=word1.<span class="built_in">size</span>();i++) dp[<span class="number">0</span>][i] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=word2.<span class="built_in">size</span>();i++) dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=word2.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=word1.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(word2[i<span class="number">-1</span>]==word1[j<span class="number">-1</span>]) dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = <span class="built_in">min</span>(<span class="built_in">min</span>(dp[i<span class="number">-1</span>][j]+<span class="number">1</span>,dp[i][j<span class="number">-1</span>]+<span class="number">1</span>),dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[word2.<span class="built_in">size</span>()][word1.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647. 回文子串"></a><a href="https://leetcode.cn/problems/palindromic-substrings/">647. 回文子串</a></h2><blockquote>
<p>给你一个字符串 <code>s</code> ，请你统计并返回这个字符串中 <strong>回文子串</strong> 的数目。</p>
<p><strong>回文字符串</strong> 是正着读和倒过来读一样的字符串。</p>
<p><strong>子字符串</strong> 是字符串中的由连续字符组成的一个序列。</p>
<p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;aaa&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s</code> 由小写英文字母组成</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 回文子串的个数，首先想到的是，将其分割成每个小部分，然后计算回文子串个数</span></span><br><span class="line"><span class="comment">// 这里需要注意的点是使用双指针判断回文子串，需要考虑子串的长度为奇数或者偶数</span></span><br><span class="line"><span class="comment">// 设置两个变量，判断分别在奇数和偶数情况下是否相等，如果不等，后续就没有继续的必要</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> res=<span class="number">0</span>,flag0=<span class="number">0</span>,flag1=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            flag0=<span class="number">1</span>;flag1=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">0</span>;len&lt;=i;len++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(flag0&amp;&amp;s[i+len]==s[i-len]) res++;</span><br><span class="line">                <span class="keyword">else</span> flag0=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(flag1&amp;&amp;s[i+<span class="number">1</span>+len]==s[i-len]) res++;</span><br><span class="line">                <span class="keyword">else</span> flag1=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(flag0==<span class="number">0</span>&amp;&amp;flag1==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 如果之前没做过类似题目比较难想递推关系，甚至dp数组该怎么写都不清楚</span></span><br><span class="line"><span class="comment">// dp[i][j]代表以i为开始j为结尾的回文子串是否为回文</span></span><br><span class="line"><span class="comment">// 可以得到推导关系当是s[i]==s[j]  dp[i][j] = dp[i+1][j-1]</span></span><br><span class="line"><span class="comment">// 其余的都为0</span></span><br><span class="line"><span class="comment">// 确定递推顺序为从下往上，从左往右</span></span><br><span class="line"><span class="comment">// 初始化元素全部初始化为1，因为用到后面的值</span></span><br><span class="line"><span class="comment">// 用res记录个数，最后得到的是dp数组其实只遍历了上半三角的部分</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">		vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>(),<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(s.<span class="built_in">size</span>(),<span class="number">1</span>));</span><br><span class="line">        <span class="type">int</span> res = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=s.<span class="built_in">size</span>()<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;s.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==s[j]&amp;&amp;dp[i+<span class="number">1</span>][j<span class="number">-1</span>])&#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    res ++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a href="https://leetcode.cn/problems/longest-palindromic-substring/">5. 最长回文子串</a></h2><blockquote>
<p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p>
<p>如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;babad&quot;</span><br><span class="line">输出：&quot;bab&quot;</span><br><span class="line">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;cbbd&quot;</span><br><span class="line">输出：&quot;bb&quot;</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s</code> 仅由数字和英文字母组成</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 与上道题不同的地方在于需要最后的最长子串</span></span><br><span class="line"><span class="comment">// 首先需要知道哪里得到最大的子串，并记录下来，是上道题的延伸</span></span><br><span class="line"><span class="comment">// 修改后的代码如下</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> flag0=<span class="number">0</span>,flag1=<span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">2</span>,<span class="number">0</span>)</span></span>; <span class="comment">// 初始化数组保存结构，res=&#123;初始位置，回文子串长度&#125;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            flag0=<span class="number">1</span>;flag1=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">0</span>;len&lt;=i;len++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(flag0&amp;&amp;s[i+len]==s[i-len])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(len*<span class="number">2</span>+<span class="number">1</span>&gt;res[<span class="number">1</span>])&#123;</span><br><span class="line">                        res[<span class="number">1</span>] = len*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">                        res[<span class="number">0</span>] = i-len;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">else</span> flag0=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(flag1&amp;&amp;s[i+<span class="number">1</span>+len]==s[i-len])&#123;</span><br><span class="line">                    <span class="keyword">if</span>((len+<span class="number">1</span>)*<span class="number">2</span>&gt;res[<span class="number">1</span>])&#123;</span><br><span class="line">                        res[<span class="number">1</span>] = (len+<span class="number">1</span>)*<span class="number">2</span>;</span><br><span class="line">                        res[<span class="number">0</span>] = i-len;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> flag1=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(flag0==<span class="number">0</span>&amp;&amp;flag1==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(res[<span class="number">0</span>],res[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 根据上题的动态回归关系，可以修改res的输出，使用res数组记录长度以及起始位置，</span></span><br><span class="line"><span class="comment">// 按照上题的思路，长度为j-i+1,初始位置为i</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>(),<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(s.<span class="built_in">size</span>(),<span class="number">1</span>));</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res = &#123;<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=s.<span class="built_in">size</span>()<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;s.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==s[j]&amp;&amp;dp[i+<span class="number">1</span>][j<span class="number">-1</span>])&#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span>(res[<span class="number">0</span>]&lt;j-i+<span class="number">1</span>)&#123;</span><br><span class="line">                        res[<span class="number">0</span>] = j-i+<span class="number">1</span>;</span><br><span class="line">                        res[<span class="number">1</span>] = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(res[<span class="number">1</span>],res[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516. 最长回文子序列"></a><a href="https://leetcode.cn/problems/longest-palindromic-subsequence/">516. 最长回文子序列</a></h2><blockquote>
<p>给你一个字符串 <code>s</code> ，找出其中最长的回文子序列，并返回该序列的长度。</p>
<p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;bbbab&quot;</span><br><span class="line">输出：4</span><br><span class="line">解释：一个可能的最长回文子序列为 &quot;bbbb&quot; 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;cbbd&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：一个可能的最长回文子序列为 &quot;bb&quot; 。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s</code> 仅由小写英文字母组成</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相当于正序和范反序的数组求最大公共子序列的长度</span></span><br><span class="line"><span class="comment">// 注意反序时dp数组和s字符串的序号</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">		vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>()+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(s.<span class="built_in">size</span>()+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=s.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i<span class="number">-1</span>]==s[s.<span class="built_in">size</span>()-j]) dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.<span class="built_in">size</span>()][s.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// dp[i][j]代表以i为开始j为结尾的回文子串的数目</span></span><br><span class="line"><span class="comment">// 可以得到推导关系dp[i][j] = dp[i+1][j-1]+2</span></span><br><span class="line"><span class="comment">// dp[i][j] = max(dp[i][j-1],dp[i+1][j])</span></span><br><span class="line"><span class="comment">// 确定递推顺序为从下往上，从左往右</span></span><br><span class="line"><span class="comment">// 初始化为对角线元素全部初始化为1</span></span><br><span class="line"><span class="comment">// 最后的结果为dp[0][s.size()]</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">		vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>(),<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(s.<span class="built_in">size</span>()));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++) dp[i][i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=s.<span class="built_in">size</span>()<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;s.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==s[j]) dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>]+<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j]=<span class="built_in">max</span>(dp[i+<span class="number">1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][s.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>代码随想录的动态规划章节结束，这部分有判断子序列，如果是连续的可以使用双指针去做，非连续的还是动态规划更好理解，删除操作和编辑距离这一块，主要还是对于题目的抽象，如何将题目中给的信息转换为正确的推导公式，并且不遗漏是关键。回文子串的几个题中，子串都可以用双指针去解，但需要注意一些边界条件，可能很难一次就ac，需要调试，使用动态规划，与之前不同的是回文子串这边的题都是遍历上三角，需要从下往上遍历，这是由递推关系式决定的，递推关系式的确定主要还是dp数组的意义的确定，这里比较难想，一旦想到，就迎刃而解了。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++算法</tag>
      </tags>
  </entry>
  <entry>
    <title>代码随想录(day16)</title>
    <url>/link/suixiangluday16.html</url>
    <content><![CDATA[<blockquote>
<p>刷题参考：<a href="https://www.programmercarl.com/">代码随想录 (programmercarl.com)</a></p>
<p>题目来源：<a href="https://leetcode.cn/problems/binary-search">力扣（LeetCode）</a></p>
</blockquote>
<h1 id="Day-16：动态规划（四）"><a href="#Day-16：动态规划（四）" class="headerlink" title="Day 16：动态规划（四）"></a>Day 16：动态规划（四）</h1><h2 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列"></a><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></h2><blockquote>
<p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p>
<p><strong>子序列</strong> 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [10,9,2,5,3,7,101,18]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,1,0,3,2,3]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [7,7,7,7,7,7,7]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 2500</code></li>
<li>$-10^4 &lt;= nums[i] &lt;= 10^4$</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 假设有一个数组10 9 2 5 7</span><br><span class="line">// 设一个dp[i]代表该位置前的数组最长递增子序列长度</span><br><span class="line">// dp[0] = 1,dp[1] = 1,dp[2] = 1,dp[3]=2</span><br><span class="line">// 这里的的递归关系假如这个值大于前面的值，则在该值上+1</span><br><span class="line">// 最后的结果应该是每个的最大值</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    	vector&lt;int&gt; dp(nums.size(),1);</span><br><span class="line">	    int res=1;</span><br><span class="line">    	for(int i=1;i&lt;nums.size();i++)&#123;</span><br><span class="line">    		for(int j=i-1;j&gt;=0;j--)&#123;</span><br><span class="line">    			if(nums[i]&gt;nums[j]) dp[i] = max(dp[i],dp[j]+1);</span><br><span class="line">    		&#125;</span><br><span class="line">			res = max(res,dp[i]);</span><br><span class="line">    	&#125;</span><br><span class="line">    	return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="674-最长连续递增序列"><a href="#674-最长连续递增序列" class="headerlink" title="674. 最长连续递增序列"></a><a href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/">674. 最长连续递增序列</a></h2><blockquote>
<p>给定一个未经排序的整数数组，找到最长且 <strong>连续递增的子序列</strong>，并返回该序列的长度。</p>
<p><strong>连续递增的子序列</strong> 可以由两个下标 <code>l</code> 和 <code>r</code>（<code>l &lt; r</code>）确定，如果对于每个 <code>l &lt;= i &lt; r</code>，都有 <code>nums[i] &lt; nums[i + 1]</code> ，那么子序列 <code>[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]</code> 就是连续递增子序列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,3,5,4,7]</span><br><span class="line">输出：3</span><br><span class="line">解释：最长连续递增序列是 [1,3,5], 长度为3。</span><br><span class="line">尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 </span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,2,2,2,2]</span><br><span class="line">输出：1</span><br><span class="line">解释：最长连续递增序列是 [2], 长度为1。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>$1 &lt;= nums.length &lt;= 10^4$</li>
<li>$-10^9 &lt;= nums[i] &lt;= 10^9$</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这道题与上道题不同，是连续的最长递增序列</span></span><br><span class="line"><span class="comment">// 可以使用双指针去做，一段一段记录，然后取最大的段</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> left=<span class="number">0</span>,right=<span class="number">1</span>,res=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(;left&lt;nums.<span class="built_in">size</span>()&amp;&amp;right&lt;nums.<span class="built_in">size</span>();right++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[right]&lt;=nums[right<span class="number">-1</span>])&#123;</span><br><span class="line">                res = <span class="built_in">max</span>(right-left,res);</span><br><span class="line">                left = right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">max</span>(right-left,res); <span class="comment">// 最后一段没有记录</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 当然也可以用动态规划方法</span></span><br><span class="line"><span class="comment">// 取一个数组1 3 5 4 7</span></span><br><span class="line"><span class="comment">// dp[0] = 1,dp[1] = 2,dp[2] = 3,dp[3] = 1</span></span><br><span class="line"><span class="comment">// 这里其实和上题的类似，但是不需要和前面的每一个比较，只需要和上一位比较即可</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(),<span class="number">1</span>)</span></span>;</span><br><span class="line">		<span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;nums[i<span class="number">-1</span>]) dp[i] = dp[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            res = <span class="built_in">max</span>(res,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="718-最长重复子数组"><a href="#718-最长重复子数组" class="headerlink" title="718. 最长重复子数组"></a><a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/">718. 最长重复子数组</a></h2><blockquote>
<p>给两个整数数组 <code>nums1</code> 和 <code>nums2</code> ，返回 <em>两个数组中 <strong>公共的</strong> 、长度最长的子数组的长度</em> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]</span><br><span class="line">输出：3</span><br><span class="line">解释：长度最长的公共子数组是 [3,2,1] 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li>
<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 100</code></li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最长重复子数组，两个数组，所以使用二维的dp</span></span><br><span class="line"><span class="comment">// dp数组画完，可以看到假如数组的值相等，在前面的dp[i][j] = dp[i-1][j-1]+1</span></span><br><span class="line"><span class="comment">// 不等则直接为0，每一个值与最大值做比较，最终结果即为最大的相等长度</span></span><br><span class="line"><span class="comment">// 开始理解错了，是连续的子序列，想成不连续的，想复杂了</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">		vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(nums1.<span class="built_in">size</span>()+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(nums2.<span class="built_in">size</span>()+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums1.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;nums2.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[i]==nums2[j]) dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j] + <span class="number">1</span>;</span><br><span class="line">                res = <span class="built_in">max</span>(dp[i+<span class="number">1</span>][j+<span class="number">1</span>],res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a><a href="https://leetcode.cn/problems/longest-common-subsequence/">1143. 最长公共子序列</a></h2><blockquote>
<p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。</p>
<p>一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<ul>
<li>例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列。</li>
</ul>
<p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; </span><br><span class="line">输出：3  </span><br><span class="line">解释：最长公共子序列是 &quot;ace&quot; ，它的长度为 3 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：text1 = &quot;abc&quot;, text2 = &quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：最长公共子序列是 &quot;abc&quot; ，它的长度为 3 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：text1 = &quot;abc&quot;, text2 = &quot;def&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：两个字符串没有公共子序列，返回 0 。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= text1.length, text2.length &lt;= 1000</code></li>
<li><code>text1</code> 和 <code>text2</code> 仅由小写英文字符组成。</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个有点像上题想错的思路了，可以间隔取子序列</span></span><br><span class="line"><span class="comment">// 确定dp数组，当两个值相等时，dp[i][j] = dp[i-1][j-1]+1</span></span><br><span class="line"><span class="comment">// 当两个值不等时，dp[i][j] = max(dp[i-1][j],dp[i][j-1])</span></span><br><span class="line"><span class="comment">// 写dp数组多写一行方便初始化递推</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">		vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(text1.<span class="built_in">size</span>()+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(text2.<span class="built_in">size</span>()+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=text1.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=text2.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(text1[i<span class="number">-1</span>]==text2[j<span class="number">-1</span>]) dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[text1.<span class="built_in">size</span>()][text2.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="1035-不相交的线"><a href="#1035-不相交的线" class="headerlink" title="1035. 不相交的线"></a><a href="https://leetcode.cn/problems/uncrossed-lines/">1035. 不相交的线</a></h2><blockquote>
<p>在两条独立的水平线上按给定的顺序写下 <code>nums1</code> 和 <code>nums2</code> 中的整数。</p>
<p>现在，可以绘制一些连接两个数字 <code>nums1[i]</code> 和 <code>nums2[j]</code> 的直线，这些直线需要同时满足满足：</p>
<ul>
<li><code>nums1[i] == nums2[j]</code></li>
<li>且绘制的直线不与任何其他连线（非水平线）相交。</li>
</ul>
<p>请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。</p>
<p>以这种方法绘制线条，并返回可以绘制的最大连线数。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202308132334374.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [1,4,2], nums2 = [1,2,4]</span><br><span class="line">输出：2</span><br><span class="line">解释：可以画出两条不交叉的线，如上图所示。 </span><br><span class="line">但无法画出第三条不相交的直线，因为从 nums1[1]=4 到 nums2[2]=4 的直线将与从 nums1[2]=2 到 nums2[1]=2 的直线相交。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [2,5,1,2,5], nums2 = [10,5,2,1,5,2]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [1,3,7,1,7,5], nums2 = [1,9,2,5,1]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums1.length, nums2.length &lt;= 500</code></li>
<li><code>1 &lt;= nums1[i], nums2[j] &lt;= 2000</code></li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 和上一题不能说是完全一致，只能说是一模一样</span></span><br><span class="line"><span class="comment">// 也就是求两个数组，最大的相同子序列的长度</span></span><br><span class="line"><span class="comment">// 上个题把text换位num即可</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxUncrossedLines</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(nums1.<span class="built_in">size</span>()+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(nums2.<span class="built_in">size</span>()+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=nums1.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=nums2.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[i<span class="number">-1</span>]==nums2[j<span class="number">-1</span>]) dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums1.<span class="built_in">size</span>()][nums2.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a><a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></h2><blockquote>
<p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>子数组</strong> 是数组中的一个连续部分。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [5,4,-1,7,8]</span><br><span class="line">输出：23</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个题，上来一看就是滑动窗口的题目</span></span><br><span class="line"><span class="comment">// 最大和，只要是前面的数组的和的值大于0，那么就采用，如果小于0，不采用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = nums[<span class="number">0</span>],sum=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum&lt;<span class="number">0</span>) sum = nums[i];</span><br><span class="line">            <span class="keyword">else</span> sum += nums[i];</span><br><span class="line">            res = <span class="built_in">max</span>(sum,res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 动态规划解法</span></span><br><span class="line"><span class="comment">// 感觉和上面的想法没啥区别</span></span><br><span class="line"><span class="comment">// 建立dp数组，如果dp[i-1]&lt;0,dp[i] = nums[i]</span></span><br><span class="line"><span class="comment">// 否则为dp[i-1] + nums[i]</span></span><br><span class="line"><span class="comment">// res计算求最大</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i<span class="number">-1</span>]&lt;<span class="number">0</span>) dp[i] = nums[i];</span><br><span class="line">            <span class="keyword">else</span> dp[i] = dp[i<span class="number">-1</span>]+nums[i];</span><br><span class="line">            res = <span class="built_in">max</span>(dp[i],res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里的几道递归题基本就是连续，非连续的子序列的最值问题，这里主要考虑的是递归过程中是否有出现最值减小的情况，如果有，意味着结果需要在递推的过程中不断更新，如果没有，直接取递推数组的最后一个返回即可。另外是二维数组的匹配时，一定要确定两个序列之间的关系，例如两个序列匹配应该是dp[i][j]与dp[i-1][j-1]的关系。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++算法</tag>
      </tags>
  </entry>
  <entry>
    <title>代码随想录(day15)</title>
    <url>/link/suixiangluday15.html</url>
    <content><![CDATA[<blockquote>
<p>刷题参考：<a href="https://www.programmercarl.com/">代码随想录 (programmercarl.com)</a></p>
<p>题目来源：<a href="https://leetcode.cn/problems/binary-search">力扣（LeetCode）</a></p>
</blockquote>
<h1 id="Day-15：动态规划（三）"><a href="#Day-15：动态规划（三）" class="headerlink" title="Day 15：动态规划（三）"></a>Day 15：动态规划（三）</h1><h2 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a href="https://leetcode.cn/problems/house-robber/">198. 打家劫舍</a></h2><blockquote>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
<p>示例 1：</p>
<p>输入：[1,2,3,1]<br>输出：4<br>解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。<br>     偷窃到的最高金额 = 1 + 3 = 4 。</p>
<p>示例 2：</p>
<p>输入：[2,7,9,3,1]<br>输出：12<br>解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。<br>     偷窃到的最高金额 = 2 + 9 + 1 = 12 。</p>
<p>提示：</p>
<p>1 &lt;= nums.length &lt;= 100<br>0 &lt;= nums[i] &lt;= 400</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先确定状态，也就是dp数组的含义</span></span><br><span class="line"><span class="comment">// 有两个状态，偷了这个房间和没偷这个房间</span></span><br><span class="line"><span class="comment">// 即有dp[j][0],dp[j][1]两个状态，j代表房间，值代表偷或者不偷的最大金额</span></span><br><span class="line"><span class="comment">// 确定递推关系，假如要偷第j个房间，那么前一个房间必然没有被偷</span></span><br><span class="line"><span class="comment">// dp[j][0] = dp[j-1][1]+nums[j]</span></span><br><span class="line"><span class="comment">// 假如不偷，那么可能前一个偷了，也可能前一个没偷，取最大值</span></span><br><span class="line"><span class="comment">// dp[j][1] = max(dp[j-1][0],dp[j-1][1])</span></span><br><span class="line"><span class="comment">// 初始化，第一间房间偷了那就是nums[0],没偷就是0</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">		vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(nums.<span class="built_in">size</span>(),<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">1</span>]+nums[i];</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[nums.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">0</span>],dp[nums.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="213-打家劫舍-II"><a href="#213-打家劫舍-II" class="headerlink" title="213. 打家劫舍 II"></a><a href="https://leetcode.cn/problems/house-robber-ii/">213. 打家劫舍 II</a></h2><blockquote>
<p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。</p>
<p>示例 1：</p>
<p>输入：nums = [2,3,2]<br>输出：3<br>解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。<br>示例 2：</p>
<p>输入：nums = [1,2,3,1]<br>输出：4<br>解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。<br>     偷窃到的最高金额 = 1 + 3 = 4 。<br>示例 3：</p>
<p>输入：nums = [1,2,3]<br>输出：3</p>
<p>提示：</p>
<p>1 &lt;= nums.length &lt;= 100<br>0 &lt;= nums[i] &lt;= 1000</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这道题与上道题不同的是房屋成环，针对成环问题可以将环分解为两个非环去解决</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">	    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(nums.<span class="built_in">size</span>()<span class="number">-1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">1</span>]+nums[i];</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp1</span>(nums.<span class="built_in">size</span>()<span class="number">-1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">        dp1[<span class="number">0</span>][<span class="number">0</span>] = nums[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            dp1[i][<span class="number">0</span>] = dp1[i<span class="number">-1</span>][<span class="number">1</span>]+nums[i+<span class="number">1</span>];</span><br><span class="line">            dp1[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp1[i<span class="number">-1</span>][<span class="number">0</span>],dp1[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">max</span>(dp1[nums.<span class="built_in">size</span>()<span class="number">-2</span>][<span class="number">0</span>],dp1[nums.<span class="built_in">size</span>()<span class="number">-2</span>][<span class="number">1</span>]),<span class="built_in">max</span>(dp[nums.<span class="built_in">size</span>()<span class="number">-2</span>][<span class="number">0</span>],dp[nums.<span class="built_in">size</span>()<span class="number">-2</span>][<span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="337-打家劫舍-III"><a href="#337-打家劫舍-III" class="headerlink" title="337. 打家劫舍 III"></a><a href="https://leetcode.cn/problems/house-robber-iii/">337. 打家劫舍 III</a></h2><blockquote>
<p>小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 root 。</p>
<p>除了 root 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。</p>
<p>给定二叉树的 root 。返回 在不触动警报的情况下 ，小偷能够盗取的最高金额 。</p>
<p>示例 1:</p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202308080908530.jpeg" alt="img"></p>
<p>输入: root = [3,2,3,null,3,null,1]<br>输出: 7<br>解释: 小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7<br>示例 2:</p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202308080908219.jpeg" alt="img"></p>
<p>输入: root = [3,4,5,1,3,null,1]<br>输出: 9<br>解释: 小偷一晚能够盗取的最高金额 4 + 5 = 9</p>
<p>提示：</p>
<p>树的节点数在$ [1, 10^4] $范围内<br>$0 &lt;= Node.val &lt;= 10^4$</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先确定状态，每个节点有两种状态，偷或者不偷</span></span><br><span class="line"><span class="comment">// 递归方程和前面题的没有什么不同，区别就是这个是在树结构里</span></span><br><span class="line"><span class="comment">// 题目分析发现，如果从上往下遍历，难以确定，只能后序遍历</span></span><br><span class="line"><span class="comment">// 当一个节点被偷时，那么两个子节点肯定没被偷</span></span><br><span class="line"><span class="comment">// dp[0] = left[1]+right[1]+val</span></span><br><span class="line"><span class="comment">// 当一个节点没有被偷时，那么左右节点偷没偷都有可能，我们需要求最大值</span></span><br><span class="line"><span class="comment">// dp[1] = max(left[0],left[1]) + max(right[0],right[1])</span></span><br><span class="line"><span class="comment">// 递推方程建立，融合到后序遍历中</span></span><br><span class="line"><span class="comment">// 当节点为null时，返回&#123;0,0&#125;，偷不偷都是0</span></span><br><span class="line"><span class="comment">// 递归的终止条件也就是递推的初始条件</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; leftdp=<span class="built_in">next</span>(root-&gt;left);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; rightdp=<span class="built_in">next</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> &#123;leftdp[<span class="number">1</span>]+rightdp[<span class="number">1</span>]+root-&gt;val,<span class="built_in">max</span>(leftdp[<span class="number">0</span>],leftdp[<span class="number">1</span>])+<span class="built_in">max</span>(rightdp[<span class="number">0</span>],rightdp[<span class="number">1</span>])&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">		vector&lt;<span class="type">int</span>&gt; dp=<span class="built_in">next</span>(root);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[<span class="number">0</span>],dp[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h2><blockquote>
<p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p>
<p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p>
<p>示例 1：</p>
<p>输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。<br>示例 2：</p>
<p>输入：prices = [7,6,4,3,1]<br>输出：0<br>解释：在这种情况下, 没有交易完成, 所以最大利润为 0。</p>
<p>提示：</p>
<p>$1 &lt;= prices.length &lt;= 10^5$<br>$0 &lt;= prices[i] &lt;= 10^4$</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 确定状态，股票的状态在某一天有持有和未持有两种状态</span></span><br><span class="line"><span class="comment">// dp[j][0],dp[j][1],j代表天数</span></span><br><span class="line"><span class="comment">// 确定递推公式，当第j天持有时，可能前一天持有，也可能前一天不持有，刚刚持有</span></span><br><span class="line"><span class="comment">// 由于股票只能买一次，当第j天不持有，那么前面可能不持有，也可能持有卖出</span></span><br><span class="line"><span class="comment">// 约束只有一次的条件是当前一天不持有，当天持有时是第一次买入</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">		vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(),<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>],-prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>]+prices[i],dp[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></h2><blockquote>
<p>给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。</p>
<p>在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。</p>
<p>返回 你能获得的 最大 利润 。</p>
<p>示例 1：</p>
<p>输入：prices = [7,1,5,3,6,4]<br>输出：7<br>解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。<br>     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。<br>     总利润为 4 + 3 = 7 。<br>示例 2：</p>
<p>输入：prices = [1,2,3,4,5]<br>输出：4<br>解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。<br>     总利润为 4 。<br>示例 3：</p>
<p>输入：prices = [7,6,4,3,1]<br>输出：0<br>解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。</p>
<p>提示：</p>
<p>$1 &lt;= prices.length &lt;= 3 * 10^4$<br>$0 &lt;= prices[i] &lt;= 10^4$</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果能够多次买入，那么持有的前一天可能从不持有到持有，不持有就不为0，而为不持有的可能</span></span><br><span class="line"><span class="comment">// 只需要在上面的代码中将首次持有的-prices[i]，改为dp[i-1][1]-prices[i]</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">		vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(),<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]-prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>]+prices[i],dp[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="123-买卖股票的最佳时机-III"><a href="#123-买卖股票的最佳时机-III" class="headerlink" title="123. 买卖股票的最佳时机 III"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III</a></h2><blockquote>
<p> 给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p>
<p> 设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p>
<p> 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p> 示例 1:</p>
<p> 输入：prices = [3,3,5,0,0,3,1,4]<br> 输出：6<br> 解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。<br>   随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。<br> 示例 2：</p>
<p> 输入：prices = [1,2,3,4,5]<br> 输出：4<br> 解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   </p>
<p>   注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。<br>   因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。<br> 示例 3：</p>
<p> 输入：prices = [7,6,4,3,1]<br> 输出：0<br> 解释：在这个情况下, 没有交易完成, 所以最大利润为 0。<br> 示例 4：</p>
<p> 输入：prices = [1]<br> 输出：0</p>
<p> 提示：</p>
<p> $1 &lt;= prices.length &lt;= 10^5$<br> $0 &lt;= prices[i] &lt;= 10^5$</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定了最大次数为2，需要考虑多个维度</span></span><br><span class="line"><span class="comment">// 第一次持有，第一次不持有，第二次持有，第二次不持有</span></span><br><span class="line"><span class="comment">// 其实这里面的状态中合并了第一次不持有和卖出后第一次卖出后不持有</span></span><br><span class="line"><span class="comment">// 这是因为第一次不持有其实就是0，求取第一次持有时，直接为0，不考虑前面的状态</span></span><br><span class="line"><span class="comment">// 第一次持有的状态，前一天可能持有，可能不持有到持有，第一次所以不持有为0</span></span><br><span class="line"><span class="comment">// 第一次不持有，也就是卖出后不持有的状态，前一天可能也是不持有状态，或者持有当天卖出</span></span><br><span class="line"><span class="comment">// 第二次持有的状态与第一次一样，不过买入时继承的是第一次卖出的金钱数，</span></span><br><span class="line"><span class="comment">// 第二次卖出与第一次完全一致</span></span><br><span class="line"><span class="comment">// 之后多次其实也是一样</span></span><br><span class="line"><span class="comment">// 由于算是复习，直接将下一题的考虑进去，下一题直接换数就行</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">		vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(),vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(<span class="number">2</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>)));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;prices.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            dp[j][<span class="number">0</span>][<span class="number">0</span>] = <span class="built_in">max</span>(dp[j<span class="number">-1</span>][<span class="number">0</span>][<span class="number">0</span>],-prices[j]);</span><br><span class="line">            dp[j][<span class="number">0</span>][<span class="number">1</span>] = <span class="built_in">max</span>(dp[j<span class="number">-1</span>][<span class="number">0</span>][<span class="number">1</span>],dp[j<span class="number">-1</span>][<span class="number">0</span>][<span class="number">0</span>]+prices[j]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">                dp[j][i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[j<span class="number">-1</span>][i][<span class="number">0</span>],dp[j<span class="number">-1</span>][i<span class="number">-1</span>][<span class="number">1</span>]-prices[j]);</span><br><span class="line">                dp[j][i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[j<span class="number">-1</span>][i][<span class="number">1</span>],dp[j<span class="number">-1</span>][i][<span class="number">0</span>]+prices[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="188-买卖股票的最佳时机-IV"><a href="#188-买卖股票的最佳时机-IV" class="headerlink" title="188. 买卖股票的最佳时机 IV"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">188. 买卖股票的最佳时机 IV</a></h2><blockquote>
<p>给你一个整数数组 prices 和一个整数 k ，其中 prices[i] 是某支给定的股票在第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。也就是说，你最多可以买 k 次，卖 k 次。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>示例 1：</p>
<p>输入：k = 2, prices = [2,4,1]<br>输出：2<br>解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。<br>示例 2：</p>
<p>输入：k = 2, prices = [3,2,6,5,0,3]<br>输出：7<br>解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。<br>     随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。</p>
<p>提示：</p>
<p>1 &lt;= k &lt;= 100<br>1 &lt;= prices.length &lt;= 1000<br>0 &lt;= prices[i] &lt;= 1000</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 与上一题类似，将2改为k即为结果</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">		vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(),vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(k,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>)));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;prices.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            dp[j][<span class="number">0</span>][<span class="number">0</span>] = <span class="built_in">max</span>(dp[j<span class="number">-1</span>][<span class="number">0</span>][<span class="number">0</span>],-prices[j]);</span><br><span class="line">            dp[j][<span class="number">0</span>][<span class="number">1</span>] = <span class="built_in">max</span>(dp[j<span class="number">-1</span>][<span class="number">0</span>][<span class="number">1</span>],dp[j<span class="number">-1</span>][<span class="number">0</span>][<span class="number">0</span>]+prices[j]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;k;i++)&#123;</span><br><span class="line">                dp[j][i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[j<span class="number">-1</span>][i][<span class="number">0</span>],dp[j<span class="number">-1</span>][i<span class="number">-1</span>][<span class="number">1</span>]-prices[j]);</span><br><span class="line">                dp[j][i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[j<span class="number">-1</span>][i][<span class="number">1</span>],dp[j<span class="number">-1</span>][i][<span class="number">0</span>]+prices[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>()<span class="number">-1</span>][k<span class="number">-1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="309-买卖股票的最佳时机含冷冻期"><a href="#309-买卖股票的最佳时机含冷冻期" class="headerlink" title="309. 买卖股票的最佳时机含冷冻期"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309. 买卖股票的最佳时机含冷冻期</a></h2><blockquote>
<p>给定一个整数数组prices，其中第  prices[i] 表示第 i 天的股票价格 。</p>
<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<p>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。<br>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>示例 1:</p>
<p>输入: prices = [1,2,3,0,2]<br>输出: 3<br>解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]<br>示例 2:</p>
<p>输入: prices = [1]<br>输出: 0</p>
<p>提示：</p>
<p>1 &lt;= prices.length &lt;= 5000<br>0 &lt;= prices[i] &lt;= 1000</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 冷冻期的引入，增加了很多状态</span></span><br><span class="line"><span class="comment">// 没有冷冻期，只有持有和不持有状态，</span></span><br><span class="line"><span class="comment">// 冷冻期引入就成了持有，卖出，冷冻期，不持有四个状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">		vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(),<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">4</span>,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">3</span>]-prices[i]),dp[i<span class="number">-1</span>][<span class="number">2</span>]-prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>]+prices[i],dp[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">            dp[i][<span class="number">2</span>] = dp[i<span class="number">-1</span>][<span class="number">1</span>];</span><br><span class="line">            dp[i][<span class="number">3</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">2</span>],dp[i<span class="number">-1</span>][<span class="number">3</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">max</span>(dp[prices.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">1</span>],dp[prices.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">2</span>]),dp[prices.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="714-买卖股票的最佳时机含手续费"><a href="#714-买卖股票的最佳时机含手续费" class="headerlink" title="714. 买卖股票的最佳时机含手续费"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714. 买卖股票的最佳时机含手续费</a></h2><blockquote>
<p>给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。</p>
<p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p>
<p>返回获得利润的最大值。</p>
<p>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p>
<p>示例 1：</p>
<p>输入：prices = [1, 3, 2, 8, 4, 9], fee = 2<br>输出：8<br>解释：能够达到的最大利润:  </p>
<p>在此处买入 prices[0] = 1<br>在此处卖出 prices[3] = 8<br>在此处买入 prices[4] = 4<br>在此处卖出 prices[5] = 9<br>总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8<br>示例 2：</p>
<p>输入：prices = [1,3,7,5,10,3], fee = 3<br>输出：6</p>
<p>提示：</p>
<p>$1 &lt;= prices.length &lt;= 5 <em> 10^4$<br>$1 &lt;= prices[i] &lt; 5 </em> 10^4$<br>$0 &lt;= fee &lt; 5 * 10^4$</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 作为股票的最后一题，一路做下来，其实算是简单题收尾了</span></span><br><span class="line"><span class="comment">// 与无限次卖股票一致，不过需要手续费，在递归时加入手续费即可</span></span><br><span class="line"><span class="comment">// 注意一笔交易手续费只用交一次，在买入时交一次手续费即可</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices, <span class="type">int</span> fee)</span> </span>&#123;</span><br><span class="line">		vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(),<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>]-fee;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]-prices[i]-fee);</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>]+prices[i],dp[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>第一次遇到这种题，想不到，针对状态的转移去进行判断，比背包问题感觉更有动态规划的感觉吧，打家劫舍和股票买卖问题，主要是对题目中可能存在的状态抽象，递推的长度在这两个问题中很明显，一个是户数，一个是天数，状态可能需要一些时间去思考，考虑周全，不遗漏感觉还是有一些难度。在打家劫舍中遇到二叉树的结合，递归中结合递推公式去做，股票问题中，多次购买，递归的维度增加，有助于理解。冷冻期的引入，引起的状态的增加需要仔细思考，感觉应该算是难题范畴。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++算法</tag>
      </tags>
  </entry>
  <entry>
    <title>代码随想录(day14)</title>
    <url>/link/suixiangluday14.html</url>
    <content><![CDATA[<blockquote>
<p>刷题参考：<a href="https://www.programmercarl.com/">代码随想录 (programmercarl.com)</a></p>
<p>题目来源：<a href="https://leetcode.cn/problems/binary-search">力扣（LeetCode）</a></p>
</blockquote>
<h1 id="Day-14：动态规划（二）"><a href="#Day-14：动态规划（二）" class="headerlink" title="Day 14：动态规划（二）"></a>Day 14：动态规划（二）</h1><h2 id="理论基础（背包问题）"><a href="#理论基础（背包问题）" class="headerlink" title="理论基础（背包问题）"></a>理论基础（背包问题）</h2><p>这个小节是背包问题，背包问题是动态规划中的一类简单的问题吧，解决的是用‘物品’填满‘背包’的一类问题，例如：填满背包能获得的最大价值，填满背包的方法等。</p>
<p>背包问题简单的主要有两种，01背包和完全背包，01背包是指所有的物品只有一个，完全背包是指同类的物品有多个。完全背包下还有组合排列问题，背包问题本身的模板很强，</p>
<p>01背包，价值最大问题，这里的<strong>价值可以是个数，可以是体积，可以是任何需要最大的元素，里面的物品也是个抽象的概念，只要具有填满背包的元素以及需要求的价值，那么就可以看成是一个背包问题</strong>，01背包就是所有的物品只有一个，一维的模板如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums+<span class="number">1</span>,<span class="number">0</span>)</span></span>;  <span class="comment">// nums为背包容量</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> &amp;i:things)&#123; <span class="comment">// things是包含物品的列表,[[1,2],[2,3],[3,4]],第一个元素为体积，第二个为价值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=nums;j&gt;=things[i][<span class="number">0</span>];j--)&#123;  <span class="comment">// 因为每个物品只能使用一次，故需要从后往前遍历</span></span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j],dp[j-things[i][<span class="number">0</span>]]+things[i][<span class="number">1</span>]);  <span class="comment">// 根据具体问题，有不同的递推公式</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[nums];</span><br></pre></td></tr></table></figure>
<p>完全背包问题与01背包区别在于，能够无限次使用，所以遍历顺序需要发生变化，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums+<span class="number">1</span>,<span class="number">0</span>)</span></span>;  <span class="comment">// nums为背包容量</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> &amp;i:things)&#123; <span class="comment">// things是包含物品的列表,[[1,2],[2,3],[3,4]],第一个元素为体积，第二个为价值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=things[i][<span class="number">0</span>];j&lt;=nums;j++)&#123;  <span class="comment">// 完全背包，从前往后遍历</span></span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j],dp[j-things[i][<span class="number">0</span>]]+things[i][<span class="number">1</span>]);  <span class="comment">// 根据具体问题，有不同的递推公式</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[nums];</span><br></pre></td></tr></table></figure>
<p>背包问题的解决方案的个数，根据排列组合的不同，背包和物品的遍历顺序不同，如果是排列问题，则需要先遍历背包，再遍历物品，如果先遍历物品，那么顺序固定，就成了求组合数。</p>
<h2 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a><a href="https://leetcode.cn/problems/partition-equal-subset-sum/">416. 分割等和子集</a></h2><blockquote>
<p>给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<p>示例 1：</p>
<p>输入：nums = [1,5,11,5]<br>输出：true<br>解释：数组可以分割成 [1, 5, 5] 和 [11] 。<br>示例 2：</p>
<p>输入：nums = [1,2,3,5]<br>输出：false<br>解释：数组不能分割成两个元素和相等的子集。</p>
<p>提示：</p>
<p>1 &lt;= nums.length &lt;= 200<br>1 &lt;= nums[i] &lt;= 100</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分割成两个等和的子集，换种说法，集合的子集中可以组合成集合总和的一半</span></span><br><span class="line"><span class="comment">// 如果集合的总和不能对半分则不能分割</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> &amp;i:nums)&#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum%<span class="number">2</span>!=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        sum = sum/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 开始01背包,本题中子集中的价值与体积相等都是本身。</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(sum+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> &amp;i:nums)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=sum;j&gt;=i;j--)&#123; <span class="comment">// 只能取一次，从后往前遍历</span></span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j],dp[j-i]+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[sum] == sum) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="1049-最后一块石头的重量-II"><a href="#1049-最后一块石头的重量-II" class="headerlink" title="1049. 最后一块石头的重量 II"></a><a href="https://leetcode.cn/problems/last-stone-weight-ii/">1049. 最后一块石头的重量 II</a></h2><blockquote>
<p>有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。</p>
<p>每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;= y。那么粉碎的可能结果如下：</p>
<p>如果 x == y，那么两块石头都会被完全粉碎；<br>如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。<br>最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 0。</p>
<p>示例 1：</p>
<p>输入：stones = [2,7,4,1,8,1]<br>输出：1<br>解释：<br>组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，<br>组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，<br>组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，<br>组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。<br>示例 2：</p>
<p>输入：stones = [31,26,33,21,40]<br>输出：5</p>
<p>提示：</p>
<p>1 &lt;= stones.length &lt;= 30<br>1 &lt;= stones[i] &lt;= 100</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 石头粉碎，如果不是按照顺序来做，其实这里比较难想</span></span><br><span class="line"><span class="comment">// 但是前面有了分割子集，这里可以想到，可以转换为以下问题</span></span><br><span class="line"><span class="comment">// 将石头分为两堆，要两堆差别最小，也就是其中一堆尽可能的靠近总数一半</span></span><br><span class="line"><span class="comment">// 最后剩下的就是总和-2*能凑齐的最大数，即为结果</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lastStoneWeightII</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">if</span>(stones.<span class="built_in">size</span>()&lt;<span class="number">2</span>) <span class="keyword">return</span> stones[<span class="number">0</span>];</span><br><span class="line">    	<span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> &amp;i:stones)&#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid = sum/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 开始01背包</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(mid+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> &amp;i:stones)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=mid;j&gt;=i;j--)&#123;</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j],dp[j-i]+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum<span class="number">-2</span>*dp[mid];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494. 目标和"></a><a href="https://leetcode.cn/problems/target-sum/">494. 目标和</a></h2><blockquote>
<p>给你一个非负整数数组 nums 和一个整数 target 。</p>
<p>向数组中的每个整数前添加 ‘+’ 或 ‘-‘ ，然后串联起所有整数，可以构造一个 表达式 ：</p>
<p>例如，nums = [2, 1] ，可以在 2 之前添加 ‘+’ ，在 1 之前添加 ‘-‘ ，然后串联起来得到表达式 “+2-1” 。<br>返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。</p>
<p>示例 1：</p>
<p>输入：nums = [1,1,1,1,1], target = 3<br>输出：5<br>解释：一共有 5 种方法让最终目标和为 3 。<br>-1 + 1 + 1 + 1 + 1 = 3<br>+1 - 1 + 1 + 1 + 1 = 3<br>+1 + 1 - 1 + 1 + 1 = 3<br>+1 + 1 + 1 - 1 + 1 = 3<br>+1 + 1 + 1 + 1 - 1 = 3<br>示例 2：</p>
<p>输入：nums = [1], target = 1<br>输出：1</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按照赋予的运算可以分为-和+两类，设-总和为left，+总和为right</span></span><br><span class="line"><span class="comment">// right-left = target，right+left = sum</span></span><br><span class="line"><span class="comment">// left = (sum-target)/2</span></span><br><span class="line"><span class="comment">// 如果不能整除，则不能凑齐，返回0种方法</span></span><br><span class="line"><span class="comment">// 如果sum&lt;target返回0,不能凑齐</span></span><br><span class="line"><span class="comment">// 这里获取的是方法的个数，递归方程与之前有所不同</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">	    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> &amp;i:nums)&#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum&lt;target) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>((sum-target)%<span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = (sum-target)/<span class="number">2</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(left+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;  <span class="comment">// 次数相关的递归，需要初始值设置为1，当为0时有一种方法凑齐</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> &amp;i:nums)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=left;j&gt;=i;j--)&#123;</span><br><span class="line">                dp[j] += dp[j-i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="474-一和零"><a href="#474-一和零" class="headerlink" title="474. 一和零"></a><a href="https://leetcode.cn/problems/ones-and-zeroes/">474. 一和零</a></h2><blockquote>
<p>给你一个二进制字符串数组 strs 和两个整数 m 和 n 。</p>
<p>请你找出并返回 strs 的最大子集的长度，该子集中 最多 有 m 个 0 和 n 个 1 。</p>
<p>如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。</p>
<p>示例 1：</p>
<p>输入：strs = [“10”, “0001”, “111001”, “1”, “0”], m = 5, n = 3<br>输出：4<br>解释：最多有 5 个 0 和 3 个 1 的最大子集是 {“10”,”0001”,”1”,”0”} ，因此答案是 4 。<br>其他满足题意但较小的子集包括 {“0001”,”1”} 和 {“10”,”1”,”0”} 。{“111001”} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。<br>示例 2：</p>
<p>输入：strs = [“10”, “0”, “1”], m = 1, n = 1<br>输出：2<br>解释：最大的子集是 {“0”, “1”} ，所以答案是 2 。</p>
<p>提示：</p>
<p>1 &lt;= strs.length &lt;= 600<br>1 &lt;= strs[i].length &lt;= 100<br>strs[i] 仅由 ‘0’ 和 ‘1’ 组成<br>1 &lt;= m, n &lt;= 100</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该题的物品体积有两个维度0的个数和1的个数，每一个物品的价值均为1</span></span><br><span class="line"><span class="comment">// 遍历物品，计算其中0，1的个数</span></span><br><span class="line"><span class="comment">// 使用二维01背包解题</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMaxForm</span><span class="params">(vector&lt;string&gt;&amp; strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i:strs)&#123;</span><br><span class="line">            <span class="type">int</span> zeros=<span class="number">0</span>,ones=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;j:i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j==<span class="string">&#x27;1&#x27;</span>) ones ++;</span><br><span class="line">                <span class="keyword">else</span> zeros++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;=zeros;j--)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=n;k&gt;=ones;k--)&#123;</span><br><span class="line">                    dp[j][k] = <span class="built_in">max</span>(dp[j][k],dp[j-zeros][k-ones]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="518-零钱兑换-II"><a href="#518-零钱兑换-II" class="headerlink" title="518. 零钱兑换 II"></a><a href="https://leetcode.cn/problems/coin-change-ii/">518. 零钱兑换 II</a></h2><blockquote>
<p>给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。</p>
<p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。</p>
<p>假设每一种面额的硬币有无限个。 </p>
<p>题目数据保证结果符合 32 位带符号整数。</p>
<p>示例 1：</p>
<p>输入：amount = 5, coins = [1, 2, 5]<br>输出：4<br>解释：有四种方式可以凑成总金额：<br>5=5<br>5=2+2+1<br>5=2+1+1+1<br>5=1+1+1+1+1<br>示例 2：</p>
<p>输入：amount = 3, coins = [2]<br>输出：0<br>解释：只用面额 2 的硬币不能凑成总金额 3 。<br>示例 3：</p>
<p>输入：amount = 10, coins = [10]<br>输出：1</p>
<p>提示：</p>
<p>1 &lt;= coins.length &lt;= 300<br>1 &lt;= coins[i] &lt;= 5000<br>coins 中的所有值 互不相同<br>0 &lt;= amount &lt;= 5000</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 完全背包，顺序遍历</span></span><br><span class="line"><span class="comment">// 题目中需要计算的是个数，所以使用个数的递推公式</span></span><br><span class="line"><span class="comment">// 这里是组合问题，先物品后背包</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">change</span><span class="params">(<span class="type">int</span> amount, vector&lt;<span class="type">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">	    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> &amp;i:coins)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=amount;j++)&#123;</span><br><span class="line">                dp[j] += dp[j-i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="377-组合总和-Ⅳ"><a href="#377-组合总和-Ⅳ" class="headerlink" title="377. 组合总和 Ⅳ"></a><a href="https://leetcode.cn/problems/combination-sum-iv/">377. 组合总和 Ⅳ</a></h2><blockquote>
<p>给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。</p>
<p>题目数据保证答案符合 32 位整数范围。</p>
<p>示例 1：</p>
<p>输入：nums = [1,2,3], target = 4<br>输出：7<br>解释：<br>所有可能的组合为：<br>(1, 1, 1, 1)<br>(1, 1, 2)<br>(1, 2, 1)<br>(1, 3)<br>(2, 1, 1)<br>(2, 2)<br>(3, 1)<br>请注意，顺序不同的序列被视作不同的组合。<br>示例 2：</p>
<p>输入：nums = [9], target = 3<br>输出：0</p>
<p>提示：</p>
<p>1 &lt;= nums.length &lt;= 200<br>1 &lt;= nums[i] &lt;= 1000<br>nums 中的所有元素 互不相同<br>1 &lt;= target &lt;= 1000</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 题目中顺序不同视为不同的组合，故是个排列问题</span></span><br><span class="line"><span class="comment">// 排列问题中，先遍历背包后遍历物品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">combinationSum4</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">		<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(target+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=target;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> &amp;i:nums)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j-i&gt;=<span class="number">0</span>) dp[j] += dp[j-i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 执行出错，int越界，这里个数超过了int的上限值，正常来讲将int改为long long类型</span></span><br><span class="line"><span class="comment">// 但是还是越界，改为unsigned long long问题解决</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">combinationSum4</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">		<span class="function">vector&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt; <span class="title">dp</span><span class="params">(target+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=target;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> &amp;i:nums)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j-i&gt;=<span class="number">0</span>) dp[j] += dp[j-i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 其实针对题目来讲可以加入判断是否相加越界，但是真的就是针对题目了</span></span><br></pre></td></tr></table></figure>
<h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></h2><blockquote>
<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>示例 1：</p>
<p>输入：n = 2<br>输出：2<br>解释：有两种方法可以爬到楼顶。</p>
<ol>
<li>1 阶 + 1 阶</li>
<li>2 阶</li>
</ol>
<p>示例 2：</p>
<p>输入：n = 3<br>输出：3<br>解释：有三种方法可以爬到楼顶。</p>
<ol>
<li>1 阶 + 1 阶 + 1 阶</li>
<li>1 阶 + 2 阶</li>
<li>2 阶 + 1 阶</li>
</ol>
<p>提示：</p>
<p>1 &lt;= n &lt;= 45</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重回爬楼梯，这次用完全背包求解</span></span><br><span class="line"><span class="comment">// 背包容量为n，物品为1,2</span></span><br><span class="line"><span class="comment">// 1,2位置不同，是不同的方式，为排列问题</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j-i&gt;=<span class="number">0</span>) dp[j] += dp[j-i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a></h2><blockquote>
<p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</p>
<p>计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<p>示例 1：</p>
<p>输入：coins = [1, 2, 5], amount = 11<br>输出：3<br>解释：11 = 5 + 5 + 1<br>示例 2：</p>
<p>输入：coins = [2], amount = 3<br>输出：-1<br>示例 3：</p>
<p>输入：coins = [1], amount = 0<br>输出：0</p>
<p>提示：</p>
<p>1 &lt;= coins.length &lt;= 12<br>1 &lt;= coins[i] &lt;= 231 - 1<br>0 &lt;= amount &lt;= 104</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无限次使用，完全背包问题，计算所需的最小硬币数，取min</span></span><br><span class="line"><span class="comment">// 背包为给定的数，物品为硬币面值，每个硬币的价值为1</span></span><br><span class="line"><span class="comment">// 因为求最小，所以初始赋值应该都为最大</span></span><br><span class="line"><span class="comment">// 因为找零需要完全相等，所以如果是最大值，证明为初始值，找不开</span></span><br><span class="line"><span class="comment">// 以此为基础的后续也找不开,最后为最大值则返回-1</span></span><br><span class="line"><span class="comment">// amount的值为0，直接返回0</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(amount==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount+<span class="number">1</span>,INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> &amp;i:coins)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=amount;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j-i] != INT_MAX)</span><br><span class="line">                	dp[j] = <span class="built_in">min</span>(dp[j],dp[j-i]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[amount]==INT_MAX) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a><a href="https://leetcode.cn/problems/perfect-squares/">279. 完全平方数</a></h2><blockquote>
<p>给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。</p>
<p>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p>
<p> 示例 1：</p>
<p>输入：n = 12<br>输出：3<br>解释：12 = 4 + 4 + 4<br>示例 2：</p>
<p>输入：n = 13<br>输出：2<br>解释：13 = 4 + 9</p>
<p>提示：</p>
<p>1 &lt;= n &lt;= 104</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最小个数，和上个题类似，为组合问题</span></span><br><span class="line"><span class="comment">// 但是这个没有找不开的问题，不需要考虑太多条件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSquares</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i*i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i*i;j&lt;=n;j++)&#123;</span><br><span class="line">                dp[j] = <span class="built_in">min</span>(dp[j],dp[j-i*i]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139. 单词拆分"></a><a href="https://leetcode.cn/problems/word-break/">139. 单词拆分</a></h2><blockquote>
<p>给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。</p>
<p>注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p>
<p>示例 1：</p>
<p>输入: s = “leetcode”, wordDict = [“leet”, “code”]<br>输出: true<br>解释: 返回 true 因为 “leetcode” 可以由 “leet” 和 “code” 拼接成。<br>示例 2：</p>
<p>输入: s = “applepenapple”, wordDict = [“apple”, “pen”]<br>输出: true<br>解释: 返回 true 因为 “applepenapple” 可以由 “apple” “pen” “apple” 拼接成。<br>     注意，你可以重复使用字典中的单词。<br>示例 3：</p>
<p>输入: s = “catsandog”, wordDict = [“cats”, “dog”, “sand”, “and”, “cat”]<br>输出: false</p>
<p>提示：</p>
<p>1 &lt;= s.length &lt;= 300<br>1 &lt;= wordDict.length &lt;= 1000<br>1 &lt;= wordDict[i].length &lt;= 20<br>s 和 wordDict[i] 仅有小写英文字母组成<br>wordDict 中的所有字符串 互不相同</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前面的所有题都是数组题，突然换到字符串还是不能很好的适应</span></span><br><span class="line"><span class="comment">// 首先的想法可能是使用回溯去做，但是很容易超时</span></span><br><span class="line"><span class="comment">// 记忆法+回溯能过，但是不是很好写</span></span><br><span class="line"><span class="comment">// 这里作为背包问题，字符串s为背包，字符串列表中元素为物品</span></span><br><span class="line"><span class="comment">// 是否对应是体积，能否组成是价值，顺序是有意义的，是排列问题</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">		<span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(s.size()+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=s.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i:wordDict)&#123;</span><br><span class="line">                <span class="type">int</span> slen = i.<span class="built_in">size</span>(); <span class="comment">// substr函数传参使用i.size()报错</span></span><br><span class="line">				<span class="keyword">if</span>(j-slen&gt;=<span class="number">0</span>&amp;&amp;dp[j-slen]&amp;&amp;s.<span class="built_in">substr</span>(j-slen,slen)==i)</span><br><span class="line">                    dp[j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[s.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>背包问题的模板性太强了，区分好01背包和完全背包，排列和组合问题，次数还是价值，基本上就解出来了，注意初始化的问题，例如，最大初始化0，最小初始化INT_MAX，次数初始化1，其余的就是对问题的抽象了。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++算法</tag>
      </tags>
  </entry>
  <entry>
    <title>代码随想录(day13)</title>
    <url>/link/suixiangluday13.html</url>
    <content><![CDATA[<blockquote>
<p>刷题参考：<a href="https://www.programmercarl.com/">代码随想录 (programmercarl.com)</a></p>
<p>题目来源：<a href="https://leetcode.cn/problems/binary-search">力扣（LeetCode）</a></p>
</blockquote>
<h1 id="Day-13：动态规划（一）"><a href="#Day-13：动态规划（一）" class="headerlink" title="Day 13：动态规划（一）"></a>Day 13：动态规划（一）</h1><h2 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h2><p>一个问题能由之前的状态推导到当前状态，这样的问题可以抽象成一个递归公式，即可使用动态规划求解。</p>
<p>动态规划五部曲：</p>
<ul>
<li>确定dp数组以及下标的含义：搞清需要递归的目标是什么</li>
<li>确定递推公式：根据前面状态推导当前状态的公式</li>
<li>dp数组初始化：一般递推公式都需要手动设定初始状态的值</li>
<li>确定遍历顺序：根据公式，明确需要循环的变量</li>
<li>举例推导dp数组：举个简单的列子，验证推导公式的正确性</li>
</ul>
<p>动态规划与贪心算法的区别：通俗来讲，就是一个需要根据之前的状态推导当前状态，另一个只需要考虑子问题的最优解。</p>
<h2 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509. 斐波那契数"></a><a href="https://leetcode.cn/problems/fibonacci-number/">509. 斐波那契数</a></h2><blockquote>
<p>斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：</p>
<p>F(0) = 0，F(1) = 1<br>F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1<br>给定 n ，请计算 F(n) 。</p>
<p>示例 1：</p>
<p>输入：n = 2<br>输出：1<br>解释：F(2) = F(1) + F(0) = 1 + 0 = 1<br>示例 2：</p>
<p>输入：n = 3<br>输出：2<br>解释：F(3) = F(2) + F(1) = 1 + 1 = 2<br>示例 3：</p>
<p>输入：n = 4<br>输出：3<br>解释：F(4) = F(3) + F(2) = 2 + 1 = 3</p>
<p>提示：</p>
<p>0 &lt;= n &lt;= 30</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 题目给的很明确，直接递推</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">int</span> dp[<span class="number">2</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> temp=dp[<span class="number">1</span>];</span><br><span class="line">            dp[<span class="number">1</span>] += dp[<span class="number">0</span>];</span><br><span class="line">            dp[<span class="number">0</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></h2><blockquote>
<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>示例 1：</p>
<p>输入：n = 2<br>输出：2<br>解释：有两种方法可以爬到楼顶。</p>
<ol>
<li>1 阶 + 1 阶</li>
<li>2 阶<br>示例 2：</li>
</ol>
<p>输入：n = 3<br>输出：3<br>解释：有三种方法可以爬到楼顶。</p>
<ol>
<li>1 阶 + 1 阶 + 1 阶</li>
<li>1 阶 + 2 阶</li>
<li>2 阶 + 1 阶</li>
</ol>
<p>提示：</p>
<p>1 &lt;= n &lt;= 45</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 刚做完斐波那契数列，这个题就是一个变形</span></span><br><span class="line"><span class="comment">// 因为每次爬楼梯可以爬一阶或者两阶，那么爬到当前阶的方法就是前一阶和前两阶方法的求和</span></span><br><span class="line"><span class="comment">// 稍作修改即可得</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">3</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">int</span> dp[<span class="number">2</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> temp=dp[<span class="number">1</span>];</span><br><span class="line">            dp[<span class="number">1</span>] += dp[<span class="number">0</span>];</span><br><span class="line">            dp[<span class="number">0</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 当然可以作为一个完全背包的排列问题去解决，解法放在下节</span></span><br></pre></td></tr></table></figure>
<h2 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a><a href="https://leetcode.cn/problems/min-cost-climbing-stairs/">746. 使用最小花费爬楼梯</a></h2><blockquote>
<p>给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p>
<p>你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。</p>
<p>请你计算并返回达到楼梯顶部的最低花费。</p>
<p>示例 1：</p>
<p>输入：cost = [10,15,20]<br>输出：15<br>解释：你将从下标为 1 的台阶开始。</p>
<ul>
<li>支付 15 ，向上爬两个台阶，到达楼梯顶部。<br>总花费为 15 。<br>示例 2：</li>
</ul>
<p>输入：cost = [1,100,1,1,1,100,1,1,100,1]<br>输出：6<br>解释：你将从下标为 0 的台阶开始。</p>
<ul>
<li>支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。</li>
<li>支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。</li>
<li>支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。</li>
<li>支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。</li>
<li>支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。</li>
<li>支付 1 ，向上爬一个台阶，到达楼梯顶部。<br>总花费为 6 。</li>
</ul>
<p>提示：</p>
<p>2 &lt;= cost.length &lt;= 1000<br>0 &lt;= cost[i] &lt;= 999</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 题目中要求的是最小的花费，每次花费可以往前前进一阶或者两阶</span></span><br><span class="line"><span class="comment">// 这里的楼顶就是cost.size()的位置</span></span><br><span class="line"><span class="comment">// 每一步取前面的最小值</span></span><br><span class="line"><span class="comment">// 初始化是到达每个位置的最小花费</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> dp[<span class="number">2</span>]=&#123;cost[<span class="number">0</span>],cost[<span class="number">1</span>]&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;cost.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="type">int</span> temp = dp[<span class="number">1</span>];</span><br><span class="line">            dp[<span class="number">1</span>] = <span class="built_in">min</span>(dp[<span class="number">0</span>],dp[<span class="number">1</span>]) + cost[i];</span><br><span class="line">            dp[<span class="number">0</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(dp[<span class="number">0</span>],dp[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><a href="https://leetcode.cn/problems/unique-paths/">62. 不同路径</a></h2><blockquote>
<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>
<p>问总共有多少条不同的路径？</p>
<p> <img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202308051746238.png" alt="img"></p>
<p>示例 1：</p>
<p>输入：m = 3, n = 7<br>输出：28<br>示例 2：</p>
<p>输入：m = 3, n = 2<br>输出：3<br>解释：<br>从左上角开始，总共有 3 条路径可以到达右下角。</p>
<ol>
<li>向右 -&gt; 向下 -&gt; 向下</li>
<li>向下 -&gt; 向下 -&gt; 向右</li>
<li>向下 -&gt; 向右 -&gt; 向下<br>示例 3：</li>
</ol>
<p>输入：m = 7, n = 3<br>输出：28<br>示例 4：</p>
<p>输入：m = 3, n = 3<br>输出：6</p>
<p>提示：</p>
<p>1 &lt;= m, n &lt;= 100<br>题目数据保证答案小于等于 2 * 109</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据题目，机器人只能向下或者向右走，那么</span></span><br><span class="line"><span class="comment">// 到达某一点的路径数，就是达到右方和上方路径数的和</span></span><br><span class="line"><span class="comment">// 递推关系确定，接下来是初始条件</span></span><br><span class="line"><span class="comment">// 最左边和最上边能到达的路径数皆为1</span></span><br><span class="line"><span class="comment">// 递归的数据是二维数组，清晰直观操作</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j]+dp[i][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63. 不同路径 II"></a><a href="https://leetcode.cn/problems/unique-paths-ii/">63. 不同路径 II</a></h2><blockquote>
<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202308052111350.png" alt="img"> </p>
<p>示例 1：</p>
<p>输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]<br>输出：2<br>解释：3x3 网格的正中间有一个障碍物。<br>从左上角到右下角一共有 2 条不同的路径：</p>
<ol>
<li>向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</li>
<li>向下 -&gt; 向下 -&gt; 向右 -&gt; 向右<br>示例 2：</li>
</ol>
<p>输入：obstacleGrid = [[0,1],[0,0]]<br>输出：1</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这道题和上道题唯一的不同是多了石子的设定</span></span><br><span class="line"><span class="comment">// 要明确石子带来的影响，当该位置存在石子时，不管其余有多少路径，能到达的都是0</span></span><br><span class="line"><span class="comment">// 另外假如石子存在与初始化的边上时，需要额外考虑对后续步骤的影响</span></span><br><span class="line"><span class="comment">// 最后得到的代码如下</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;obstacleGrid.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;obstacleGrid[<span class="number">0</span>].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(obstacleGrid[i][j]==<span class="number">1</span>) obstacleGrid[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;j==<span class="number">0</span>) obstacleGrid[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">0</span>) obstacleGrid[i][j] += obstacleGrid[i][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">0</span>) obstacleGrid[i][j] += obstacleGrid[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">else</span> obstacleGrid[i][j] = obstacleGrid[i<span class="number">-1</span>][j]+obstacleGrid[i][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obstacleGrid[obstacleGrid.<span class="built_in">size</span>()<span class="number">-1</span>][obstacleGrid[<span class="number">0</span>].<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="343-整数拆分"><a href="#343-整数拆分" class="headerlink" title="343. 整数拆分"></a><a href="https://leetcode.cn/problems/integer-break/">343. 整数拆分</a></h2><blockquote>
<p>给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k &gt;= 2 ），并使这些整数的乘积最大化。</p>
<p>返回 你可以获得的最大乘积 。</p>
<p>示例 1:</p>
<p>输入: n = 2<br>输出: 1<br>解释: 2 = 1 + 1, 1 × 1 = 1。<br>示例 2:</p>
<p>输入: n = 10<br>输出: 36<br>解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。</p>
<p>提示:</p>
<p>2 &lt;= n &lt;= 58</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 整数可以被拆分为两部分，例如5=3+2</span></span><br><span class="line"><span class="comment">// 那么最大的乘积也可以分为3能分割实现的最大乘积，以及2能实现的最大乘积相乘</span></span><br><span class="line"><span class="comment">// 需要额外考虑数字本身是否为最大的值，例如3的最大分割乘积为2,比本身的3要小</span></span><br><span class="line"><span class="comment">// 这样，我们只需要考虑一部分的分割，因为如果有一部分能分割，必然能够融合到另一部分中</span></span><br><span class="line"><span class="comment">// 最后的递推公式就成了在i和[dp[n-i],n-i]的乘积中选择最大值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">integerBreak</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> temp=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="type">int</span> mul = dp[i-j]&gt;i-j?dp[i-j]:i-j;</span><br><span class="line">                <span class="keyword">if</span>(temp&lt;j*mul) temp=j*mul;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a><a href="https://leetcode.cn/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></h2><blockquote>
<p>给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。</p>
<p> <img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202308052122038.jpeg" alt="img"></p>
<p>示例 1：</p>
<p>输入：n = 3<br>输出：5<br>示例 2：</p>
<p>输入：n = 1<br>输出：1</p>
<p>提示：</p>
<p>1 &lt;= n &lt;= 19</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这道题正常画图，观察，可以发现右边外边是关键</span></span><br><span class="line"><span class="comment">// 当右边外边只有一个节点时，插入新值有两种方式，得到1,2两个新的边节点个数</span></span><br><span class="line"><span class="comment">// 两个时，有三种方式，得到1,2,3三个新的边节点个数</span></span><br><span class="line"><span class="comment">// 有n个节点时，有n+1种方式，得到1,2，...，n+1 n+1个新的边节点个数</span></span><br><span class="line"><span class="comment">// 直观想，直接新建一个队列，出栈一个进栈两个，...</span></span><br><span class="line"><span class="comment">// 最后统计队列中的元素个数，即得总个数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">3</span>) <span class="keyword">return</span> n;</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">        temp.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">        temp.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> size=temp.<span class="built_in">size</span>()<span class="number">-1</span>;size&gt;=<span class="number">0</span>;size--)&#123;</span><br><span class="line">                <span class="type">int</span> cur = temp.<span class="built_in">front</span>();</span><br><span class="line">                temp.<span class="built_in">pop_front</span>();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cur+<span class="number">1</span>;j++)&#123;</span><br><span class="line">                    temp.<span class="built_in">push_back</span>(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 思路简单，但是超时，下面是改进后的代码</span></span><br><span class="line"><span class="comment">// 开始写的代码，忘记了思路，/(~.~)\</span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">3</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">temp</span><span class="params">(<span class="number">2</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> size=temp.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            temp.<span class="built_in">pop_front</span>();</span><br><span class="line">            temp.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(;size&gt;<span class="number">0</span>;size--)&#123;</span><br><span class="line">                temp.<span class="built_in">push_back</span>(temp.<span class="built_in">back</span>()+temp.<span class="built_in">front</span>());</span><br><span class="line">                temp.<span class="built_in">pop_front</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            temp.<span class="built_in">push_back</span>(temp.<span class="built_in">back</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(;n&gt;=<span class="number">2</span>;n--)&#123;</span><br><span class="line">            sum += n*temp.<span class="built_in">front</span>();</span><br><span class="line">            temp.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202308052148418.png" alt="96.不同的二叉搜索树2"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据上面的表格，可以建立递推公式</span></span><br><span class="line"><span class="comment">// dp[4] = dp[0]*dp[3]+dp[1]*dp[2]+dp[2]*dp[1]+dp[3]*dp[0]</span></span><br><span class="line"><span class="comment">// 得到动态规划代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> temp=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                temp += dp[j]*dp[i-j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202308052201675.png" alt="image-20230805220158603"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据数学关系，可以将上述的递推公式转换为卡特兰公式，推导如上</span></span><br><span class="line"><span class="comment">// 实现代码如下</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">G</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        G[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        G[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">                G[i] += G[j - <span class="number">1</span>] * G[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> G[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​        作为动态规划的初始篇章，主要解决了一些简单的问题，可以看出动态规划的代码非常的简洁，主要的工作在推导递推公式，以及明确初始化上。最后的二叉搜索树比较难想，好想的方法又超时，其实根本原因还是因为递推公式没有明确下来，其余的题目都较为基础，注意一些细节的实现问题，基本上就能解出。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++算法</tag>
      </tags>
  </entry>
  <entry>
    <title>代码随想录(day12)</title>
    <url>/link/suixiangluday12.html</url>
    <content><![CDATA[<blockquote>
<p>刷题参考：<a href="https://www.programmercarl.com/">代码随想录 (programmercarl.com)</a></p>
<p>题目来源：<a href="https://leetcode.cn/problems/binary-search">力扣（LeetCode）</a></p>
</blockquote>
<h1 id="Day-12：贪心算法（后篇）"><a href="#Day-12：贪心算法（后篇）" class="headerlink" title="Day 12：贪心算法（后篇）"></a>Day 12：贪心算法（后篇）</h1><h2 id="406-根据身高重建队列"><a href="#406-根据身高重建队列" class="headerlink" title="406. 根据身高重建队列"></a><a href="https://leetcode.cn/problems/queue-reconstruction-by-height/">406. 根据身高重建队列</a></h2><blockquote>
<p>假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。</p>
<p>请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。</p>
<p>示例 1：</p>
<p>输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]<br>输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]<br>解释：<br>编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。<br>编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。<br>编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。<br>编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。<br>编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。<br>编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。<br>因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。<br>示例 2：</p>
<p>输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]<br>输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]</p>
<p>提示：</p>
<p>1 &lt;= people.length &lt;= 2000<br>0 &lt;= hi &lt;= 106<br>0 &lt;= ki &lt; people.length<br>题目数据确保队列可以被重建</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这道题如果没做过类似题，或者思维不是很灵活的，不太好想</span></span><br><span class="line"><span class="comment">// 分解问题可以分为两个步骤，首先是排序，从大到小按第一个元素排序</span></span><br><span class="line"><span class="comment">// 然后按照顺序，将第二个元素作为index插入新的数组这样就能保证满足条件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;a,vector&lt;<span class="type">int</span>&gt; &amp;b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>]==b[<span class="number">0</span>]?a[<span class="number">1</span>]&lt;b[<span class="number">1</span>]:a[<span class="number">0</span>]&gt;b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; people) &#123;</span><br><span class="line">		<span class="built_in">sort</span>(people.<span class="built_in">begin</span>(),people.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i:people)&#123;</span><br><span class="line">            <span class="type">int</span> pos=i[<span class="number">1</span>];</span><br><span class="line">            res.<span class="built_in">insert</span>(res.<span class="built_in">begin</span>()+pos,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="452-用最少数量的箭引爆气球"><a href="#452-用最少数量的箭引爆气球" class="headerlink" title="452. 用最少数量的箭引爆气球"></a><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">452. 用最少数量的箭引爆气球</a></h2><blockquote>
<p>有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] = [xstart, xend] 表示水平直径在 xstart 和 xend之间的气球。你不知道气球的确切 y 坐标。</p>
<p>一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。 弓箭一旦被射出之后，可以无限地前进。</p>
<p>给你一个数组 points ，返回引爆所有气球所必须射出的 最小 弓箭数 。</p>
<p>示例 1：</p>
<p>输入：points = [[10,16],[2,8],[1,6],[7,12]]<br>输出：2<br>解释：气球可以用2支箭来爆破:<br>-在x = 6处射出箭，击破气球[2,8]和[1,6]。<br>-在x = 11处发射箭，击破气球[10,16]和[7,12]。<br>示例 2：</p>
<p>输入：points = [[1,2],[3,4],[5,6],[7,8]]<br>输出：4<br>解释：每个气球需要射出一支箭，总共需要4支箭。<br>示例 3：</p>
<p>输入：points = [[1,2],[2,3],[3,4],[4,5]]<br>输出：2<br>解释：气球可以用2支箭来爆破:</p>
<ul>
<li>在x = 2处发射箭，击破气球[1,2]和[2,3]。</li>
<li>在x = 4处射出箭，击破气球[3,4]和[4,5]。</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读题可以发现是一个区间问题，首先需要对数组进行排序</span></span><br><span class="line"><span class="comment">// 排序后的数组按照从小到大的顺序，区间的右端如果大于下个区间的左端</span></span><br><span class="line"><span class="comment">// 则说明可以使用一支箭击穿，如果右端大于下个区间的右端，则更新右端</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;a,vector&lt;<span class="type">int</span>&gt; &amp;b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>]==b[<span class="number">0</span>]?a[<span class="number">1</span>]&lt;b[<span class="number">1</span>]:a[<span class="number">0</span>]&lt;b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMinArrowShots</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">sort</span>(points.<span class="built_in">begin</span>(),points.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        <span class="type">int</span> right=points[<span class="number">0</span>][<span class="number">1</span>],res=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i:points)&#123;</span><br><span class="line">            <span class="keyword">if</span>(right&gt;=i[<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(right&gt;i[<span class="number">1</span>]) </span><br><span class="line">                    right = i[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                res ++;</span><br><span class="line">                right = i[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435. 无重叠区间"></a><a href="https://leetcode.cn/problems/non-overlapping-intervals/">435. 无重叠区间</a></h2><blockquote>
<p>给定一个区间的集合 intervals ，其中 intervals[i] = [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。</p>
<p>示例 1:</p>
<p>输入: intervals = [[1,2],[2,3],[3,4],[1,3]]<br>输出: 1<br>解释: 移除 [1,3] 后，剩下的区间没有重叠。<br>示例 2:</p>
<p>输入: intervals = [ [1,2], [1,2], [1,2] ]<br>输出: 2<br>解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。<br>示例 3:</p>
<p>输入: intervals = [ [1,2], [2,3] ]<br>输出: 0<br>解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正常想法，排序后，不断合并有交集的，最终剩下的就是没有重叠的，合并的就是需要去除的个数</span></span><br><span class="line"><span class="comment">// 但是当一个大的区间包含两个小的区间的时候，会合并成一个大的区间，去掉了两个</span></span><br><span class="line"><span class="comment">// 要是保留两个小区间，只需要去除一个大的区间</span></span><br><span class="line"><span class="comment">// 有上面扎气球的题目，不难想到，其实扎气球的方法是保留了小区间的，因为有右边的左更新</span></span><br><span class="line"><span class="comment">// 因此，右边左更新会保留小区间，右边的右更新会保留更大的区间</span></span><br><span class="line"><span class="comment">// 这道题就变成了求扎气球需要的个数，然后总数减去扎气球个数即为结果</span></span><br><span class="line"><span class="comment">// 需要注意判断条件，扎气球首尾相等算重叠，这个不算</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;a,vector&lt;<span class="type">int</span>&gt; &amp;b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>]==b[<span class="number">0</span>]?a[<span class="number">1</span>]&lt;b[<span class="number">1</span>]:a[<span class="number">0</span>]&lt;b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(),intervals.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        <span class="type">int</span> right=intervals[<span class="number">0</span>][<span class="number">1</span>],res=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i:intervals)&#123;</span><br><span class="line">            <span class="keyword">if</span>(right&gt;i[<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(right&gt;i[<span class="number">1</span>]) </span><br><span class="line">                    right = i[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                res ++;</span><br><span class="line">                right = i[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intervals.<span class="built_in">size</span>()-res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763. 划分字母区间"></a><a href="https://leetcode.cn/problems/partition-labels/">763. 划分字母区间</a></h2><blockquote>
<p>给你一个字符串 s 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。</p>
<p>注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 s 。</p>
<p>返回一个表示每个字符串片段的长度的列表。</p>
<p>示例 1：<br>输入：s = “ababcbacadefegdehijhklij”<br>输出：[9,7,8]<br>解释：<br>划分结果为 “ababcbaca”、”defegde”、”hijhklij” 。<br>每个字母最多出现在一个片段中。<br>像 “ababcbacadefegde”, “hijhklij” 这样的划分是错误的，因为划分的片段数较少。<br>示例 2：</p>
<p>输入：s = “eccbbbbdec”<br>输出：[10]</p>
<p>提示：</p>
<p>1 &lt;= s.length &lt;= 500<br>s 仅由小写英文字母组成</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 看到字母，需要查找字母的，先想到的是哈希表，计算字母的个数</span></span><br><span class="line"><span class="comment">// 于是有以下思路，一个指针指向最前面，另一个指针指向最后面</span></span><br><span class="line"><span class="comment">// 最后面的指针往前移动，直至等于最前面的指针，并记录经过的字母个数</span></span><br><span class="line"><span class="comment">// 最前面的指针往后移动，如果指向的字母在记录的表中出现过</span></span><br><span class="line"><span class="comment">// 那么右指针右移到该字母在表中的个数为0，循环上面的操作，直至左右指针相遇</span></span><br><span class="line"><span class="comment">// 再对后面的进行上面的操作</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">next</span><span class="params">(string &amp;s,<span class="type">int</span> left,<span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;right) <span class="keyword">return</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="type">char</span> temp=s[right];</span><br><span class="line">        <span class="keyword">while</span>(temp!=s[left])&#123;</span><br><span class="line">            <span class="keyword">if</span>(mp[temp]) mp[temp]++;</span><br><span class="line">            <span class="keyword">else</span> mp[temp]=<span class="number">1</span>;</span><br><span class="line">            temp = s[--right];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=left+<span class="number">1</span>;i&lt;=right;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(mp[s[i]])&#123;</span><br><span class="line">                right++;</span><br><span class="line">                mp[s[right]]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(right-left+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">next</span>(s,right+<span class="number">1</span>,s.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">partitionLabels</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">next</span>(s,<span class="number">0</span>,s.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 更简单，快速的思路，先遍历一遍字符串，把每个字母出现过的最大位置记录下来</span></span><br><span class="line"><span class="comment">// 在进行遍历，当字符位置等于记录的最大位置的时候，就是一段，然后继续第二段</span></span><br><span class="line"><span class="comment">// 如果在到达指定位置前，出现了大于指定位置的值，则更新指定位置为最大位置。</span></span><br><span class="line"><span class="comment">// 只需要两次遍历，就能得到结果</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">partitionLabels</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> hash[<span class="number">27</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash[s[i]-<span class="string">&#x27;a&#x27;</span>]&lt;i) hash[s[i]-<span class="string">&#x27;a&#x27;</span>]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> temp=hash[s[<span class="number">0</span>]-<span class="string">&#x27;a&#x27;</span>],left=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash[s[i]-<span class="string">&#x27;a&#x27;</span>]&gt;temp) temp=hash[s[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span>(i==temp)&#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(temp-left);</span><br><span class="line">                temp = hash[s[i+<span class="number">1</span>]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">                left = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(temp-left);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a></h2><blockquote>
<p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p>
<p>示例 1：</p>
<p>输入：intervals = [[1,3],[2,6],[8,10],[15,18]]<br>输出：[[1,6],[8,10],[15,18]]<br>解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].<br>示例 2：</p>
<p>输入：intervals = [[1,4],[4,5]]<br>输出：[[1,5]]<br>解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 区间问题，这次是保留大区间，所以先排序然后右边往右更新</span></span><br><span class="line"><span class="comment">// 将每一段的左右值记录下来，更新到结果中</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;a,vector&lt;<span class="type">int</span>&gt; &amp;b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">0</span>]==b[<span class="number">0</span>]) <span class="keyword">return</span> a[<span class="number">1</span>]&gt;b[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>]&lt;b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(),intervals.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        <span class="type">int</span> left=intervals[<span class="number">0</span>][<span class="number">0</span>],right=intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;intervals.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(right&gt;=intervals[i][<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(right&lt;intervals[i][<span class="number">1</span>]) right=intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(&#123;left,right&#125;);</span><br><span class="line">                left = intervals[i][<span class="number">0</span>];</span><br><span class="line">                right = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(&#123;left,right&#125;);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="738-单调递增的数字"><a href="#738-单调递增的数字" class="headerlink" title="738. 单调递增的数字"></a><a href="https://leetcode.cn/problems/monotone-increasing-digits/">738. 单调递增的数字</a></h2><blockquote>
<p>当且仅当每个相邻位数上的数字 x 和 y 满足 x &lt;= y 时，我们称这个整数是单调递增的。</p>
<p>给定一个整数 n ，返回 小于或等于 n 的最大数字，且数字呈 单调递增 。</p>
<p>示例 1:</p>
<p>输入: n = 10<br>输出: 9<br>示例 2:</p>
<p>输入: n = 1234<br>输出: 1234<br>示例 3:</p>
<p>输入: n = 332<br>输出: 299</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 观察后可以发现，当给的数值呈单调递增的时候，就是原值</span></span><br><span class="line"><span class="comment">// 当有一位出现了小于前一位的情况，那么后续所有的值全部为9，前一位需要-1</span></span><br><span class="line"><span class="comment">// 当出现相等值时需要再往前移动，因为减少后的值不满足递增关系</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">monotoneIncreasingDigits</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        string s=<span class="built_in">to_string</span>(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i+<span class="number">1</span>]&lt;s[i])&#123;</span><br><span class="line">                <span class="keyword">while</span>(i&gt;<span class="number">0</span>&amp;&amp;s[i]==s[i<span class="number">-1</span>]) i--;</span><br><span class="line">                s[i] = s[i]<span class="number">-1</span>;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">while</span>(i&lt;s.<span class="built_in">size</span>())&#123;</span><br><span class="line">                    s[i]=<span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">atoi</span>(s.<span class="built_in">c_str</span>());    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="968-监控二叉树"><a href="#968-监控二叉树" class="headerlink" title="968. 监控二叉树"></a><a href="https://leetcode.cn/problems/binary-tree-cameras/">968. 监控二叉树</a></h2><blockquote>
<p>给定一个二叉树，我们在树的节点上安装摄像头。</p>
<p>节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。</p>
<p>计算监控树的所有节点所需的最小摄像头数量。 </p>
<p>示例 1：</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_01.png" alt="img"></p>
<p>输入：[0,0,null,0,0]<br>输出：1<br>解释：如图所示，一台摄像头足以监控所有节点。<br>示例 2：</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_02.png" alt="img"></p>
<p>输入：[0,0,null,0,null,0,null,null,0]<br>输出：2<br>解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检测节点需要最少，所以需要从叶子节点往上判断，叶子结点不能作为监督节点</span></span><br><span class="line"><span class="comment">// 所以采用后序遍历，并需要传递当前节点的状态，采用0，1，2,作为状态标记</span></span><br><span class="line"><span class="comment">// 分别代表，监督未覆盖节点，监督节点，监督覆盖节点</span></span><br><span class="line"><span class="comment">// 最后的根节点如果是未覆盖节点需要加入一个监督节点</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">(TreeNode* &amp;root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="built_in">next</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> right = <span class="built_in">next</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="number">2</span>&amp;&amp;right==<span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="number">0</span>||right==<span class="number">0</span>) &#123;</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="number">1</span>||right==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCameraCover</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">next</span>(root)==<span class="number">0</span>) res++;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>贪心算法结束，感觉和没刷过差不太多，首先将贪心算法，更像一种经验，当然这是对思维不灵活的来说，一个问题分解成成多个问题，或者多个步骤，在每个步骤中进行操作得到最优，最后得到最后的结果。多维数组的排序问题，先进行单维度的排序；区间问题，需要先排序，然后明确是需要小区间还是大区间，确定右值的更新方式；划分字母区间，hash表用来存储最大index；监控二叉树，对所有的状态进行赋值，返回状态值进行判断。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++算法</tag>
      </tags>
  </entry>
  <entry>
    <title>代码随想录(day11)</title>
    <url>/link/suixiangluday11.html</url>
    <content><![CDATA[<blockquote>
<p> 刷题参考：<a href="https://www.programmercarl.com/">代码随想录 (programmercarl.com)</a></p>
<p>题目来源：<a href="https://leetcode.cn/problems/binary-search">力扣（LeetCode）</a></p>
</blockquote>
<h1 id="Day-11：贪心算法（前篇）"><a href="#Day-11：贪心算法（前篇）" class="headerlink" title="Day 11：贪心算法（前篇）"></a>Day 11：贪心算法（前篇）</h1><h2 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h2><p>贪心的本质是每阶段的局部最优达到全局最优。</p>
<ul>
<li>只根据当前已有的信息就做出选择，而且一旦做出了选择，将来无论如何都不能更改</li>
<li>不从整体最优考虑，所做的选择只是在某种意义上的<strong>局部最优</strong></li>
<li>这种选择并不总能获得整体最优解（Optimal Solution），但通常能获得<strong>近似最优解</strong>（Near-Optimal Solution）</li>
</ul>
<blockquote>
<p>动态规划法通常以自底向上的方式求解各个子问题。<br>贪心法则通常以自顶向下的方式做出一系列的贪心选择。</p>
</blockquote>
<p><strong>最优量度标准（正确的贪心策略，贪心选择性质）</strong></p>
<ul>
<li>贪心法求解问题的核心问题</li>
<li>根据该量度标准，实行多步决策进行求解</li>
<li>在该量度意义下，每步的贪心选择是局部最优的</li>
<li>得到全局最优解</li>
</ul>
<p><strong>求解的问题有最优子结构性质(最优性原理)</strong></p>
<ul>
<li>一个问题的最优解包含其子问题的最优解</li>
</ul>
<blockquote>
<p>注：贪心算法的基本要素是贪心选择性质和最优子结构性质。</p>
</blockquote>
<p>所以贪心问题就是一个<strong>分解-&gt;求解-&gt;合并</strong>的过程。唯一的难点就是如何通过局部最优，推出整体最优。</p>
<p>靠自己手动模拟，如果模拟可行，就可以试一试贪心策略，如果不可行，可能需要动态规划。</p>
<p>如何验证可不可以用贪心算法呢？</p>
<p><strong>最好用的策略就是举反例，如果想不到反例，那么就试一试贪心吧</strong>。</p>
<p>可有同学认为手动模拟，举例子得出的结论不靠谱，想要严格的数学证明。</p>
<p>一般数学证明有如下两种方法：</p>
<ul>
<li>数学归纳法</li>
<li>反证法</li>
</ul>
<h2 id="455-分发饼干"><a href="#455-分发饼干" class="headerlink" title="455. 分发饼干"></a><a href="https://leetcode.cn/problems/assign-cookies/">455. 分发饼干</a></h2><blockquote>
<p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p>
<p>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p>
<p>示例 1:</p>
<p>输入: g = [1,2,3], s = [1,1]<br>输出: 1<br>解释:<br>你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。<br>虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。<br>所以你应该输出1。<br>示例 2:</p>
<p>输入: g = [1,2], s = [1,2,3]<br>输出: 2<br>解释:<br>你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。<br>你拥有的饼干数量和尺寸都足以让所有孩子满足。<br>所以你应该输出2.</p>
<p>提示：</p>
<p>1 &lt;= g.length &lt;= 3 <em> 104<br>0 &lt;= s.length &lt;= 3 </em> 104<br>1 &lt;= g[i], s[j] &lt;= 231 - 1</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 贪心算法的思维就是如何拆解问题，局部问题的最优解能合并得到全局最优</span></span><br><span class="line"><span class="comment">// 分饼干可以拆解为两个方向</span></span><br><span class="line"><span class="comment">// 1.拆解为最大饼干满足最大胃口</span></span><br><span class="line"><span class="comment">// 2.拆解为最小胃口给对应胃口的最小饼干</span></span><br><span class="line"><span class="comment">// 这样看示例2，这两种拆解的方法虽然都是能满足两个孩子</span></span><br><span class="line"><span class="comment">// 但是两者的分配方案其实是不同的</span></span><br><span class="line"><span class="comment">// 1. [1,2],[2,3]</span></span><br><span class="line"><span class="comment">// 2. [1,2],[1,2]</span></span><br><span class="line"><span class="comment">// 也就是说贪心算法得到的不一定是全局最优解，下面是采用第二种拆解方式的代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; g, vector&lt;<span class="type">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(g.<span class="built_in">begin</span>(),g.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i:g)&#123;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;s.<span class="built_in">size</span>()&amp;&amp;i&gt;s[left]) left++;</span><br><span class="line">            <span class="keyword">if</span>(left&gt;=s.<span class="built_in">size</span>()) <span class="keyword">break</span>;</span><br><span class="line">            sum++;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="376-摆动序列"><a href="#376-摆动序列" class="headerlink" title="376. 摆动序列"></a><a href="https://leetcode.cn/problems/wiggle-subsequence/">376. 摆动序列</a></h2><blockquote>
<p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p>
<p>例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。</p>
<p>相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。<br>子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。</p>
<p>给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。</p>
<p>示例 1：</p>
<p>输入：nums = [1,7,4,9,2,5]<br>输出：6<br>解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。<br>示例 2：</p>
<p>输入：nums = [1,17,5,10,13,15,10,5,16,8]<br>输出：7<br>解释：这个序列包含几个长度为 7 摆动序列。<br>其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。<br>示例 3：</p>
<p>输入：nums = [1,2,3,4,5,6,7,8,9]<br>输出：2</p>
<p>提示：</p>
<p>1 &lt;= nums.length &lt;= 1000<br>0 &lt;= nums[i] &lt;= 1000</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先拆解为子问题，摆动序列整体看摆动，在个体上看就是大于两边，或者小于两边</span></span><br><span class="line"><span class="comment">// 只需要判断大于两边或者小于两边的个数，开头必定算一个</span></span><br><span class="line"><span class="comment">// 结束的时候正常情况下也算一个，只有当序列全为一个值时（sum=1并且头尾相等）才不需要+1</span></span><br><span class="line"><span class="comment">// 当出现连续值时，也就是出现平的情况，这样需要先记录前一个的值，再进行遍历到不同的值再进行判断</span></span><br><span class="line"><span class="comment">// 也就是将平的情况切除出去</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">wiggleMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&lt;<span class="number">2</span>) <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> right=<span class="number">1</span>;right&lt;nums.<span class="built_in">size</span>()<span class="number">-1</span>;right++)&#123;</span><br><span class="line">            <span class="type">int</span> temp=nums[right<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">while</span>(right&lt;nums.<span class="built_in">size</span>()<span class="number">-1</span>&amp;&amp;nums[right]==nums[right+<span class="number">1</span>]) right++;</span><br><span class="line">            <span class="keyword">if</span>(right&gt;=nums.<span class="built_in">size</span>()<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>((nums[right]&lt;temp&amp;&amp;nums[right]&lt;nums[right+<span class="number">1</span>])||\</span><br><span class="line">                (nums[right]&gt;temp&amp;&amp;nums[right]&gt;nums[right+<span class="number">1</span>]))sum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>]==nums.<span class="built_in">back</span>()&amp;&amp;sum==<span class="number">1</span>)<span class="keyword">return</span> sum;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> sum+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a><a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></h2><blockquote>
<p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>子数组 是数组中的一个连续部分。</p>
<p>示例 1：</p>
<p>输入：nums = [-2,1,-3,4,-1,2,1,-5,4]<br>输出：6<br>解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。<br>示例 2：</p>
<p>输入：nums = [1]<br>输出：1<br>示例 3：</p>
<p>输入：nums = [5,4,-1,7,8]<br>输出：23</p>
<p>提示：</p>
<p>1 &lt;= nums.length &lt;= 105<br>-104 &lt;= nums[i] &lt;= 104</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 连续子数组的最大值，拆分问题为，前一段序列与当前值相加</span></span><br><span class="line"><span class="comment">// 这样当前一段序列大于0时才对最大值有帮助，小于0，不如直接选择当前值</span></span><br><span class="line"><span class="comment">// 由于题目中有负数存在，所以最大值初始化为最小负数</span></span><br><span class="line"><span class="comment">// 将每段得到的最大值进行比较，得到的最大值，即为最大值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum=INT_MIN;</span><br><span class="line">        <span class="type">int</span> max=sum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum&lt;<span class="number">0</span>) sum=i;</span><br><span class="line">            <span class="keyword">else</span> sum += i;</span><br><span class="line">            <span class="keyword">if</span>(max&lt;sum) max=sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></h2><blockquote>
<p>给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。</p>
<p>在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。</p>
<p>返回 你能获得的 最大 利润 。</p>
<p>示例 1：</p>
<p>输入：prices = [7,1,5,3,6,4]<br>输出：7<br>解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。<br>     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。<br>     总利润为 4 + 3 = 7 。<br>示例 2：</p>
<p>输入：prices = [1,2,3,4,5]<br>输出：4<br>解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。<br>     总利润为 4 。<br>示例 3：</p>
<p>输入：prices = [7,6,4,3,1]<br>输出：0<br>解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。</p>
<p>提示：</p>
<p>1 &lt;= prices.length &lt;= 3 * 104<br>0 &lt;= prices[i] &lt;= 104</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 题目看清之后很简单，正常想示例最小买，后面最大再卖，其实和只在赚的前一天买，后一天买是一样的</span></span><br><span class="line"><span class="comment">// 也就是将一整段的股票保有期，拆解成为多个小段</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;prices.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> num = prices[i+<span class="number">1</span>]-prices[i];</span><br><span class="line">            <span class="keyword">if</span>(num&gt;<span class="number">0</span>) sum+=num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a><a href="https://leetcode.cn/problems/jump-game/">55. 跳跃游戏</a></h2><blockquote>
<p>给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个下标。</p>
<p>示例 1：</p>
<p>输入：nums = [2,3,1,1,4]<br>输出：true<br>解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。<br>示例 2：</p>
<p>输入：nums = [3,2,1,0,4]<br>输出：false<br>解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</p>
<p>提示：</p>
<p>1 &lt;= nums.length &lt;= 3 * 104<br>0 &lt;= nums[i] &lt;= 105</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 观察跳跃的情况，不难发现，只要每个数组中没有值等于0，则必然能跳到终点</span></span><br><span class="line"><span class="comment">// 当存在0时，往前遍历如果有值能大于步数则也能跳过，然后重新将步数置为0</span></span><br><span class="line"><span class="comment">// 这样，如果步数存在，则不能跳到，不存在，则可以跳到</span></span><br><span class="line"><span class="comment">// 注意最后一步已经跳到，所以遍历的时候不考虑最后一个的情况</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> temp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=nums.<span class="built_in">size</span>()<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;=temp) temp += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(temp&gt;<span class="number">0</span>) temp=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp?<span class="literal">false</span>:<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 贪心算法的思路的话，就是将一整段看成一小段一小段，用一个max记录最大值，分别记录当前能到的最大值</span></span><br><span class="line"><span class="comment">// 如果最大值最后小于数组长度，那么不能跳到，大于等于则能跳到</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=max;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]+i&gt;max) max=nums[i]+i;</span><br><span class="line">            <span class="keyword">if</span>(max&gt;=nums.<span class="built_in">size</span>()<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45. 跳跃游戏 II"></a><a href="https://leetcode.cn/problems/jump-game-ii/">45. 跳跃游戏 II</a></h2><blockquote>
<p>给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。</p>
<p>每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处:</p>
<p>0 &lt;= j &lt;= nums[i]<br>i + j &lt; n<br>返回到达 nums[n - 1] 的最小跳跃次数。生成的测试用例可以到达 nums[n - 1]。</p>
<p>示例 1:</p>
<p>输入: nums = [2,3,1,1,4]<br>输出: 2<br>解释: 跳到最后一个位置的最小跳跃数是 2。<br>     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。<br>示例 2:</p>
<p>输入: nums = [2,3,0,1,4]<br>输出: 2</p>
<p>提示:</p>
<p>1 &lt;= nums.length &lt;= 104<br>0 &lt;= nums[i] &lt;= 1000<br>题目保证可以到达 nums[n-1]</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 题目保证了必定能达到终点，这道题首先想到的是从终点逆向推导</span></span><br><span class="line"><span class="comment">// 在数组从后往前找到能满足到达最后一个点的最前面的位置，记录位置</span></span><br><span class="line"><span class="comment">// 再从记录的位置往前推导，找到满足的最前面的位置，直至到达0，每次更新推导步数+1</span></span><br><span class="line"><span class="comment">// 这是一个递归过程，代码如下</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">next</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> index,<span class="type">int</span> &amp;sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> min=index;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=index;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;=index-i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&lt;min) min=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sum++;</span><br><span class="line">        <span class="built_in">next</span>(nums,min,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">next</span>(nums,nums.<span class="built_in">size</span>()<span class="number">-1</span>,sum);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 使用分解的思想，求每一步能达到的最大位置</span></span><br><span class="line"><span class="comment">// 然后再每次求上次最大位置和本次最大位置之间的最大值</span></span><br><span class="line"><span class="comment">// 直到最大值大于等于最后的位置</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> max=nums[<span class="number">0</span>],premax=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(max&lt;nums.<span class="built_in">size</span>()<span class="number">-1</span>)&#123;</span><br><span class="line">            sum ++;</span><br><span class="line">            <span class="type">int</span> temp=max,i=premax;</span><br><span class="line">            <span class="keyword">for</span>(;i&lt;=temp;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(max&lt;i+nums[i]) max=i+nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            premax = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 使用一个for循环完成</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">1</span>,len=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> max=nums[<span class="number">0</span>],premax=max;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;max&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(max&lt;i+nums[i]) max=i+nums[i];</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=premax||max&gt;=len)&#123;</span><br><span class="line">                sum++;</span><br><span class="line">                premax = max;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="1005-K-次取反后最大化的数组和"><a href="#1005-K-次取反后最大化的数组和" class="headerlink" title="1005. K 次取反后最大化的数组和"></a><a href="https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/">1005. K 次取反后最大化的数组和</a></h2><blockquote>
<p>给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组：</p>
<p>选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。<br>重复这个过程恰好 k 次。可以多次选择同一个下标 i 。</p>
<p>以这种方式修改数组后，返回数组 可能的最大和 。</p>
<p>示例 1：</p>
<p>输入：nums = [4,2,3], k = 1<br>输出：5<br>解释：选择下标 1 ，nums 变为 [4,-2,3] 。<br>示例 2：</p>
<p>输入：nums = [3,-1,0,2], k = 3<br>输出：6<br>解释：选择下标 (1, 2, 2) ，nums 变为 [3,1,0,2] 。<br>示例 3：</p>
<p>输入：nums = [2,-3,-1,5,-4], k = 2<br>输出：13<br>解释：选择下标 (1, 4) ，nums 变为 [2,3,-1,5,4] 。</p>
<p>提示：</p>
<p>1 &lt;= nums.length &lt;= 104<br>-100 &lt;= nums[i] &lt;= 100<br>1 &lt;= k &lt;= 104</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正常思维，先排序，然后翻转负数，负数翻转完，反复翻转最小值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestSumAfterKNegations</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">0</span>) sum+=i;</span><br><span class="line">            <span class="keyword">else</span> flag++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;flag;i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i&lt;k) sum -= nums[i];</span><br><span class="line">                <span class="keyword">else</span> sum += nums[i];</span><br><span class="line">                nums[i] = -nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">if</span>(k&gt;flag)&#123;</span><br><span class="line">            <span class="keyword">if</span>((k-flag)%<span class="number">2</span>==<span class="number">0</span>) <span class="keyword">return</span> sum;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> sum<span class="number">-2</span>*nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 优化的话，可以按绝对值从大到小排序，然后遍历相加求和过程中遇到负数就翻转一次，</span></span><br><span class="line"><span class="comment">// 翻转次数不够就不翻转，翻转结束有剩余，就判断翻转剩余次数的奇偶性</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(a) &gt; <span class="built_in">abs</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestSumAfterKNegations</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;<span class="number">0</span>&amp;&amp;k&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                sum-=i;</span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> sum+=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k%<span class="number">2</span>==<span class="number">0</span>) <span class="keyword">return</span> sum;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums.<span class="built_in">back</span>()&lt;<span class="number">0</span>) sum+=<span class="number">2</span>*nums.<span class="built_in">back</span>();</span><br><span class="line">        <span class="keyword">else</span> sum-=<span class="number">2</span>*nums.<span class="built_in">back</span>();</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="134-加油站"><a href="#134-加油站" class="headerlink" title="134. 加油站"></a><a href="https://leetcode.cn/problems/gas-station/">134. 加油站</a></h2><blockquote>
<p>在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p>
<p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</p>
<p>给定两个整数数组 gas 和 cost ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。</p>
<p>示例 1:</p>
<p>输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]<br>输出: 3<br>解释:<br>从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油<br>开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油<br>开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油<br>开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油<br>开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油<br>开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。<br>因此，3 可为起始索引。<br>示例 2:</p>
<p>输入: gas = [2,3,4], cost = [3,4,3]<br>输出: -1<br>解释:<br>你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。<br>我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油<br>开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油<br>开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油<br>你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。<br>因此，无论怎样，你都不可能绕环路行驶一周。</p>
<p>提示:</p>
<p>gas.length == n<br>cost.length == n<br>1 &lt;= n &lt;= 105<br>0 &lt;= gas[i], cost[i] &lt;= 104</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单想，要算经过一个站之后的净剩余油量，也就是加油数-耗油数</span></span><br><span class="line"><span class="comment">// 直接两个循环，第一层循环确定起始位置，第二层循环判断能够走完一圈</span></span><br><span class="line"><span class="comment">// 直接提交会超时，需要额外判断条件，当汽油总量小于0时结束循环，继续检查下一个开始点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">canCompleteCircuit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; gas, vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(gas.<span class="built_in">size</span>()==<span class="number">1</span>&amp;&amp;gas[<span class="number">0</span>]==cost[<span class="number">0</span>]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;gas.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="type">int</span> cur = gas[i]-cost[i];</span><br><span class="line">            <span class="keyword">if</span>(cur&gt;<span class="number">0</span>&amp;&amp;(i==<span class="number">0</span>||cur&gt;gas[i<span class="number">-1</span>]-cost[i<span class="number">-1</span>]))&#123;</span><br><span class="line">                sum += cur;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> temp=i+<span class="number">1</span>;i?temp!=i:temp!=gas.<span class="built_in">size</span>();temp++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(temp==gas.<span class="built_in">size</span>()) temp=<span class="number">0</span>;</span><br><span class="line">                    sum += gas[temp]-cost[temp];</span><br><span class="line">                    <span class="keyword">if</span>(sum&lt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(sum&gt;=<span class="number">0</span>) <span class="keyword">return</span> i;</span><br><span class="line">                <span class="keyword">else</span> sum=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 算所有的油箱剩余，如果油为负数，则向前求补充，油为正数则向后前行</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">canCompleteCircuit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; gas, vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,len=gas.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> right=len;</span><br><span class="line">        <span class="type">int</span> sum = gas[right]-cost[right];</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                sum+=(gas[left]-cost[left]);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                right--;</span><br><span class="line">                sum+=(gas[right]-cost[right]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;=<span class="number">0</span>) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="135-分发糖果"><a href="#135-分发糖果" class="headerlink" title="135. 分发糖果"></a><a href="https://leetcode.cn/problems/candy/">135. 分发糖果</a></h2><blockquote>
<p>n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。</p>
<p>你需要按照以下要求，给这些孩子分发糖果：</p>
<p>每个孩子至少分配到 1 个糖果。<br>相邻两个孩子评分更高的孩子会获得更多的糖果。<br>请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。</p>
<p>示例 1：</p>
<p>输入：ratings = [1,0,2]<br>输出：5<br>解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。<br>示例 2：</p>
<p>输入：ratings = [1,2,2]<br>输出：4<br>解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。<br>     第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。</p>
<p>提示：</p>
<p>n == ratings.length<br>1 &lt;= n &lt;= 2 <em> 104<br>0 &lt;= ratings[i] &lt;= 2 </em> 104</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将问题分解成从左往右给糖，和从右往左给糖，合并两个问题的解，取最大</span></span><br><span class="line"><span class="comment">// 思路难想，也不好确定是否真的正确，但举不出反例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">candy</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; ratings)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len=ratings.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len&lt;<span class="number">2</span>) <span class="keyword">return</span> len;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">        <span class="keyword">if</span>(ratings[<span class="number">1</span>]-ratings[<span class="number">0</span>]&gt;=<span class="number">0</span>) temp.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span>  temp.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i+<span class="number">1</span>]-ratings[i]&gt;<span class="number">0</span>) temp.<span class="built_in">push_back</span>(temp.<span class="built_in">back</span>()+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//else if(ratings[i+1]==ratings[i]) temp.push_back(1);</span></span><br><span class="line">            <span class="keyword">else</span> temp.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; cur=temp;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(ratings[len<span class="number">-2</span>]-ratings[len<span class="number">-1</span>]&gt;=<span class="number">0</span>) cur[len<span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>  cur[len<span class="number">-1</span>]=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=len<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i<span class="number">-1</span>]-ratings[i]&gt;<span class="number">0</span>) cur[i<span class="number">-1</span>]=cur[i]+<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//else if(ratings[i-1]==ratings[i]) cur[i-1]=1;</span></span><br><span class="line">            <span class="keyword">else</span> cur[i<span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line">            res+=temp[i]&gt;cur[i]?temp[i]:cur[i];</span><br><span class="line">        &#125;</span><br><span class="line">        res+=temp[<span class="number">0</span>]&gt;cur[<span class="number">0</span>]?temp[<span class="number">0</span>]:cur[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="860-柠檬水找零"><a href="#860-柠檬水找零" class="headerlink" title="860. 柠檬水找零"></a><a href="https://leetcode.cn/problems/lemonade-change/">860. 柠檬水找零</a></h2><blockquote>
<p>在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。</p>
<p>每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。</p>
<p>注意，一开始你手头没有任何零钱。</p>
<p>给你一个整数数组 bills ，其中 bills[i] 是第 i 位顾客付的账。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。</p>
<p>示例 1：</p>
<p>输入：bills = [5,5,5,10,20]<br>输出：true<br>解释：<br>前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。<br>第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。<br>第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。<br>由于所有客户都得到了正确的找零，所以我们输出 true。<br>示例 2：</p>
<p>输入：bills = [5,5,10,10,20]<br>输出：false<br>解释：<br>前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。<br>对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。<br>对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。<br>由于不是每位顾客都得到了正确的找零，所以答案是 false。</p>
<p>提示：</p>
<p>1 &lt;= bills.length &lt;= 105<br>bills[i] 不是 5 就是 10 或是 20 </p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拆解问题，找钱的时候有大的找大的，没大的找小的，都没有找不开</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">lemonadeChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; bills)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> fivenums=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> tennums=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> &amp;i:bills)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">5</span>) fivenums++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">10</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(fivenums) fivenums--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                tennums++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(tennums&amp;&amp;fivenums)&#123;</span><br><span class="line">                    fivenums--;</span><br><span class="line">                    tennums--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(fivenums&gt;=<span class="number">3</span>) fivenums-=<span class="number">3</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>将大问题分解为小问题，或者说大区间分解为小区间，在小区间上找最优解，然后合并起来得到大区间上的最优解，分解的逻辑不固定，需要自己想，小问题的区间，条件的判断，需要仔细考虑，感觉是常识，数学，大问题变小问题等的结合。分饼干和分糖果的问题上体现的很好，其他问题上可能感觉不太到，也可能是我学识浅薄，看不懂。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++算法</tag>
      </tags>
  </entry>
  <entry>
    <title>代码随想录(day10)</title>
    <url>/link/suixiangluday10.html</url>
    <content><![CDATA[<blockquote>
<p>刷题参考：<a href="https://www.programmercarl.com/">代码随想录 (programmercarl.com)</a></p>
<p>题目来源：<a href="https://leetcode.cn/problems/binary-search">力扣（LeetCode）</a></p>
</blockquote>
<h1 id="Day-10：回溯算法（后篇）"><a href="#Day-10：回溯算法（后篇）" class="headerlink" title="Day 10：回溯算法（后篇）"></a>Day 10：回溯算法（后篇）</h1><h2 id="491-递增子序列"><a href="#491-递增子序列" class="headerlink" title="491. 递增子序列"></a><a href="https://leetcode.cn/problems/non-decreasing-subsequences/">491. 递增子序列</a></h2><blockquote>
<p>给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。你可以按 任意顺序 返回答案。</p>
<p>数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。</p>
<p>示例 1：</p>
<p>输入：nums = [4,6,7,7]<br>输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]<br>示例 2：</p>
<p>输入：nums = [4,4,3,2,1]<br>输出：[[4,4]]</p>
<p>提示：</p>
<p>1 &lt;= nums.length &lt;= 15<br>-100 &lt;= nums[i] &lt;= 100</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 题目中最少两个元素，需要判定数组的长度是否大于1</span></span><br><span class="line"><span class="comment">// 对相同元素需要去重，可以使用used数组，也可以使用set进行去重</span></span><br><span class="line"><span class="comment">// used数组节约内存和时间，set更好理解</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> left)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp.<span class="built_in">size</span>()&gt;<span class="number">1</span>) res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        <span class="keyword">if</span>(left&gt;=nums.<span class="built_in">size</span>())<span class="keyword">return</span>;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; uset;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=left;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (uset.<span class="built_in">find</span>(nums[i]) != uset.<span class="built_in">end</span>()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(temp.<span class="built_in">empty</span>()||nums[i]&gt;=temp.<span class="built_in">back</span>())&#123;</span><br><span class="line">                uset.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">                temp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                <span class="built_in">backtracking</span>(nums,i+<span class="number">1</span>);</span><br><span class="line">                temp.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">findSubsequences</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode.cn/problems/permutations/">46. 全排列</a></h2><blockquote>
<p>给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。</p>
<p>示例 1：</p>
<p>输入：nums = [1,2,3]<br>输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]<br>示例 2：</p>
<p>输入：nums = [0,1]<br>输出：[[0,1],[1,0]]<br>示例 3：</p>
<p>输入：nums = [1]<br>输出：[[1]]</p>
<p>提示：</p>
<p>1 &lt;= nums.length &lt;= 6<br>-10 &lt;= nums[i] &lt;= 10<br>nums 中的所有整数 互不相同</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 任意顺序的全排列，可以使用hash表记录元素有没有被使用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,unordered_map&lt;<span class="type">int</span>, <span class="type">bool</span>&gt; &amp;hash)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp.<span class="built_in">size</span>()==nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash[i])&#123;</span><br><span class="line">                hash[i]=<span class="literal">false</span>;</span><br><span class="line">                temp.<span class="built_in">push_back</span>(i);</span><br><span class="line">                <span class="built_in">backtracking</span>(nums,hash);</span><br><span class="line">                hash[i]=<span class="literal">true</span>;</span><br><span class="line">                temp.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">bool</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i:nums) hash[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">backtracking</span>(nums,hash);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 也可以用used数组进行记录使用情况，这种情况下需要对数组进行排序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,vector&lt;<span class="type">bool</span>&gt; &amp;used)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp.<span class="built_in">size</span>()==nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(used[i]==<span class="literal">false</span>)&#123;</span><br><span class="line">                used[i]=<span class="literal">true</span>;</span><br><span class="line">                temp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                <span class="built_in">backtracking</span>(nums,used);</span><br><span class="line">                used[i]=<span class="literal">false</span>;</span><br><span class="line">                temp.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">used</span><span class="params">(nums.size(),<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">backtracking</span>(nums,used);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47. 全排列 II"></a><a href="https://leetcode.cn/problems/permutations-ii/">47. 全排列 II</a></h2><blockquote>
<p>给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。</p>
<p>示例 1：</p>
<p>输入：nums = [1,1,2]<br>输出：<br>[[1,1,2],<br> [1,2,1],<br> [2,1,1]]<br>示例 2：</p>
<p>输入：nums = [1,2,3]<br>输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</p>
<p>提示：</p>
<p>1 &lt;= nums.length &lt;= 8<br>-10 &lt;= nums[i] &lt;= 10</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 与上题不同的是数组里有重复元素，使用hash表对元素个数进行计数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &amp;hash)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp.<span class="built_in">size</span>()==nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mp.<span class="built_in">find</span>(i)!=mp.<span class="built_in">end</span>()) <span class="keyword">continue</span>; </span><br><span class="line">            <span class="keyword">if</span>(hash[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                hash[i]--;</span><br><span class="line">                temp.<span class="built_in">push_back</span>(i);</span><br><span class="line">                mp.<span class="built_in">insert</span>(i);</span><br><span class="line">                <span class="built_in">backtracking</span>(nums,hash);</span><br><span class="line">                hash[i]++;</span><br><span class="line">                temp.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i:nums) hash[i] = hash[i]?hash[i]+<span class="number">1</span>:<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">backtracking</span>(nums,hash);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 使用used数组能够同时满足作为使用数组以及层间去重的作用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,vector&lt;<span class="type">bool</span>&gt; &amp;used)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp.<span class="built_in">size</span>()==nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i<span class="number">-1</span>]&amp;&amp;used[i<span class="number">-1</span>]==<span class="literal">false</span>) <span class="keyword">continue</span>; </span><br><span class="line">            <span class="keyword">if</span>(used[i]==<span class="literal">false</span>)&#123;</span><br><span class="line">                used[i]=<span class="literal">true</span>;</span><br><span class="line">                temp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                <span class="built_in">backtracking</span>(nums,used);</span><br><span class="line">                used[i]=<span class="literal">false</span>;</span><br><span class="line">                temp.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">used</span><span class="params">(nums.size(),<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">backtracking</span>(nums,used);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="332-重新安排行程"><a href="#332-重新安排行程" class="headerlink" title="332. 重新安排行程"></a><a href="https://leetcode.cn/problems/reconstruct-itinerary/">332. 重新安排行程</a></h2><blockquote>
<p>给你一份航线列表 tickets ，其中 tickets[i] = [fromi, toi] 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。</p>
<p>所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。</p>
<p>例如，行程 [“JFK”, “LGA”] 与 [“JFK”, “LGB”] 相比就更小，排序更靠前。<br>假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。</p>
<p>示例 1：</p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202307061150721.jpeg" alt="img"></p>
<p>输入：tickets = [[“MUC”,”LHR”],[“JFK”,”MUC”],[“SFO”,”SJC”],[“LHR”,”SFO”]]<br>输出：[“JFK”,”MUC”,”LHR”,”SFO”,”SJC”]<br>示例 2：</p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202307061150365.jpeg" alt="img"></p>
<p>输入：tickets = [[“JFK”,”SFO”],[“JFK”,”ATL”],[“SFO”,”ATL”],[“ATL”,”JFK”],[“ATL”,”SFO”]]<br>输出：[“JFK”,”ATL”,”JFK”,”SFO”,”ATL”,”SFO”]<br>解释：另一种有效的行程是 [“JFK”,”SFO”,”ATL”,”JFK”,”ATL”,”SFO”] ，但是它字典排序更大更靠后。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接做不进行剪枝的话是直接超时的，同样使用used数组记录车票的使用情况</span></span><br><span class="line"><span class="comment">// 由于车票有重复的，所以也要对开始的数组进行排序</span></span><br><span class="line"><span class="comment">// sort的默认方式就是字典排序，先排序后即满足要求</span></span><br><span class="line"><span class="comment">// 得到第一种结果后，后序的结果都不需要</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">    vector&lt;string&gt; temp;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets,vector&lt;<span class="type">bool</span>&gt; &amp;used)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp.<span class="built_in">size</span>()==tickets.<span class="built_in">size</span>()+<span class="number">1</span>)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tickets.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(used[i]==<span class="literal">true</span>||(i&gt;<span class="number">0</span>&amp;&amp;tickets[i]==tickets[i<span class="number">-1</span>]&amp;&amp;used[i<span class="number">-1</span>]==<span class="literal">false</span>)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(tickets[i][<span class="number">0</span>]==temp.<span class="built_in">back</span>())&#123;</span><br><span class="line">                used[i] = <span class="literal">true</span>;</span><br><span class="line">                temp.<span class="built_in">push_back</span>(tickets[i][<span class="number">1</span>]);</span><br><span class="line">                <span class="built_in">backtracking</span>(tickets,used);</span><br><span class="line">                <span class="keyword">if</span>(res.<span class="built_in">size</span>()==<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">                used[i] = <span class="literal">false</span>;</span><br><span class="line">                temp.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findItinerary</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">used</span><span class="params">(tickets.size(),<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="built_in">sort</span>(tickets.<span class="built_in">begin</span>(),tickets.<span class="built_in">end</span>());</span><br><span class="line">        temp.<span class="built_in">push_back</span>(<span class="string">&quot;JFK&quot;</span>);</span><br><span class="line">        <span class="built_in">backtracking</span>(tickets,used);</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 以下是随想录的代码答案</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// unordered_map&lt;出发机场, map&lt;到达机场, 航班次数&gt;&gt; targets</span></span><br><span class="line">unordered_map&lt;string, map&lt;string, <span class="type">int</span>&gt;&gt; targets;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> ticketNum, vector&lt;string&gt;&amp; result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (result.<span class="built_in">size</span>() == ticketNum + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (pair&lt;<span class="type">const</span> string, <span class="type">int</span>&gt;&amp; target : targets[result[result.<span class="built_in">size</span>() - <span class="number">1</span>]]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (target.second &gt; <span class="number">0</span> ) &#123; <span class="comment">// 记录到达机场是否飞过了</span></span><br><span class="line">            result.<span class="built_in">push_back</span>(target.first);</span><br><span class="line">            target.second--;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">backtracking</span>(ticketNum, result)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            result.<span class="built_in">pop_back</span>();</span><br><span class="line">            target.second++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findItinerary</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span> </span>&#123;</span><br><span class="line">        targets.<span class="built_in">clear</span>();</span><br><span class="line">        vector&lt;string&gt; result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> vector&lt;string&gt;&amp; vec : tickets) &#123;</span><br><span class="line">            targets[vec[<span class="number">0</span>]][vec[<span class="number">1</span>]]++; <span class="comment">// 记录映射关系</span></span><br><span class="line">        &#125;</span><br><span class="line">        result.<span class="built_in">push_back</span>(<span class="string">&quot;JFK&quot;</span>); <span class="comment">// 起始机场</span></span><br><span class="line">        <span class="built_in">backtracking</span>(tickets.<span class="built_in">size</span>(), result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 哈希表键为出发机场，值使用了有序的字典，直接对键进行排序，键为到达机场，值为次数</span></span><br><span class="line"><span class="comment">// 相比上面的方法，少了每次循环遍历的次数，只需要循环每个键对应的map</span></span><br><span class="line"><span class="comment">// 使用bool的返回值，记录返回值，如果有一次满足了条件，就不会再进行接下来的回溯</span></span><br></pre></td></tr></table></figure>
<h2 id="51-N-皇后"><a href="#51-N-皇后" class="headerlink" title="51. N 皇后"></a><a href="https://leetcode.cn/problems/n-queens/">51. N 皇后</a></h2><blockquote>
<p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。</p>
<p>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p>给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。</p>
<p>每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p>
<p> <img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202307061528887.jpeg" alt="img"></p>
<p>示例 1：</p>
<p>输入：n = 4<br>输出：[[“.Q..”,”…Q”,”Q…”,”..Q.”],[“..Q.”,”Q…”,”…Q”,”.Q..”]]<br>解释：如上图所示，4 皇后问题存在两个不同的解法。<br>示例 2：</p>
<p>输入：n = 1<br>输出：[[“Q”]]</p>
<p>提示：</p>
<p>1 &lt;= n &lt;= 9</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该题的思路，主要是针对于是否符合条件的判断</span></span><br><span class="line"><span class="comment">// 先创建一个mask矩阵，记录每个点能否放皇后</span></span><br><span class="line"><span class="comment">// 每一层放下皇后后更新mask矩阵</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">    vector&lt;string&gt; temp;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; mask;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> layernum,vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; &amp;mask)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(layernum==n)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(layernum==<span class="number">0</span>||mask[layernum][i]==<span class="literal">false</span>)&#123;</span><br><span class="line">                vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; cur=mask;</span><br><span class="line">                temp[layernum][i]=<span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=layernum+<span class="number">1</span>;j&lt;n;j++) &#123;</span><br><span class="line">                    mask[j][i]=<span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span>(i+j-layernum&lt;n) mask[j][i+j-layernum]=<span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span>(i-j+layernum&gt;=<span class="number">0</span>) mask[j][i-j+layernum]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">backtracking</span>(n,layernum+<span class="number">1</span>,mask);</span><br><span class="line">                temp[layernum][i]=<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                mask=cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        temp=<span class="built_in">vector</span>&lt;string&gt;(n,<span class="built_in">string</span>(n,<span class="string">&#x27;.&#x27;</span>));</span><br><span class="line">        mask = vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;(n,<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n,<span class="literal">false</span>));</span><br><span class="line">        <span class="built_in">backtracking</span>(n,<span class="number">0</span>,mask);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 可以不使用mask矩阵，直接使用一个函数来判断能否放值</span></span><br><span class="line"><span class="comment">// 经过修改后时间和空间都得到了很大的优化，</span></span><br><span class="line"><span class="comment">// 猜测原因是mask矩阵的复原与修改耗费了时间和空间</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">    vector&lt;string&gt; temp;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; mask;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> layernum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(layernum==n)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(layernum==<span class="number">0</span>||<span class="built_in">isValid</span>(layernum,i, temp,n))&#123;</span><br><span class="line">                temp[layernum][i]=<span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">                <span class="built_in">backtracking</span>(n,layernum+<span class="number">1</span>);</span><br><span class="line">                temp[layernum][i]=<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col, vector&lt;string&gt;&amp; chessboard, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检查列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123; <span class="comment">// 这是一个剪枝</span></span><br><span class="line">            <span class="keyword">if</span> (chessboard[i][col] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查 45度角是否有皇后</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;=<span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chessboard[i][j] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查 135度角是否有皇后</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chessboard[i][j] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        temp=<span class="built_in">vector</span>&lt;string&gt;(n,<span class="built_in">string</span>(n,<span class="string">&#x27;.&#x27;</span>));</span><br><span class="line">        <span class="built_in">backtracking</span>(n,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="37-解数独"><a href="#37-解数独" class="headerlink" title="37. 解数独"></a><a href="https://leetcode.cn/problems/sudoku-solver/">37. 解数独</a></h2><blockquote>
<p>编写一个程序，通过填充空格来解决数独问题。</p>
<p>数独的解法需 遵循如下规则：</p>
<p>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）<br>数独部分空格内已填入了数字，空白格用 ‘.’ 表示。</p>
<p> <img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202307061611739.png" alt="img"></p>
<p>示例 1：</p>
<p>输入：board = [[“5”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”],[“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”],[“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”],[“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”],[“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”],[“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”],[“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”],[“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”],[“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”]]<br>输出：[[“5”,”3”,”4”,”6”,”7”,”8”,”9”,”1”,”2”],[“6”,”7”,”2”,”1”,”9”,”5”,”3”,”4”,”8”],[“1”,”9”,”8”,”3”,”4”,”2”,”5”,”6”,”7”],[“8”,”5”,”9”,”7”,”6”,”1”,”4”,”2”,”3”],[“4”,”2”,”6”,”8”,”5”,”3”,”7”,”9”,”1”],[“7”,”1”,”3”,”9”,”2”,”4”,”8”,”5”,”6”],[“9”,”6”,”1”,”5”,”3”,”7”,”2”,”8”,”4”],[“2”,”8”,”7”,”4”,”1”,”9”,”6”,”3”,”5”],[“3”,”4”,”5”,”2”,”8”,”6”,”1”,”7”,”9”]]<br>解释：输入的数独如上图所示，唯一有效的解决方案如下所示：</p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202307061611461.png" alt="img"></p>
<p>提示：</p>
<p>board.length == 9<br>board[i].length == 9<br>board[i][j] 是一位数字或者 ‘.’<br>题目数据 保证 输入数独仅有一个解</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该题存在唯一解，所以可以设置回溯函数的返回值为bool型，可以在首次搜索到答案就停止回溯</span></span><br><span class="line"><span class="comment">// 解数独问题与n皇后不同的是，每个点存在9个取值，需要考虑遍历一个二维的矩阵</span></span><br><span class="line"><span class="comment">// 所以先取数独中的位置需要两层循环，再取可能的取值需要一层循环</span></span><br><span class="line"><span class="comment">// 判断如果没有填写数组中的值为&#x27;.&#x27;，每次循环都需要判断填入值是否满足条件</span></span><br><span class="line"><span class="comment">// 如果循环结束的话也就是空格都填满了，这时候得到唯一解，返回true，回溯结束</span></span><br><span class="line"><span class="comment">// 如果有空位所有的值都不能填上，那么说明解数独失败，返回false</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">backtracking</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> layer=<span class="number">0</span>;layer&lt;<span class="number">9</span>;layer++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[layer][i]==<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">char</span> j=<span class="string">&#x27;1&#x27;</span>;j&lt;=<span class="string">&#x27;9&#x27;</span>;j++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(<span class="built_in">isValid</span>(layer,i,board,j))&#123;</span><br><span class="line">                            board[layer][i]=j;</span><br><span class="line">                            <span class="keyword">if</span>(<span class="built_in">backtracking</span>(board)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                            board[layer][i]=<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(<span class="type">int</span> layer, <span class="type">int</span> index, vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board,<span class="type">char</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123; </span><br><span class="line">            <span class="keyword">if</span> (board[layer][i] == num) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (board[i][index] == num) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> x = layer/<span class="number">3</span>,y = index/<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> lx = x*<span class="number">3</span>; lx &lt; x*<span class="number">3</span>+<span class="number">3</span>; lx++) &#123; </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> ly = y*<span class="number">3</span>; ly &lt; y*<span class="number">3</span>+<span class="number">3</span>; ly++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (board[lx][ly] == num) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solveSudoku</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(board);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>除了使用used数组，还可以使用set进行去重，但是效率不如使用used数组快，尤其是全排列问题时，使用hash表要比使用used效率低，注意，全排列问题使用used需要先对数组进行排序。</p>
<p>重新安排行程中，使用哈希字典和有序字典的结合，记录机票，减少了循环的集合中的元素个数，提升代码的效率，当问题存在唯一解时，回溯可以返回bool型变量，方便判断是否达成条件，及时终止回溯。</p>
<p>n皇后问题算是一个一维的回溯问题，只需要遍历层，循环的集合是列的index，解数独是一个二维的回溯问题，不但需要遍历层，还需要遍历列，循环遍历的集合是1-9的数值，另外需要判断是否满足题目要求的条件，终止条件的判断也很重要。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++算法</tag>
      </tags>
  </entry>
  <entry>
    <title>代码随想录(day9)</title>
    <url>/link/suixiangluday9.html</url>
    <content><![CDATA[<blockquote>
<p>刷题参考：<a href="https://www.programmercarl.com/">代码随想录 (programmercarl.com)</a></p>
<p>题目来源：<a href="https://leetcode.cn/problems/binary-search">力扣（LeetCode）</a></p>
</blockquote>
<h1 id="Day-9：回溯算法（前篇）"><a href="#Day-9：回溯算法（前篇）" class="headerlink" title="Day 9：回溯算法（前篇）"></a>Day 9：回溯算法（前篇）</h1><h2 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h2><p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202307051821791.png" alt="回溯算法大纲"></p>
<p>回溯算法，基础是一个递归函数，为了实现回溯，需要在递归过程中对一些已经实现的操作进行撤回。</p>
<p>回溯算法的本质是穷举，并不是个高效的算法。</p>
<p><strong>回溯法解决的问题都可以抽象为树形结构，回溯法解决的问题都是在集合中递归查找子集，集合的大小就是树的宽度，递归的深度就是树的深度，递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。</strong></p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202307051826462.png" alt="回溯算法理论基础"></p>
<p><strong>for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历</strong></p>
<ul>
<li><p>回溯函数的返回值一般为void，参数一般很难一下子都确定下来，一般先写逻辑，需要什么参数，填写什么参数。</p>
</li>
<li><p>回溯要有终止条件，一般来讲抽象树的叶子节点对应的条件就是终止条件。</p>
</li>
<li>回溯中对节点的处理和节点的恢复</li>
</ul>
<p>总结以上步骤，回溯算法的模板框架如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(参数)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        <span class="built_in">backtracking</span>(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a><a href="https://leetcode.cn/problems/combinations/">77. 组合</a></h2><blockquote>
<p>给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。</p>
<p>你可以按 任何顺序 返回答案。</p>
<p>示例 1：</p>
<p>输入：n = 4, k = 2<br>输出：<br>[<br>  [2,4],<br>  [3,4],<br>  [2,3],<br>  [1,2],<br>  [1,3],<br>  [1,4],<br>]<br>示例 2：</p>
<p>输入：n = 1, k = 1<br>输出：[[1]]</p>
<p>提示：</p>
<p>1 &lt;= n &lt;= 20<br>1 &lt;= k &lt;= n</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该题为组合问题，先写回溯模板</span></span><br><span class="line"><span class="comment">// 确定递归条件，数组的大小等于k就记录当前数组然后return</span></span><br><span class="line"><span class="comment">// for循环从1到n，下次的循环从这次循环的节点的下一个开始</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> k,<span class="type">int</span> cur,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;res,vector&lt;<span class="type">int</span>&gt; temp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp.<span class="built_in">size</span>()==k)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(;cur&lt;=n;cur++)&#123;</span><br><span class="line">            temp.<span class="built_in">push_back</span>(cur);</span><br><span class="line">            <span class="built_in">backtracking</span>(n, k, cur+<span class="number">1</span>, res, temp);</span><br><span class="line">            temp.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">        <span class="type">int</span> cur=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">backtracking</span>(n,k,cur,res,temp);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 运行时间420ms, 占用空间160.2MB</span></span><br><span class="line"><span class="comment">// 以上代码可以优化的地方，一直传递的引用res和temp可以作为变量提取出来，减少空间使用</span></span><br><span class="line"><span class="comment">// 针对题目进行剪枝，当循环到剩下的数组元素不足以凑齐k个时，不需要再进行循环，减少时间使用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> k,<span class="type">int</span> cur,<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp.<span class="built_in">size</span>()==k)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(;cur&lt;=n-num;cur++)&#123;</span><br><span class="line">            temp.<span class="built_in">push_back</span>(cur);</span><br><span class="line">            <span class="built_in">backtracking</span>(n, k, cur+<span class="number">1</span>,num<span class="number">-1</span>);</span><br><span class="line">            temp.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">int</span> cur=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">backtracking</span>(n,k,cur,k<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 运行时间8ms，占用空间9.6MB</span></span><br></pre></td></tr></table></figure>
<h2 id="216-组合总和-III"><a href="#216-组合总和-III" class="headerlink" title="216. 组合总和 III"></a><a href="https://leetcode.cn/problems/combination-sum-iii/">216. 组合总和 III</a></h2><blockquote>
<p>找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：</p>
<p>只使用数字1到9<br>每个数字 最多使用一次<br>返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p>
<p>示例 1:</p>
<p>输入: k = 3, n = 7<br>输出: [[1,2,4]]<br>解释:<br>1 + 2 + 4 = 7<br>没有其他符合的组合了。<br>示例 2:</p>
<p>输入: k = 3, n = 9<br>输出: [[1,2,6], [1,3,5], [2,3,4]]<br>解释:<br>1 + 2 + 6 = 9<br>1 + 3 + 5 = 9<br>2 + 3 + 4 = 9<br>没有其他符合的组合了。<br>示例 3:</p>
<p>输入: k = 4, n = 1<br>输出: []<br>解释: 不存在有效的组合。<br>在[1,9]范围内使用4个不同的数字，我们可以得到的最小和是1+2+3+4 = 10，因为10 &gt; 1，没有有效的组合。</p>
<p>提示:</p>
<p>2 &lt;= k &lt;= 9<br>1 &lt;= n &lt;= 60</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 与上面的差别不大，需要计算和</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> k, <span class="type">int</span> num,<span class="type">int</span> n,<span class="type">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum==n&amp;&amp;temp.<span class="built_in">size</span>()==k)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;n||temp.<span class="built_in">size</span>()&gt;=k) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(;start&lt;<span class="number">10</span>-num;start++)&#123;</span><br><span class="line">            temp.<span class="built_in">push_back</span>(start);</span><br><span class="line">            <span class="built_in">backtracking</span>(start+<span class="number">1</span>,k,num<span class="number">-1</span>,n,sum+start);</span><br><span class="line">            temp.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(<span class="number">1</span>,k,k<span class="number">-1</span>,n,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h2><blockquote>
<p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202307051903543.png" alt="img"></p>
<p>示例 1：</p>
<p>输入：digits = “23”<br>输出：[“ad”,”ae”,”af”,”bd”,”be”,”bf”,”cd”,”ce”,”cf”]<br>示例 2：</p>
<p>输入：digits = “”<br>输出：[]<br>示例 3：</p>
<p>输入：digits = “2”<br>输出：[“a”,”b”,”c”]</p>
<p>提示：</p>
<p>0 &lt;= digits.length &lt;= 4<br>digits[i] 是范围 [‘2’, ‘9’] 的一个数字。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该题基本与上题相似，但需要判断按键对应的数字，特别注意7，9对应的字母个数为4</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    string temp;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(string digits,<span class="type">int</span> nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp.<span class="built_in">size</span>()==digits.<span class="built_in">size</span>())&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> key = digits[nums]-<span class="string">&#x27;0&#x27;</span>==<span class="number">7</span>||digits[nums]-<span class="string">&#x27;0&#x27;</span>==<span class="number">9</span>?<span class="number">4</span>:<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;key;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(digits[nums]-<span class="string">&#x27;0&#x27;</span>==<span class="number">8</span>||digits[nums]-<span class="string">&#x27;0&#x27;</span>==<span class="number">9</span>) temp += (<span class="type">char</span>)(<span class="string">&#x27;a&#x27;</span>+(digits[nums]-<span class="string">&#x27;0&#x27;</span><span class="number">-2</span>)*<span class="number">3</span>+<span class="number">1</span>+i);</span><br><span class="line">            <span class="keyword">else</span> temp += (<span class="type">char</span>)(<span class="string">&#x27;a&#x27;</span>+(digits[nums]-<span class="string">&#x27;0&#x27;</span><span class="number">-2</span>)*<span class="number">3</span>+i);        </span><br><span class="line">            <span class="built_in">backtracking</span>(digits,nums+<span class="number">1</span>);</span><br><span class="line">            temp.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">backtracking</span>(digits,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></h2><blockquote>
<p>给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。</p>
<p>candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p>
<p>对于给定的输入，保证和为 target 的不同组合数少于 150 个。</p>
<p>示例 1：</p>
<p>输入：candidates = [2,3,6,7], target = 7<br>输出：[[2,2,3],[7]]<br>解释：<br>2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。<br>7 也是一个候选， 7 = 7 。<br>仅有这两种组合。<br>示例 2：</p>
<p>输入: candidates = [2,3,5], target = 8<br>输出: [[2,2,2,2],[2,3,3],[3,5]]<br>示例 3：</p>
<p>输入: candidates = [2], target = 1<br>输出: []</p>
<p>提示：</p>
<p>1 &lt;= candidates.length &lt;= 30<br>2 &lt;= candidates[i] &lt;= 40<br>candidates 的所有元素 互不相同<br>1 &lt;= target &lt;= 40</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需要判断是否和等于给定值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target,<span class="type">int</span> sum,<span class="type">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum==target)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;target) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=key;i&lt;candidates.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            temp.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(candidates, target,sum+candidates[i],i);</span><br><span class="line">            temp.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(candidates, target,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 如果数组很大，可能需要先对数组进行排序，</span></span><br><span class="line"><span class="comment">// 这样当sum值大于给定值时，后续的就不用再判断</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target,<span class="type">int</span> sum,<span class="type">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum==target)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=key;i&lt;candidates.<span class="built_in">size</span>()&amp;&amp; sum+candidates[i]&lt;= target;i++)&#123;</span><br><span class="line">            temp.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(candidates, target,sum+candidates[i],i);</span><br><span class="line">            temp.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">backtracking</span>(candidates, target,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a><a href="https://leetcode.cn/problems/combination-sum-ii/">40. 组合总和 II</a></h2><blockquote>
<p>给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的每个数字在每个组合中只能使用 一次 。</p>
<p>注意：解集不能包含重复的组合。 </p>
<p>示例 1:</p>
<p>输入: candidates = [10,1,2,7,6,1,5], target = 8,<br>输出:<br>[<br>[1,1,6],<br>[1,2,5],<br>[1,7],<br>[2,6]<br>]<br>示例 2:</p>
<p>输入: candidates = [2,5,2,1,2], target = 5,<br>输出:<br>[<br>[1,2,2],<br>[5]<br>]</p>
<p>提示:</p>
<p>1 &lt;= candidates.length &lt;= 100<br>1 &lt;= candidates[i] &lt;= 50<br>1 &lt;= target &lt;= 30</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这道题与之前题目不同的是，存在有相同元素的去重问题</span></span><br><span class="line"><span class="comment">// 回溯问题本身很抽象，所以直接看题解了</span></span><br><span class="line"><span class="comment">// 根据横向for遍历和纵向的递归遍历看，去重问题是存在于层间的</span></span><br><span class="line"><span class="comment">// 创建一个used数组，记录这一层之中哪些元素使用过</span></span><br><span class="line"><span class="comment">// 如果说当前元素与前一个元素相等，并且前一元素未使用</span></span><br><span class="line"><span class="comment">// 前一元素和当前元素相等，如果没使用，说明该元素是第二次处于相同位置了</span></span><br><span class="line"><span class="comment">// 这样的话跳过本次循环</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target,<span class="type">int</span> key,vector&lt;<span class="type">bool</span>&gt; used)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=key;i&lt;candidates.<span class="built_in">size</span>()&amp;&amp;  target-candidates[i]&gt;=<span class="number">0</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;candidates[i]==candidates[i<span class="number">-1</span>]&amp;&amp;used[i<span class="number">-1</span>]==<span class="literal">false</span>) <span class="keyword">continue</span>;</span><br><span class="line">            temp.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">backtracking</span>(candidates, target-candidates[i],i+<span class="number">1</span>,used);</span><br><span class="line">            temp.<span class="built_in">pop_back</span>();</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">used</span><span class="params">(candidates.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">backtracking</span>(candidates, target,<span class="number">0</span>,used);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 之前使用额外的变量sum，现在使用target，一方面是减少变量使用，一方面是可以防止数值越界</span></span><br></pre></td></tr></table></figure>
<h2 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131. 分割回文串"></a><a href="https://leetcode.cn/problems/palindrome-partitioning/">131. 分割回文串</a></h2><blockquote>
<p>给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。</p>
<p>回文串 是正着读和反着读都一样的字符串。</p>
<p>示例 1：</p>
<p>输入：s = “aab”<br>输出：[[“a”,”a”,”b”],[“aa”,”b”]]<br>示例 2：</p>
<p>输入：s = “a”<br>输出：[[“a”]]</p>
<p>提示：</p>
<p>1 &lt;= s.length &lt;= 16<br>s 仅由小写英文字母组成</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 回溯的循环中额外加入回文串的判断，终止条件就是遍历到头</span></span><br><span class="line"><span class="comment">// 还是挺抽象的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">    vector&lt;string&gt; vstr;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(string temp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> left=<span class="number">0</span>,right=temp.<span class="built_in">size</span>()<span class="number">-1</span>;left&lt;right;left++,right--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp[left]!=temp[right]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(string s,<span class="type">int</span> left,string temp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left==s.<span class="built_in">size</span>()) res.<span class="built_in">push_back</span>(vstr);</span><br><span class="line">        temp.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(;left&lt;s.<span class="built_in">size</span>();left++)&#123;</span><br><span class="line">            temp += s[left];</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isPalindrome</span>(temp))&#123;</span><br><span class="line">                vstr.<span class="built_in">push_back</span>(temp);</span><br><span class="line">                <span class="built_in">backtracking</span>(s,left+<span class="number">1</span>,temp);</span><br><span class="line">                vstr.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">partition</span>(string s) &#123;</span><br><span class="line">        string temp;</span><br><span class="line">        <span class="built_in">backtracking</span>(s,<span class="number">0</span>,temp);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 以上代码中string可以直接用切片操作替换</span></span><br><span class="line"><span class="comment">// 相应的回文串判断也需要修改</span></span><br><span class="line"><span class="comment">// 从切分的角度去理解题目，会更直观</span></span><br><span class="line"><span class="comment">// 注意：字符串切分时的参数是，起始位置和切分长度</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">    vector&lt;string&gt; vstr;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">const</span> string &amp;temp,<span class="type">int</span> left,<span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(;left&lt;right;left++,right--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp[left]!=temp[right]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">const</span> string &amp;s,<span class="type">int</span> left)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left==s.<span class="built_in">size</span>()) res.<span class="built_in">push_back</span>(vstr);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> right=left;right&lt;s.<span class="built_in">size</span>();right++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isPalindrome</span>(s,left,right))&#123;</span><br><span class="line">                vstr.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(left, right-left+<span class="number">1</span>));</span><br><span class="line">                <span class="built_in">backtracking</span>(s,right+<span class="number">1</span>);</span><br><span class="line">                vstr.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">partition</span>(<span class="type">const</span> string &amp;s) &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(s,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="93-复原-IP-地址"><a href="#93-复原-IP-地址" class="headerlink" title="93. 复原 IP 地址"></a><a href="https://leetcode.cn/problems/restore-ip-addresses/">93. 复原 IP 地址</a></h2><blockquote>
<p>有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。</p>
<p>例如：”0.1.2.201” 和 “192.168.1.1” 是 有效 IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “192.168@1.1” 是 无效 IP 地址。<br>给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 ‘.’ 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。</p>
<p>示例 1：</p>
<p>输入：s = “25525511135”<br>输出：[“255.255.11.135”,”255.255.111.35”]<br>示例 2：</p>
<p>输入：s = “0000”<br>输出：[“0.0.0.0”]<br>示例 3：</p>
<p>输入：s = “101023”<br>输出：[“1.0.10.23”,”1.0.102.3”,”10.1.0.23”,”10.10.2.3”,”101.0.2.3”]</p>
<p>提示：</p>
<ul>
<li>1 &lt;= s.length &lt;= 20</li>
<li>s 仅由数字组成</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这道题的终止条件：遍历到头了或者分割超过了四段</span></span><br><span class="line"><span class="comment">// 保存条件为，输出到头，且等于四段</span></span><br><span class="line"><span class="comment">// 需要额外判断的是为0的时候的情况</span></span><br><span class="line"><span class="comment">// 如果存在&quot;01&quot;这种情况，那么直接break结束循环</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string temp;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">const</span> string &amp;s,<span class="type">int</span> left,<span class="type">int</span> ipnums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;=s.<span class="built_in">size</span>()&amp;&amp;ipnums==<span class="number">4</span>) res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        <span class="keyword">if</span>(ipnums==<span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">1</span>;len+left&lt;=s.<span class="built_in">size</span>();len++)&#123;</span><br><span class="line">            string sub = s.<span class="built_in">substr</span>(left, len);</span><br><span class="line">            <span class="keyword">if</span>(sub[<span class="number">0</span>]==<span class="string">&#x27;0&#x27;</span>&amp;&amp;sub.<span class="built_in">size</span>()&gt;<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="type">int</span> ip=<span class="built_in">atoi</span>(sub.<span class="built_in">c_str</span>());</span><br><span class="line">            <span class="keyword">if</span>(ip&lt;=<span class="number">255</span>&amp;&amp;ip&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                temp += sub;</span><br><span class="line">                <span class="keyword">if</span>(ipnums!=<span class="number">3</span>)temp += <span class="string">&quot;.&quot;</span>;</span><br><span class="line">                <span class="built_in">backtracking</span>(s, left+len, ipnums+<span class="number">1</span>);</span><br><span class="line">                temp = temp.<span class="built_in">substr</span>(<span class="number">0</span>,ipnums==<span class="number">3</span>?temp.<span class="built_in">size</span>()-len:temp.<span class="built_in">size</span>()-len<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">restoreIpAddresses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a><a href="https://leetcode.cn/problems/subsets/">78. 子集</a></h2><blockquote>
<p>给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。</p>
<p>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p>
<p>示例 1：</p>
<p>输入：nums = [1,2,3]<br>输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]<br>示例 2：</p>
<p>输入：nums = [0]<br>输出：[[],[0]]</p>
<p>提示：</p>
<p>1 &lt;= nums.length &lt;= 10<br>-10 &lt;= nums[i] &lt;= 10<br>nums 中的所有元素 互不相同</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子集的情况与组合情况不同，保存的时候，子集要保存所有节点</span></span><br><span class="line"><span class="comment">// 组合情况只需要在叶子节点保存</span></span><br><span class="line"><span class="comment">// 也就是不需要对保存的条件进行判断</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> left)</span></span>&#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        <span class="keyword">if</span>(left&gt;=nums.<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=left;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            temp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(nums,i+<span class="number">1</span>);</span><br><span class="line">            temp.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="90-子集-II"><a href="#90-子集-II" class="headerlink" title="90. 子集 II"></a><a href="https://leetcode.cn/problems/subsets-ii/">90. 子集 II</a></h2><blockquote>
<p>给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p>
<p>解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。</p>
<p>示例 1：</p>
<p>输入：nums = [1,2,2]<br>输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]<br>示例 2：</p>
<p>输入：nums = [0]<br>输出：[[],[0]]</p>
<p>提示：</p>
<p>1 &lt;= nums.length &lt;= 10<br>-10 &lt;= nums[i] &lt;= 10</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 和上一个不同的是，可能有重复元素，所以需要先对数组进行排序</span></span><br><span class="line"><span class="comment">// 和组合总和二中一样，是层间的去重，判断是否有重复情况</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> left,vector&lt;<span class="type">bool</span>&gt; pre)</span></span>&#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        <span class="keyword">if</span>(left&gt;=nums.<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=left;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i<span class="number">-1</span>]&amp;&amp;pre[i<span class="number">-1</span>]==<span class="literal">false</span>) <span class="keyword">continue</span>;</span><br><span class="line">            temp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            pre[i]=<span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">backtracking</span>(nums,i+<span class="number">1</span>,pre);</span><br><span class="line">            temp.<span class="built_in">pop_back</span>();</span><br><span class="line">            pre[i]=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">pre</span><span class="params">(nums.size(),<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">backtracking</span>(nums,<span class="number">0</span>,pre);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>主要是回溯的组合，分割以及子集问题，对模板的应用，还有对于类中的变量直接在类中定义能够减少空间的使用，分割主要是字符串问题，针对字符串问题，分割的思想比单独的一个词一个词的去看要直观很多，子集的问题和之前的问题都相差不大，主要是在保存最后结果时，一个是所有节点，一个是叶子节点，最后还需要针对具体问题，设置不同的循环条件。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++算法</tag>
      </tags>
  </entry>
  <entry>
    <title>代码随想录(day8)</title>
    <url>/link/suixiangluday8.html</url>
    <content><![CDATA[<blockquote>
<p>刷题参考：<a href="https://www.programmercarl.com/">代码随想录 (programmercarl.com)</a></p>
<p>题目来源：<a href="https://leetcode.cn/problems/binary-search">力扣（LeetCode）</a></p>
</blockquote>
<h1 id="Day-8：二叉树（后篇）"><a href="#Day-8：二叉树（后篇）" class="headerlink" title="Day 8：二叉树（后篇）"></a>Day 8：二叉树（后篇）</h1><h2 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h2><blockquote>
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>示例 1：</p>
<p>输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br>输出：3<br>解释：节点 5 和节点 1 的最近公共祖先是节点 3 。<br>示例 2：</p>
<p>输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4<br>输出：5<br>解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。<br>示例 3：</p>
<p>输入：root = [1,2], p = 1, q = 2<br>输出：1</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最近公共祖先，需要考虑的点比较多</span></span><br><span class="line"><span class="comment">// 首先，考虑公共祖先应该是后序遍历</span></span><br><span class="line"><span class="comment">// 确定递归结束条件：递归到叶子节点返回nullptr</span></span><br><span class="line"><span class="comment">// 递归到与给定节点相同的节点直接返回该节点</span></span><br><span class="line"><span class="comment">// 这时候意味着，假如说两个节点在一个根节点的左右子树上，</span></span><br><span class="line"><span class="comment">// 那么该根节点的左右子树都有不为nullptr的返回值</span></span><br><span class="line"><span class="comment">// 这时候找到了公共祖先，再往上返回时，返回公共祖先</span></span><br><span class="line"><span class="comment">// 当出现只有一边的子树有值时，返回的是有值的子树的返回值</span></span><br><span class="line"><span class="comment">// 这样到最后就能够得到结果</span></span><br><span class="line"><span class="comment">// 两个节点位置属于根节点和孩子节点的关系时，相当于提前找到了根节点回传</span></span><br><span class="line"><span class="comment">// 这是因为题目中所给的条件，两个节点必定存在</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(root==p||root==q) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode* left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left,p,q);</span><br><span class="line">        TreeNode* right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right,p,q);</span><br><span class="line">        <span class="keyword">if</span>(left&amp;&amp;right) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left==<span class="literal">nullptr</span>&amp;&amp;right==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left==<span class="literal">nullptr</span>) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235. 二叉搜索树的最近公共祖先"></a><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先</a></h2><blockquote>
<p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]</p>
<p>示例 1:</p>
<p>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8<br>输出: 6<br>解释: 节点 2 和节点 8 的最近公共祖先是 6。<br>示例 2:</p>
<p>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4<br>输出: 2<br>解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</p>
<p>说明:</p>
<p>所有节点的值都是唯一的。<br>p、q 为不同节点且均存在于给定的二叉搜索树中。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由于二叉搜索树的有序性，比较两个值的大小</span></span><br><span class="line"><span class="comment">// 当根节点比两个值都大的时候需要向左搜索</span></span><br><span class="line"><span class="comment">// 都小的时候向右搜索，其他情况，则根节点即为祖先节点</span></span><br><span class="line"><span class="comment">// 这是一个带条件的前序遍历</span></span><br><span class="line"><span class="comment">// 递归条件还是节点为nullptr返回nullptr，不过针对该题，必定存在，则不需要判断</span></span><br><span class="line"><span class="comment">// 只需要判断祖先节点返回即可</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;val&gt;q-&gt;val) <span class="built_in">swap</span>(p,q);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val&lt;p-&gt;val) <span class="keyword">return</span> <span class="built_in">lowestCommonAncestor</span>(root-&gt;right,p, q);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val&gt;q-&gt;val) <span class="keyword">return</span> <span class="built_in">lowestCommonAncestor</span>(root-&gt;left,p, q);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701. 二叉搜索树中的插入操作"></a><a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">701. 二叉搜索树中的插入操作</a></h2><blockquote>
<p>给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。</p>
<p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。</p>
<p>示例 1：</p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/05/insertbst.jpg" alt="img"></p>
<p>输入：root = [4,2,7,1,3], val = 5<br>输出：[4,2,7,1,3,5]<br>解释：另一个满足题目要求可以通过的树是：</p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/05/bst.jpg" alt="img"></p>
<p>示例 2：</p>
<p>输入：root = [40,20,60,10,30,50,70], val = 25<br>输出：[40,20,60,10,30,50,70,null,null,25]<br>示例 3：</p>
<p>输入：root = [4,2,7,1,3,null,null,null,null,null,null], val = 5<br>输出：[4,2,7,1,3,5]</p>
<p>提示：</p>
<p>树中的节点数将在 [0, 104]的范围内。<br>-108 &lt;= Node.val &lt;= 108<br>所有值 Node.val 是 独一无二 的。<br>-108 &lt;= val &lt;= 108<br>保证 val 在原始BST中不存在。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先，需要明确一个问题，插入的任何值都可以作为叶子节点插入</span></span><br><span class="line"><span class="comment">// 接下来，只需要判断给定值与节点值的大小关系，直到遍历到叶子节点</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* &amp;root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val&gt;val) <span class="built_in">insertIntoBST</span>(root-&gt;left,val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val&lt;val) <span class="built_in">insertIntoBST</span>(root-&gt;right,val);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450. 删除二叉搜索树中的节点"></a><a href="https://leetcode.cn/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a></h2><blockquote>
<p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p>
<p>一般来说，删除节点可分为两个步骤：</p>
<p>首先找到需要删除的节点；<br>如果找到了，删除它。</p>
<p>示例 1:</p>
<p><img src="https://assets.leetcode.com/uploads/2020/09/04/del_node_1.jpg" alt="img"></p>
<p>输入：root = [5,3,6,2,4,null,7], key = 3<br>输出：[5,4,6,2,null,null,7]<br>解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。<br>一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。<br>另一个正确答案是 [5,2,6,null,4,null,7]。</p>
<p><img src="https://assets.leetcode.com/uploads/2020/09/04/del_node_supp.jpg" alt="img"></p>
<p>示例 2:</p>
<p>输入: root = [5,3,6,2,4,null,7], key = 0<br>输出: [5,3,6,2,4,null,7]<br>解释: 二叉树不包含值为 0 的节点<br>示例 3:</p>
<p>输入: root = [], key = 0<br>输出: []</p>
<p>提示:</p>
<p>节点数的范围 [0, 104].<br>-105 &lt;= Node.val &lt;= 105<br>节点值唯一<br>root 是合法的二叉搜索树<br>-105 &lt;= key &lt;= 105</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先删除元素从上往下遍历，使用前序遍历</span></span><br><span class="line"><span class="comment">// 判断遍历的节点的情况：</span></span><br><span class="line"><span class="comment">// 如果遍历点不等于给定的值，继续遍历</span></span><br><span class="line"><span class="comment">// 如果遍历点等于给定值，判断一下几种情况</span></span><br><span class="line"><span class="comment">// 1.左右子树都不存在，叶子节点，直接删除</span></span><br><span class="line"><span class="comment">// 2.左右节点只有一个存在，存在的节点替位</span></span><br><span class="line"><span class="comment">// 3.左右节点都存在，这时候要将节点的左子树放到右子树的左下角，右子树替位节点</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* &amp;root, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val==key)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left==<span class="literal">nullptr</span>&amp;&amp;root-&gt;right==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span>) <span class="keyword">return</span> root-&gt;right;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;right == <span class="literal">nullptr</span>) <span class="keyword">return</span> root-&gt;left;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                TreeNode* temp=root-&gt;right;</span><br><span class="line">                <span class="keyword">while</span>(temp-&gt;left) temp = temp-&gt;left;</span><br><span class="line">                temp-&gt;left = root-&gt;left;</span><br><span class="line">                <span class="keyword">return</span> root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            root-&gt;left = <span class="built_in">deleteNode</span>(root-&gt;left,key);</span><br><span class="line">            root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right,key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="669-修剪二叉搜索树"><a href="#669-修剪二叉搜索树" class="headerlink" title="669. 修剪二叉搜索树"></a><a href="https://leetcode.cn/problems/trim-a-binary-search-tree/">669. 修剪二叉搜索树</a></h2><blockquote>
<p>给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树 不应该 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 唯一的答案 。</p>
<p>所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。</p>
<p>示例 1：</p>
<p><img src="https://assets.leetcode.com/uploads/2020/09/09/trim1.jpg" alt="img"></p>
<p>输入：root = [1,0,2], low = 1, high = 2<br>输出：[1,null,2]<br>示例 2：</p>
<p><img src="https://assets.leetcode.com/uploads/2020/09/09/trim2.jpg" alt="img"></p>
<p>输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3<br>输出：[3,2,null,1]</p>
<p>提示：</p>
<p>树中节点数在范围 [1, 104] 内<br>0 &lt;= Node.val &lt;= 104<br>树中每个节点的值都是 唯一 的<br>题目数据保证输入是一棵有效的二叉搜索树<br>0 &lt;= low &lt;= high &lt;= 104</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假如这是一个无序的，删除一个根节点后有两个节点需要安排</span></span><br><span class="line"><span class="comment">// 有序的树，删掉一个节点后，只需要安排一边的树即可</span></span><br><span class="line"><span class="comment">// 因为有序的树，当前节点不符合区间条件，有一边的子树也必然不符合条件</span></span><br><span class="line"><span class="comment">// 由于直接返回整个子树如果前序遍历，有可能会出现子树中也有不符合条件的值的存在</span></span><br><span class="line"><span class="comment">// 所以使用后序遍历</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">trimBST</span><span class="params">(TreeNode* root, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        root-&gt;left = <span class="built_in">trimBST</span>(root-&gt;left, low, high);</span><br><span class="line">        root-&gt;right = <span class="built_in">trimBST</span>(root-&gt;right, low, high);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val&lt;low) <span class="keyword">return</span> root-&gt;right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val&gt;high) <span class="keyword">return</span> root-&gt;left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108. 将有序数组转换为二叉搜索树"></a><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a></h2><blockquote>
<p>给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。</p>
<p>高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p>
<p>示例 1：</p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg" alt="img"></p>
<p>输入：nums = [-10,-3,0,5,9]<br>输出：[0,-3,9,-10,null,5]<br>解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：</p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree2.jpg" alt="img"></p>
<p>示例 2：</p>
<p>输入：nums = [1,3]<br>输出：[3,1]<br>解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。</p>
<p>提示：</p>
<p>1 &lt;= nums.length &lt;= 104<br>-104 &lt;= nums[i] &lt;= 104<br>nums 按 严格递增 顺序排列</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 因为数组是有序数组，搜索树是有序树</span></span><br><span class="line"><span class="comment">// 对应一下，数组中间值为根节点，左边为左子树，右边为右子树</span></span><br><span class="line"><span class="comment">// 二分递归，注意开闭区间的循环不变量，防止数组越界</span></span><br><span class="line"><span class="comment">// 采用左闭右开区间</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> left=<span class="number">0</span>,<span class="type">int</span> right=<span class="number">-1</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(right==<span class="number">-1</span>) right=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(left&gt;=right) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        TreeNode* root= <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[mid]);</span><br><span class="line">        root-&gt;left = <span class="built_in">sortedArrayToBST</span>(nums,left,mid);</span><br><span class="line">        root-&gt;right = <span class="built_in">sortedArrayToBST</span>(nums,mid+<span class="number">1</span>,right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="538. 把二叉搜索树转换为累加树"></a><a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树</a></h2><blockquote>
<p>给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。</p>
<p>提醒一下，二叉搜索树满足下列约束条件：</p>
<p>节点的左子树仅包含键 小于 节点键的节点。<br>节点的右子树仅包含键 大于 节点键的节点。<br>左右子树也必须是二叉搜索树。<br>注意：本题和 1038: <a href="https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/">https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/</a> 相同</p>
<p>示例 1：</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/05/03/tree.png" alt="img"></p>
<p>输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]<br>输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]<br>示例 2：</p>
<p>输入：root = [0,null,1]<br>输出：[1,null,1]<br>示例 3：</p>
<p>输入：root = [1,0,2]<br>输出：[3,3,2]<br>示例 4：</p>
<p>输入：root = [3,2,4,1]<br>输出：[7,9,4,10]</p>
<p>提示：</p>
<p>树中的节点数介于 0 和 104 之间。<br>每个节点的值介于 -104 和 104 之间。<br>树中的所有值 互不相同 。<br>给定的树为二叉搜索树。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 因为求的是大于某值的和，最大值在搜索树的最右边</span></span><br><span class="line"><span class="comment">// 所以采用，右中左的后续遍历，这样就是从大到小排序</span></span><br><span class="line"><span class="comment">// 计算逻辑在中的部分，累加后修改，设置一个全局变量sum来计算总和</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">convertBST</span>(root-&gt;right);</span><br><span class="line">        sum += root-&gt;val;</span><br><span class="line">        root-&gt;val = sum;</span><br><span class="line">        <span class="built_in">convertBST</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从公共祖先到搜索树的各种操作，重要的是明确问题需要的遍历顺序，前序遍历在前面返回，如果不是那种后面没有用的情况，要用后序遍历，这样才能保证所有节点都被遍历，有时需要额外的全局变量辅助信息的累加，或者指针的保存，结合中篇的内容，前序用来删除，插入等一次性操作，因为只需要找到需要操作的节点，不需要继续遍历，修剪，需要后序操作，需要对多个节点进行操作，能够遍历所有节点，不受树结构变化的影响，中序操作用来遍历搜索树。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++算法</tag>
      </tags>
  </entry>
  <entry>
    <title>代码随想录(day7)</title>
    <url>/link/suixiangluday7.html</url>
    <content><![CDATA[<blockquote>
<p>刷题参考：<a href="https://www.programmercarl.com/">代码随想录 (programmercarl.com)</a></p>
<p>题目来源：<a href="https://leetcode.cn/problems/binary-search">力扣（LeetCode）</a></p>
</blockquote>
<h1 id="Day-7：二叉树（中篇）"><a href="#Day-7：二叉树（中篇）" class="headerlink" title="Day 7：二叉树（中篇）"></a>Day 7：二叉树（中篇）</h1><h2 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404. 左叶子之和"></a><a href="https://leetcode.cn/problems/sum-of-left-leaves/">404. 左叶子之和</a></h2><blockquote>
<p>给定二叉树的根节点 root ，返回所有左叶子之和。</p>
<p>示例 1：</p>
<p>输入: root = [3,9,20,null,null,15,7]<br>输出: 24<br>解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24<br>示例 2:</p>
<p>输入: root = [1]<br>输出: 0</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前序遍历，使用递归并加入左右节点的判断</span></span><br><span class="line"><span class="comment">// 将所有的左叶子节点全部相加</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">next</span><span class="params">(TreeNode* root,<span class="type">int</span> &amp;sum, <span class="type">bool</span> leftflag)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">nullptr</span>&amp;&amp;root-&gt;right==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(leftflag) sum += root-&gt;val;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left) <span class="built_in">next</span>(root-&gt;left,sum,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) <span class="built_in">next</span>(root-&gt;right,sum,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">next</span>(root,sum,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="513-找树左下角的值"><a href="#513-找树左下角的值" class="headerlink" title="513. 找树左下角的值"></a><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/">513. 找树左下角的值</a></h2><blockquote>
<p>给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。</p>
<p>假设二叉树中至少有一个节点。</p>
<p>示例 1:</p>
<p>输入: root = [2,1,3]<br>输出: 1<br>示例 2:</p>
<p>输入: [1,2,3,4,null,5,6,null,null,7]<br>输出: 7</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 层序遍历取最后一层的第一个数</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; temp;</span><br><span class="line">        <span class="type">int</span> res;</span><br><span class="line">        temp.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!temp.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> size = temp.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>) res=temp.<span class="built_in">front</span>()-&gt;val;</span><br><span class="line">                <span class="keyword">if</span>(temp.<span class="built_in">front</span>()-&gt;left) temp.<span class="built_in">push</span>(temp.<span class="built_in">front</span>()-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(temp.<span class="built_in">front</span>()-&gt;right) temp.<span class="built_in">push</span>(temp.<span class="built_in">front</span>()-&gt;right);</span><br><span class="line">                temp.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a><a href="https://leetcode.cn/problems/path-sum/">112. 路径总和</a></h2><blockquote>
<p>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。</p>
<p>叶子节点 是指没有子节点的节点。</p>
<p>示例 1：</p>
<p>输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22<br>输出：true<br>解释：等于目标和的根节点到叶节点路径如上图所示。<br>示例 2：</p>
<p>输入：root = [1,2,3], targetSum = 5<br>输出：false<br>解释：树中存在两条根节点到叶子节点的路径：<br>(1 —&gt; 2): 和为 3<br>(1 —&gt; 3): 和为 4<br>不存在 sum = 5 的根节点到叶子节点的路径。<br>示例 3：</p>
<p>输入：root = [], targetSum = 0<br>输出：false<br>解释：由于树是空的，所以不存在根节点到叶子节点的路径。</p>
<ul>
<li>树中节点的数目在范围 <code>[0, 5000]</code> 内</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
<li><code>-1000 &lt;= targetSum &lt;= 1000</code></li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先明确题目为到叶子结点的路径，然后该题目的值有负数</span></span><br><span class="line"><span class="comment">// 前序遍历+节点值，并判断路径中节点值的和等于给定值时，是否为叶子节点</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">next</span><span class="params">(TreeNode* root,<span class="type">int</span> targetSum,<span class="type">int</span> sum,<span class="type">bool</span> &amp;flag)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span> || flag) <span class="keyword">return</span>;</span><br><span class="line">        sum += root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(sum==targetSum&amp;&amp;root-&gt;left==<span class="literal">nullptr</span>&amp;&amp;root-&gt;right==<span class="literal">nullptr</span>) flag=<span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">next</span>(root-&gt;left,targetSum,sum,flag);</span><br><span class="line">        <span class="built_in">next</span>(root-&gt;right,targetSum,sum,flag);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">next</span>(root,targetSum,<span class="number">0</span>,flag);</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></h2><blockquote>
<p>给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。</p>
<p>示例 1:</p>
<p>输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]<br>输出：[3,9,20,null,null,15,7]<br>示例 2:</p>
<p>输入：inorder = [-1], postorder = [-1]<br>输出：[-1]</p>
</blockquote>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210203154249860.png" alt="106.从中序与后序遍历序列构造二叉树"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先要明确思路，了解如何使用中序遍历和前序遍历进行处理</span></span><br><span class="line"><span class="comment">// 只有了解了基本的思路才能写出代码，以下是使用迭代的代码</span></span><br><span class="line"><span class="comment">// 在后序最后一位为当前树的顶点位置，通过该位置，将中序遍历分为两段</span></span><br><span class="line"><span class="comment">// 根据中序遍历分为两段的长度，将后序遍历分为两段</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">next</span><span class="params">(vector&lt;<span class="type">int</span>&gt; inorder, vector&lt;<span class="type">int</span>&gt; postorder,TreeNode* &amp;temp)</span></span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; inleft,inright;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; posleft,posright;</span><br><span class="line">        <span class="type">int</span> head = postorder[postorder.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">        <span class="type">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> &amp;i:inorder)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=head)&#123;</span><br><span class="line">                <span class="keyword">if</span>(flag) inleft.<span class="built_in">push_back</span>(i);</span><br><span class="line">                <span class="keyword">else</span> inright.<span class="built_in">push_back</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> flag=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(inleft.<span class="built_in">empty</span>()&amp;&amp;inright.<span class="built_in">empty</span>()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;postorder.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;inleft.<span class="built_in">size</span>()) posleft.<span class="built_in">push_back</span>(postorder[i]);</span><br><span class="line">            <span class="keyword">else</span> posright.<span class="built_in">push_back</span>(postorder[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!posleft.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            temp-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(posleft[posleft.<span class="built_in">size</span>()<span class="number">-1</span>]);</span><br><span class="line">            <span class="built_in">next</span>(inleft, posleft,temp-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!posright.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            temp-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(posright[posright.<span class="built_in">size</span>()<span class="number">-1</span>]);</span><br><span class="line">            <span class="built_in">next</span>(inright, posright,temp-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        TreeNode* root=<span class="keyword">new</span> <span class="built_in">TreeNode</span>(postorder[postorder.<span class="built_in">size</span>()<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(inorder.<span class="built_in">size</span>()==<span class="number">1</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="built_in">next</span>(inorder, postorder,root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 以上代码是未经过优化的代码144ms，204.5MB</span></span><br><span class="line"><span class="comment">// 通过对代码进行优化可以达到24ms，72.2MB</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> head = postorder.<span class="built_in">back</span>();</span><br><span class="line">        TreeNode* root=<span class="keyword">new</span> <span class="built_in">TreeNode</span>(head);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;::iterator iter = <span class="built_in">find</span>(inorder.<span class="built_in">begin</span>(), inorder.<span class="built_in">end</span>(), head);</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">distance</span>(inorder.<span class="built_in">begin</span>(),iter);</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inleft</span><span class="params">(inorder.begin(),inorder.begin()+index)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inright</span><span class="params">(inorder.begin()+index+<span class="number">1</span>,inorder.end())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">posleft</span><span class="params">(postorder.begin(),postorder.begin()+index)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">posright</span><span class="params">(postorder.begin()+index,postorder.end()<span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(!posleft.<span class="built_in">empty</span>()) root-&gt;left = <span class="built_in">buildTree</span>(inleft, posleft);</span><br><span class="line">        <span class="keyword">if</span>(!posright.<span class="built_in">empty</span>()) root-&gt;right = <span class="built_in">buildTree</span>(inright, posright);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654. 最大二叉树"></a><a href="https://leetcode.cn/problems/maximum-binary-tree/">654. 最大二叉树</a></h2><blockquote>
<p>给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建:</p>
<p>创建一个根节点，其值为 nums 中的最大值。<br>递归地在最大值 左边 的 子数组前缀上 构建左子树。<br>递归地在最大值 右边 的 子数组后缀上 构建右子树。<br>返回 nums 构建的 最大二叉树 。</p>
<p>示例 1：</p>
<p>输入：nums = [3,2,1,6,0,5]<br>输出：[6,3,5,null,2,0,null,null,1]<br>解释：递归调用如下所示：</p>
<ul>
<li><p>[3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。</p>
<ul>
<li>[3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。<ul>
<li>空数组，无子节点。</li>
<li>[2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。<ul>
<li>空数组，无子节点。</li>
<li>只有一个元素，所以子节点是一个值为 1 的节点。</li>
</ul>
</li>
</ul>
</li>
<li>[0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。<ul>
<li>只有一个元素，所以子节点是一个值为 0 的节点。</li>
<li>空数组，无子节点。</li>
</ul>
</li>
</ul>
<p>示例 2：</p>
</li>
</ul>
<p>输入：nums = [3,2,1]<br>输出：[3,null,2,null,1]</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有了上面题目的铺垫，简单修改可得</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line">        <span class="keyword">for</span>(index=<span class="number">1</span>;index&lt;nums.<span class="built_in">size</span>();index++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[max]&lt;nums[index]) max=index;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[max]);</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left</span><span class="params">(nums.begin(),nums.begin()+max)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(!left.<span class="built_in">empty</span>()) root-&gt;left = <span class="built_in">constructMaximumBinaryTree</span>(left);</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">right</span><span class="params">(nums.begin()+max+<span class="number">1</span>,nums.end())</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(!right.<span class="built_in">empty</span>()) root-&gt;right = <span class="built_in">constructMaximumBinaryTree</span>(right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617. 合并二叉树"></a><a href="https://leetcode.cn/problems/merge-two-binary-trees/">617. 合并二叉树</a></h2><blockquote>
<p>给你两棵二叉树： root1 和 root2 。</p>
<p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。</p>
<p>返回合并后的二叉树。</p>
<p>注意: 合并过程必须从两个树的根节点开始。</p>
<p>示例 1：</p>
<p>输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]<br>输出：[3,4,5,5,4,null,7]<br>示例 2：</p>
<p>输入：root1 = [1], root2 = [1,2]<br>输出：[2,2]</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root1&amp;&amp;!root2) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(root1) root-&gt;val += root1-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(root2) root-&gt;val += root2-&gt;val;</span><br><span class="line">        root-&gt;left = <span class="built_in">mergeTrees</span>(root1?root1-&gt;left:<span class="literal">nullptr</span>, root2?root2-&gt;left:<span class="literal">nullptr</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">mergeTrees</span>(root1?root1-&gt;right:<span class="literal">nullptr</span>, root2?root2-&gt;right:<span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700. 二叉搜索树中的搜索"></a><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索</a></h2><blockquote>
<p>给定二叉搜索树（BST）的根节点 root 和一个整数值 val。</p>
<p>你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。</p>
<p>示例 1:</p>
<p>输入：root = [4,2,7,1,3], val = 2<br>输出：[2,1,3]<br>示例 2:</p>
<p>输入：root = [4,2,7,1,3], val = 5<br>输出：[]</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 考虑二叉搜索树的性质，左子树都比根节点小，右子树都比根节点大</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">next</span><span class="params">(TreeNode* &amp;root, <span class="type">int</span> val,TreeNode* &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>||root-&gt;val==val)&#123;</span><br><span class="line">            res=root;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val&gt;val) <span class="built_in">next</span>(root-&gt;left,val,res);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">next</span>(root-&gt;right,val,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        TreeNode* res;</span><br><span class="line">        <span class="built_in">next</span>(root, val,res);</span><br><span class="line">        <span class="keyword">if</span>(res==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h2><blockquote>
<p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p>
<p>有效 二叉搜索树定义如下：</p>
<p>节点的左子树只包含 小于 当前节点的数。<br>节点的右子树只包含 大于 当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。</p>
<p>示例 1：</p>
<p>输入：root = [2,1,3]<br>输出：true<br>示例 2：</p>
<p>输入：root = [5,1,4,null,null,3,6]<br>输出：false<br>解释：根节点的值是 5 ，但是右子节点的值是 4 。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接中序遍历，如果是二叉搜索树，中序遍历后必然是从小到大排序</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">next</span><span class="params">(TreeNode* root,vector&lt;<span class="type">int</span>&gt; &amp;temp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">next</span>(root-&gt;left,temp);</span><br><span class="line">        temp.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">next</span>(root-&gt;right,temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> res=<span class="literal">true</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">        <span class="built_in">next</span>(root,temp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;temp.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp[i+<span class="number">1</span>]&lt;=temp[i])&#123;</span><br><span class="line">                res=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="530-二叉搜索树的最小绝对差"><a href="#530-二叉搜索树的最小绝对差" class="headerlink" title="530. 二叉搜索树的最小绝对差"></a><a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">530. 二叉搜索树的最小绝对差</a></h2><blockquote>
<p>给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值 。</p>
<p>差值是一个正数，其数值等于两值之差的绝对值。</p>
<p>示例 1：</p>
<p>输入：root = [4,2,6,1,3]<br>输出：1<br>示例 2：</p>
<p>输入：root = [1,0,48,null,null,12,49]<br>输出：1</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中序遍历，找前一元素减后一元素最小值</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">next</span><span class="params">(TreeNode* root,vector&lt;<span class="type">int</span>&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">next</span>(root-&gt;left,res);</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">next</span>(root-&gt;right,res); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">next</span>(root,res);</span><br><span class="line">        <span class="type">int</span> out=res[<span class="number">1</span>]-res[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;res.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(out&gt;res[i+<span class="number">1</span>]-res[i]) out=res[i+<span class="number">1</span>]-res[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="501-二叉搜索树中的众数"><a href="#501-二叉搜索树中的众数" class="headerlink" title="501. 二叉搜索树中的众数"></a><a href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">501. 二叉搜索树中的众数</a></h2><blockquote>
<p>给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。</p>
<p>如果树中有不止一个众数，可以按 任意顺序 返回。</p>
<p>假定 BST 满足如下定义：</p>
<p>结点左子树中所含节点的值 小于等于 当前节点的值<br>结点右子树中所含节点的值 大于等于 当前节点的值<br>左子树和右子树都是二叉搜索树</p>
<p>示例 1：</p>
<p>输入：root = [1,null,2,2]<br>输出：[2]<br>示例 2：</p>
<p>输入：root = [0]<br>输出：[0]</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中序遍历，map记录元素个数，对map次数进行排序</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">comparePairs</span><span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; a, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.second &gt; b.second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">next</span><span class="params">(TreeNode* root,vector&lt;<span class="type">int</span>&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left) <span class="built_in">next</span>(root-&gt;left,res);</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) <span class="built_in">next</span>(root-&gt;right,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findMode</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">next</span>(root,res);</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> &amp;i:res)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mp[i]) mp[i]++;</span><br><span class="line">            <span class="keyword">else</span> mp[i]=<span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">pairs</span>(mp.<span class="built_in">begin</span>(), mp.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(pairs.<span class="built_in">begin</span>(), pairs.<span class="built_in">end</span>(), comparePairs);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; out;</span><br><span class="line">        <span class="type">int</span> num=pairs.<span class="built_in">begin</span>()-&gt;second;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i:pairs)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i.second==num) out.<span class="built_in">push_back</span>(i.first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++算法</tag>
      </tags>
  </entry>
  <entry>
    <title>代码随想录(day6)</title>
    <url>/link/suixiangluday6.html</url>
    <content><![CDATA[<blockquote>
<p>刷题参考：<a href="https://www.programmercarl.com/">代码随想录 (programmercarl.com)</a></p>
<p>题目来源：<a href="https://leetcode.cn/problems/binary-search">力扣（LeetCode）</a></p>
</blockquote>
<h1 id="Day-6：二叉树（前篇）"><a href="#Day-6：二叉树（前篇）" class="headerlink" title="Day 6：二叉树（前篇）"></a>Day 6：二叉树（前篇）</h1><h2 id="基本理论"><a href="#基本理论" class="headerlink" title="基本理论"></a>基本理论</h2><h3 id="二叉树的种类"><a href="#二叉树的种类" class="headerlink" title="二叉树的种类"></a>二叉树的种类</h3><ul>
<li>满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。</li>
</ul>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806185805576.png" alt="img"></p>
<ul>
<li>完全二叉树：当使用顺序存储时，存储的内容中不存在空值</li>
</ul>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200920221638903.png" alt="img"></p>
<ul>
<li>二叉搜索树</li>
<li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>它的左、右子树也分别为二叉排序树</li>
</ul>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806190304693.png" alt="img"></p>
<ul>
<li>平衡二叉搜索：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</li>
</ul>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806190511967.png" alt="img"></p>
<h3 id="二叉树的存储方式"><a href="#二叉树的存储方式" class="headerlink" title="二叉树的存储方式"></a>二叉树的存储方式</h3><ul>
<li>链式存储：采用链表存储</li>
</ul>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/2020092019554618.png" alt="img"></p>
<ul>
<li>顺序存储：采用数组存储</li>
</ul>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200920200429452.png" alt="img"></p>
<h3 id="二叉树的遍历方式"><a href="#二叉树的遍历方式" class="headerlink" title="二叉树的遍历方式"></a>二叉树的遍历方式</h3><ul>
<li>深度优先遍历：前序遍历，中序遍历，后序遍历</li>
</ul>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806191109896.png" alt="img"></p>
<ul>
<li>广度优先遍历：层序遍历</li>
</ul>
<h3 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 链表结构定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x)</span><br><span class="line">        :<span class="built_in">val</span>(x),<span class="built_in">left</span>(<span class="literal">NULL</span>),<span class="built_in">right</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></h2><blockquote>
<p>给你二叉树的根节点 root ，返回它节点值的 前序 遍历。 </p>
<p>示例 1：</p>
<p>输入：root = [1,null,2,3]<br>输出：[1,2,3]<br>示例 2：</p>
<p>输入：root = []<br>输出：[]<br>示例 3：</p>
<p>输入：root = [1]<br>输出：[1]<br>示例 4：</p>
<p>输入：root = [1,2]<br>输出：[1,2]<br>示例 5：</p>
<p>输入：root = [1,null,2]<br>输出：[1,2]</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">next</span><span class="params">(TreeNode* &amp;root,vector&lt;<span class="type">int</span>&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left) <span class="built_in">next</span>(root-&gt;left,res);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) <span class="built_in">next</span>(root-&gt;right,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">next</span>(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">next</span><span class="params">(TreeNode* &amp;root,vector&lt;<span class="type">int</span>&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left) <span class="built_in">next</span>(root-&gt;left,res);</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) <span class="built_in">next</span>(root-&gt;right,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">next</span>(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">next</span><span class="params">(TreeNode* &amp;root,vector&lt;<span class="type">int</span>&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left) <span class="built_in">next</span>(root-&gt;left,res);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) <span class="built_in">next</span>(root-&gt;right,res);</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">next</span>(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单思路，队列实现遍历</span></span><br><span class="line"><span class="comment">// 先初始化，记录第一层的节点，第一层的节点记录完成后</span></span><br><span class="line"><span class="comment">// 记录当前的队列大小，需要将所有节点弹出，并将弹出的值保存到数组中</span></span><br><span class="line"><span class="comment">// 弹出的同时要新加入下一层的节点</span></span><br><span class="line"><span class="comment">// 当队列中的节点个数为0时，遍历完成</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        queue&lt;TreeNode*&gt; temp;</span><br><span class="line">        temp.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!temp.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> size=temp.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; cur;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                cur.<span class="built_in">push_back</span>(temp.<span class="built_in">front</span>()-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(temp.<span class="built_in">front</span>()-&gt;left) temp.<span class="built_in">push</span>(temp.<span class="built_in">front</span>()-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(temp.<span class="built_in">front</span>()-&gt;right) temp.<span class="built_in">push</span>(temp.<span class="built_in">front</span>()-&gt;right);</span><br><span class="line">                temp.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树</a></h2><blockquote>
<p>给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。</p>
<p>示例 1：</p>
<p>输入：root = [4,2,7,1,3,6,9]<br>输出：[4,7,2,9,6,3,1]</p>
<p>示例 2：</p>
<p>输入：root = [2,1,3]<br>输出：[2,3,1]<br>示例 3：</p>
<p>输入：root = []<br>输出：[]</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单递归</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">next</span><span class="params">(TreeNode* &amp;root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        TreeNode* temp;</span><br><span class="line">        temp = root-&gt;left;</span><br><span class="line">        root-&gt;left = root-&gt;right;</span><br><span class="line">        root-&gt;right = temp;</span><br><span class="line">        <span class="built_in">next</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">next</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">next</span>(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a></h2><blockquote>
<p>给你一个二叉树的根节点 root ， 检查它是否轴对称。</p>
<p>示例 1：</p>
<p>输入：root = [1,2,2,3,4,4,3]<br>输出：true<br>示例 2：</p>
<p>输入：root = [1,2,2,null,3,null,3]<br>输出：false</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">next</span><span class="params">(TreeNode* left,TreeNode* right,<span class="type">bool</span> &amp;flag)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!flag || (left==<span class="literal">nullptr</span>&amp;&amp;right==<span class="literal">nullptr</span>)) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="literal">nullptr</span> || right==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            flag=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(left-&gt;val != right-&gt;val) flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">next</span>(left-&gt;left,right-&gt;right,flag);</span><br><span class="line">        <span class="built_in">next</span>(left-&gt;right,right-&gt;left,flag);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">next</span>(root-&gt;left,root-&gt;right,flag);</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h2><blockquote>
<p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例：<br>给定二叉树 [3,9,20,null,null,15,7]，</p>
<p>   3</p>
<p>   / \<br>  9  20<br>      /  \<br>   15   7<br>返回它的最大深度 3 。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">next</span><span class="params">(TreeNode* root,<span class="type">int</span> legth,<span class="type">int</span> &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res&lt;legth) res=legth;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        legth ++;</span><br><span class="line">        <span class="built_in">next</span>(root-&gt;left,legth,res);</span><br><span class="line">        <span class="built_in">next</span>(root-&gt;right,legth,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> legth=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">next</span>(root,legth,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 以上代码可以在最大深度中过，但不能在最小深度中过</span></span><br><span class="line"><span class="comment">// 因为没有明确叶子节点的定义，即没有任何一个子节点</span></span><br><span class="line"><span class="comment">// 上面的代码是没有一个节点就返回，以下是修正后的代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">next</span><span class="params">(TreeNode* root,<span class="type">int</span> legth,<span class="type">int</span> &amp;res)</span></span>&#123;</span><br><span class="line">        legth ++;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">nullptr</span>&amp;&amp;root-&gt;right==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res&lt;legth) res=legth;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left) <span class="built_in">next</span>(root-&gt;left,legth,res);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) <span class="built_in">next</span>(root-&gt;right,legth,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> legth=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">next</span>(root,legth,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></h2><blockquote>
<p>给定一个二叉树，找出其最小深度。</p>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<p>说明：叶子节点是指没有子节点的节点。</p>
<p>示例 1：</p>
<p>输入：root = [3,9,20,null,null,15,7]<br>输出：2<br>示例 2：</p>
<p>输入：root = [2,null,3,null,4,null,5,null,6]<br>输出：5</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 与上题基本一致，但是由于是需要一个最小值，所以先赋值-1给结果作为初始状态</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">next</span><span class="params">(TreeNode* root,<span class="type">int</span> legth,<span class="type">int</span> &amp;res)</span></span>&#123;</span><br><span class="line">        legth ++;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">nullptr</span>&amp;&amp;root-&gt;right==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res&gt;legth || res==<span class="number">-1</span>) res=legth;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left) <span class="built_in">next</span>(root-&gt;left,legth,res);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) <span class="built_in">next</span>(root-&gt;right,legth,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> legth=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">next</span>(root,legth,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222. 完全二叉树的节点个数"></a><a href="https://leetcode.cn/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a></h2><blockquote>
<p>给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。</p>
<p>完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。</p>
<p>示例 1：</p>
<p>输入：root = [1,2,3,4,5,6]<br>输出：6<br>示例 2：</p>
<p>输入：root = []<br>输出：0<br>示例 3：</p>
<p>输入：root = [1]<br>输出：1</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不知道为什么是个中等题</span></span><br><span class="line"><span class="comment">// 递归直接秒</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">next</span><span class="params">(TreeNode* root,<span class="type">int</span> &amp;nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        nums ++;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left) <span class="built_in">next</span>(root-&gt;left,nums);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) <span class="built_in">next</span>(root-&gt;right,nums);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> nums=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">next</span>(root,nums);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a><a href="https://leetcode.cn/problems/balanced-binary-tree/">110. 平衡二叉树</a></h2><blockquote>
<p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：</p>
<p>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。</p>
<p>示例 1：</p>
<p>输入：root = [3,9,20,null,null,15,7]<br>输出：true<br>示例 2：</p>
<p>输入：root = [1,2,2,3,3,null,null,4,4]<br>输出：false<br>示例 3：</p>
<p>输入：root = []<br>输出：true</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前序遍历算深度，后序遍历算深度</span></span><br><span class="line"><span class="comment">// 遍历分清条件，将遍历过程中的变化，插入到对应位置</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">(TreeNode* root,<span class="type">int</span> legth,<span class="type">bool</span> &amp;temp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="built_in">next</span>(root-&gt;left,legth,temp);</span><br><span class="line">        <span class="type">int</span> right = <span class="built_in">next</span>(root-&gt;right,legth,temp);</span><br><span class="line">        <span class="keyword">if</span>(right-left&gt;<span class="number">1</span> || left-right&gt;<span class="number">1</span>) temp=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> left&gt;right?++left:++right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> temp=<span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">next</span>(root,<span class="number">0</span>,temp);</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257. 二叉树的所有路径"></a><a href="https://leetcode.cn/problems/binary-tree-paths/">257. 二叉树的所有路径</a></h2><blockquote>
<p>给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。</p>
<p>叶子节点 是指没有子节点的节点。</p>
<p>示例 1：</p>
<p>输入：root = [1,2,3,null,5]<br>输出：[“1-&gt;2-&gt;5”,”1-&gt;3”]<br>示例 2：</p>
<p>输入：root = [1]<br>输出：[“1”]</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前序遍历算路径</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">next</span><span class="params">(TreeNode* root,vector&lt;<span class="type">int</span>&gt; temp,vector&lt;string&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        temp.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">nullptr</span>&amp;&amp;root-&gt;right==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            string a;</span><br><span class="line">            a += <span class="built_in">to_string</span>(temp[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;temp.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                a += <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">                a += <span class="built_in">to_string</span>(temp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(a);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left) <span class="built_in">next</span>(root-&gt;left,temp,res);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) <span class="built_in">next</span>(root-&gt;right,temp,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">        <span class="built_in">next</span>(root,temp,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>二叉树的前中后序遍历，层序遍历是基础，后面的翻转二叉树，对称二叉树，都是前序遍历的简单应用，再后面的最大最小深度，节点个数，所有路径，都可以转换成前序遍历的变体，平衡二叉树是需要求子树的高度，相当于是从下往上，这里需要后序遍历，来求高度。</p>
<p>这里需要注意的是叶子节点的定义，树的高度和深度的区别，总之，先通过问题判断需要的遍历方式，将需要的操作插入到相应的遍历位置，就可以完成上述题目。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++算法</tag>
      </tags>
  </entry>
  <entry>
    <title>代码随想录(day5)</title>
    <url>/link/suixiangluday5.html</url>
    <content><![CDATA[<blockquote>
<p>刷题参考：<a href="https://www.programmercarl.com/">代码随想录 (programmercarl.com)</a></p>
<p>题目来源：<a href="https://leetcode.cn/problems/binary-search">力扣（LeetCode）</a></p>
</blockquote>
<h1 id="Day-5：栈与队列"><a href="#Day-5：栈与队列" class="headerlink" title="Day 5：栈与队列"></a>Day 5：栈与队列</h1><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>队列是先进先出，栈是先进后出</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210104235346563.png" alt="栈与队列理论1"></p>
<p>栈和队列是STL（C++标准库）里面的两个数据结构。</p>
<p>C++标准库是有多个版本的，要知道我们使用的STL是哪个版本，才能知道对应的栈和队列的实现原理。</p>
<p>那么来介绍一下，三个最为普遍的STL版本：</p>
<ol>
<li>HP STL 其他版本的C++ STL，一般是以HP STL为蓝本实现出来的，HP STL是C++ STL的第一个实现版本，而且开放源代码。</li>
<li>P.J.Plauger STL 由P.J.Plauger参照HP STL实现出来的，被Visual C++编译器所采用，不是开源的。</li>
<li>SGI STL 由Silicon Graphics Computer Systems公司参照HP STL实现，被Linux的C++编译器GCC所采用，SGI STL是开源软件，源码可读性甚高。</li>
</ol>
<p><strong>栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。</strong></p>
<p>STL中栈往往不被归类为容器，而被归类为container adapter（容器适配器），栈的底层实现可以是vector，deque，list，主要是数组和链表的底层实现。<strong>常用的SGI STL，如果没有指定底层实现的话，默认是以deque为缺省情况下栈的底层结构。</strong></p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210104235459376.png" alt="栈与队列理论3"></p>
<p>队列也是相同的情况。</p>
<h2 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></h2><blockquote>
<p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：</p>
<p>实现 MyQueue 类：</p>
<p>void push(int x) 将元素 x 推到队列的末尾<br>int pop() 从队列的开头移除并返回元素<br>int peek() 返回队列开头的元素<br>boolean empty() 如果队列为空，返回 true ；否则，返回 false<br>说明：</p>
<p>你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。<br>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</p>
<p>示例 1：</p>
<p>输入：<br>[“MyQueue”, “push”, “push”, “peek”, “pop”, “empty”]<br>[[], [1], [2], [], [], []]<br>输出：<br>[null, null, null, 1, 1, false]</p>
<p>解释：<br>MyQueue myQueue = new MyQueue();<br>myQueue.push(1); // queue is: [1]<br>myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)<br>myQueue.peek(); // return 1<br>myQueue.pop(); // return 1, queue is [2]<br>myQueue.empty(); // return false</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用两个栈来模拟队列，一个进栈，一个出栈</span></span><br><span class="line"><span class="comment">// 当需要添加时，直接向进栈里添加即可</span></span><br><span class="line"><span class="comment">// 当需要查看或删除队列头部元素时，先判断出栈里有没有元素</span></span><br><span class="line"><span class="comment">// 如果有则直接top，或者pop，没有的话就将进栈的所有元素挪到出栈中</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::stack&lt;<span class="type">int</span>&gt; instack;</span><br><span class="line">    std::stack&lt;<span class="type">int</span>&gt; outstack;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="built_in">MyQueue</span>() &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        instack.<span class="built_in">push</span>(x);</span><br><span class="line">        size ++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> out = <span class="built_in">peek</span>();</span><br><span class="line">        outstack.<span class="built_in">pop</span>();</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(outstack.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">while</span>(instack.<span class="built_in">size</span>())&#123;</span><br><span class="line">                outstack.<span class="built_in">push</span>(instack.<span class="built_in">top</span>());</span><br><span class="line">                instack.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> outstack.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a><a href="https://leetcode.cn/problems/implement-stack-using-queues/">225. 用队列实现栈</a></h2><blockquote>
<p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。</p>
<p>实现 MyStack 类：</p>
<p>void push(int x) 将元素 x 压入栈顶。<br>int pop() 移除并返回栈顶元素。<br>int top() 返回栈顶元素。<br>boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。</p>
<p>注意：</p>
<p>你只能使用队列的基本操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。<br>你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</p>
<p>示例：</p>
<p>输入：<br>[“MyStack”, “push”, “push”, “top”, “pop”, “empty”]<br>[[], [1], [2], [], [], []]<br>输出：<br>[null, null, null, 2, 2, false]</p>
<p>解释：<br>MyStack myStack = new MyStack();<br>myStack.push(1);<br>myStack.push(2);<br>myStack.top(); // 返回 2<br>myStack.pop(); // 返回 2<br>myStack.empty(); // 返回 False</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 两个队列模拟栈，可以考虑使用一个队列进行备份</span></span><br><span class="line"><span class="comment">// 当压入栈时直接进入队列，当弹出栈时，将队列中的所有元素移动到备份队列</span></span><br><span class="line"><span class="comment">// 只保留最后一个元素，需要弹出或取值时使用即可</span></span><br><span class="line"><span class="comment">// 然后从备份队列还原，可以单个队列循环实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">    <span class="built_in">MyStack</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        a.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>()<span class="number">-1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a.<span class="built_in">push</span>(a.<span class="built_in">front</span>());</span><br><span class="line">            a.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        res = a.<span class="built_in">front</span>();</span><br><span class="line">        a.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res;</span><br><span class="line">        res = <span class="built_in">pop</span>();</span><br><span class="line">        a.<span class="built_in">push</span>(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></h2><blockquote>
<p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>每个右括号都有一个对应的相同类型的左括号。</p>
<p>示例 1：</p>
<p>输入：s = “()”<br>输出：true<br>示例 2：</p>
<p>输入：s = “()[]{}”<br>输出：true<br>示例 3：</p>
<p>输入：s = “(]”<br>输出：false</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单的栈的应用，输入的括号直接与栈顶的元素对比</span></span><br><span class="line"><span class="comment">// 不匹配就压入，匹配就直接消去，如果最后栈为空，则返回true</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; str_stack;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i:s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(str_stack.<span class="built_in">empty</span>()) str_stack.<span class="built_in">push</span>(i);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == (str_stack.<span class="built_in">top</span>())+<span class="number">1</span> || i == (str_stack.<span class="built_in">top</span>())+<span class="number">2</span>) str_stack.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">else</span> str_stack.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str_stack.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="1047-删除字符串中的所有相邻重复项"><a href="#1047-删除字符串中的所有相邻重复项" class="headerlink" title="1047. 删除字符串中的所有相邻重复项"></a><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">1047. 删除字符串中的所有相邻重复项</a></h2><blockquote>
<p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</p>
<p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p>
<p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p>
<p>示例：</p>
<p>输入：”abbaca”<br>输出：”ca”<br>解释：<br>例如，在 “abbaca” 中，我们可以删除 “bb” 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 “aaca”，其中又只有 “aa” 可以执行重复项删除操作，所以最后的字符串为 “ca”。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 思路和上面的一样，和栈顶匹配就消去</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;i:s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (res.<span class="built_in">empty</span>()) res.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == res.<span class="built_in">back</span>()) res.<span class="built_in">pop_back</span>();</span><br><span class="line">                <span class="keyword">else</span> res.<span class="built_in">push_back</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值</a></h2><blockquote>
<p>给你一个字符串数组 tokens ，表示一个根据 逆波兰表示法 表示的算术表达式。</p>
<p>请你计算该表达式。返回一个表示表达式值的整数。</p>
<p>注意：</p>
<p>有效的算符为 ‘+’、’-‘、’*’ 和 ‘/‘ 。<br>每个操作数（运算对象）都可以是一个整数或者另一个表达式。<br>两个整数之间的除法总是 向零截断 。<br>表达式中不含除零运算。<br>输入是一个根据逆波兰表示法表示的算术表达式。<br>答案及所有中间计算结果可以用 32 位 整数表示。</p>
<p>示例 1：</p>
<p>输入：tokens = [“2”,”1”,”+”,”3”,”<em>“]<br>输出：9<br>解释：该算式转化为常见的中缀算术表达式为：((2 + 1) </em> 3) = 9<br>示例 2：</p>
<p>输入：tokens = [“4”,”13”,”5”,”/“,”+”]<br>输出：6<br>解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6<br>示例 3：</p>
<p>输入：tokens = [“10”,”6”,”9”,”3”,”+”,”-11”,”<em>“,”/“,”</em>“,”17”,”+”,”5”,”+”]<br>输出：22<br>解释：该算式转化为常见的中缀算术表达式为：<br>  ((10 <em> (6 / ((9 + 3) </em> -11))) + 17) + 5<br>= ((10 <em> (6 / (12 </em> -11))) + 17) + 5<br>= ((10 <em> (6 / -132)) + 17) + 5<br>= ((10 </em> 0) + 17) + 5<br>= (0 + 17) + 5<br>= 17 + 5<br>= 22</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 看上去很难，但是只要清楚当碰到运算符时，栈顶两个元素进行运算</span></span><br><span class="line"><span class="comment">// 就成了简单的等运算符号来的时候在栈顶进行运算的问题了</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; jisuan;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;i:tokens)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i.<span class="built_in">back</span>()&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;i.<span class="built_in">back</span>()&lt;=<span class="string">&#x27;9&#x27;</span>) jisuan.<span class="built_in">push</span>(<span class="built_in">atoi</span>(i.<span class="built_in">c_str</span>()));</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span> a = jisuan.<span class="built_in">top</span>();</span><br><span class="line">                jisuan.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> b = jisuan.<span class="built_in">top</span>();</span><br><span class="line">                jisuan.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="string">&quot;+&quot;</span>) jisuan.<span class="built_in">push</span>(a+b);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="string">&quot;-&quot;</span>) jisuan.<span class="built_in">push</span>(b-a);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="string">&quot;*&quot;</span>) jisuan.<span class="built_in">push</span>(b*a);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="string">&quot;/&quot;</span>) jisuan.<span class="built_in">push</span>(b/a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jisuan.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></h2><blockquote>
<p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回 滑动窗口中的最大值 。</p>
<p>示例 1：</p>
<p>输入：nums = [1,3,-1,-3,5,3,6,7], k = 3<br>输出：[3,3,5,5,6,7]<br>解释：<br>滑动窗口的位置                最大值</p>
<hr>
<p>[1  3  -1] -3  5  3  6  7       3<br> 1 [3  -1  -3] 5  3  6  7       3<br> 1  3 [-1  -3  5] 3  6  7       5<br> 1  3  -1 [-3  5  3] 6  7       5<br> 1  3  -1  -3 [5  3  6] 7       6<br> 1  3  -1  -3  5 [3  6  7]      7<br>示例 2：</p>
<p>输入：nums = [1], k = 1<br>输出：[1]</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 滑动窗口，第一想法双指针去做左指针，右指针，然后滑动取区域内最大值</span></span><br><span class="line"><span class="comment">// 但显然当k很大时会超时，可以进行优化，c++方法最快实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">array</span><span class="params">(nums.size() - k + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> ans;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> index = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> right = k - <span class="number">1</span>; right &lt; nums.<span class="built_in">size</span>(); right++,left++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(left &lt;= index)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[right] &gt;= nums[index])&#123;</span><br><span class="line">                    index = right;</span><br><span class="line">                    ans = nums[right];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[right] &gt;= ans - <span class="number">1</span>)&#123;</span><br><span class="line">                index = right;</span><br><span class="line">                ans = nums[right];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[left] &gt;= ans - <span class="number">1</span>)&#123;</span><br><span class="line">                index = left;</span><br><span class="line">                ans = nums[left];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ans = nums[left];</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = left + <span class="number">1</span>; j &lt;= right; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums[j] &gt;= ans)&#123;</span><br><span class="line">                        index = j;</span><br><span class="line">                        ans = nums[j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            array[left] = ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 另外可以采用单调队列来实现，单调队列解决的问题是什么</span></span><br><span class="line"><span class="comment">// 放入的元素全部呈单调递增或者单调递减的样式</span></span><br><span class="line"><span class="comment">// 滑动窗口取最大，单调队列能保证最大值永远在一边</span></span><br><span class="line"><span class="comment">// 但是单调队列与队列不同，其底层实现是一个双边队列，两边都可以进出</span></span><br><span class="line"><span class="comment">// 最简单的实现，首先应该有一个队列，进行初始化</span></span><br><span class="line"><span class="comment">// 初始化时，先将第一个值传入队列</span></span><br><span class="line"><span class="comment">// 然后进行比较，如果存在一个值大于队列中入口位置的元素</span></span><br><span class="line"><span class="comment">// 那么弹出入口元素，在进行比较，直至为空或者小于入口元素</span></span><br><span class="line"><span class="comment">// 滑动窗口考虑一入一出两个情况，接下来是出口，</span></span><br><span class="line"><span class="comment">// 如果滑动窗口弹出的元素和出口元素一致，那么弹出出口元素</span></span><br><span class="line"><span class="comment">// 这样就能保证出口处的元素为当前的最大值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Myqueue</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">        <span class="built_in">Myqueue</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(!que.<span class="built_in">empty</span>() &amp;&amp; que.<span class="built_in">front</span>()&lt;x) que.<span class="built_in">pop_front</span>();</span><br><span class="line">            que.<span class="built_in">push_front</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!que.<span class="built_in">empty</span>() &amp;&amp; que.<span class="built_in">back</span>()==x) que.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> que.<span class="built_in">back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        Myqueue myque;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            myque.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=k) myque.<span class="built_in">pop</span>(nums[i-k]);</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=k<span class="number">-1</span>) res.<span class="built_in">push_back</span>(myque.<span class="built_in">top</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 上述代码中的back与front互换后减少空间使用，并且加快了速度</span></span><br></pre></td></tr></table></figure>
<h2 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a><a href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></h2><blockquote>
<p>给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。</p>
<p>示例 1:</p>
<p>输入: nums = [1,1,1,2,2,3], k = 2<br>输出: [1,2]<br>示例 2:</p>
<p>输入: nums = [1], k = 1<br>输出: [1]</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接的想法，先用字典记录元素个数</span></span><br><span class="line"><span class="comment">// 将字典的键值对绑定，对值进行排序，得到前k个的键就是结果</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp; a,<span class="type">const</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.second&gt;b.second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i:nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp[i]) mp[i] ++;</span><br><span class="line">            <span class="keyword">else</span> mp[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; <span class="built_in">v</span>(mp.<span class="built_in">begin</span>(),mp.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(v[i].first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 使用顶堆实现：求前 k 大，用小顶堆，求前 k 小，用大顶堆。</span></span><br><span class="line"><span class="comment">// 常见关于堆的面试：1. 实现一个堆数据结构（插入，删除） 2. 求 top k 3. 求中位数 4. k 路归并</span></span><br><span class="line"><span class="comment">// 二叉树的时候再做</span></span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>代码随想录总共七道题：前两道题分别是栈实现队列和队列实现栈，主要是为了更加熟悉栈和队列的结构，了解基本的操作，接下来的括号匹配，删除字符串相邻重复项和逆波兰表达式求值是考察栈的用法，滑动窗口最大值用自己实现的<strong>单调队列</strong>结构去求解，前k个高频元素主要引出了<strong>优先队列</strong>和大小顶堆。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++算法</tag>
      </tags>
  </entry>
  <entry>
    <title>代码随想录(day4)</title>
    <url>/link/suixiangluday4.html</url>
    <content><![CDATA[<blockquote>
<p>刷题参考：<a href="https://www.programmercarl.com/">代码随想录 (programmercarl.com)</a></p>
<p>题目来源：<a href="https://leetcode.cn/problems/binary-search">力扣（LeetCode）</a></p>
</blockquote>
<h1 id="Day-4：字符串"><a href="#Day-4：字符串" class="headerlink" title="Day 4：字符串"></a>Day 4：字符串</h1><blockquote>
<p>第四天了，啪的一下，很快啊，但是好像又没学到啥，可能是融（上）会（进）贯（下）通（出）了吧</p>
</blockquote>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>代码随想录没有说字符串的基本原理，string的底层是怎么实现的呢，大概就是char []吧，想到这里，突然觉得前面的数组，哈希表，也该去实现一下，链表题目中实现了。</p>
<p>这里找到了一个博文<a href="https://blog.csdn.net/qq_51845557/article/details/120686651"> C++ STL String底层实现分析_517 pacifikal的博客-CSDN博客</a></p>
<p>看完之后感觉确实好像stl没学，差了点意思，一个数据结构里面包含着基本结构，构造方法，运算符重载，方法实现，以及迭代器。这些方法之前虽然都一直在用，但是很少关注是如何实现的。stl分析也该提上日程了吗？</p>
<p>下面借用大佬的图文</p>
<h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>从一个容器的角度讲，string的结构并不复杂，本质上还是一个顺序表。如图可以生动展示一个string所占用的空间。其中_size表示当前已经使用的空间,_capacity表示最大容量。特别需要注意的是，string的字符串结尾会固定存放一个’/0’来表示字符串结尾。在实践中我发现在不主动调用reserve()方法与resize()方法的情况下，string.capacity()的值往往与string().size()相同。</p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202306131011764.png" alt="img"></p>
<p>由此可以得到string的私有部分定义：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span>* _ptr;						<span class="comment">//实际存储字符串内容的空间 </span></span><br><span class="line">	<span class="type">size_t</span> _size;					<span class="comment">//存储字符串当前的容量 </span></span><br><span class="line">	<span class="type">size_t</span> _capacity;				<span class="comment">//存储字符串最大容量 </span></span><br><span class="line">构造方法</span><br><span class="line">        下面给出string的构造方法：</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造函数 </span></span><br><span class="line">	<span class="built_in">MyString</span>():_ptr(<span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>]),_size(<span class="number">0</span>),_capacity()&#123;</span><br><span class="line">		*_ptr=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	&#125;<span class="comment">//没有参数的构造函数</span></span><br><span class="line">	<span class="built_in">MyString</span>(<span class="type">const</span> <span class="type">char</span>* ptr):_ptr(<span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(ptr)+<span class="number">1</span>]),_size(<span class="number">0</span>),_capacity(<span class="number">0</span>)&#123;<span class="comment">//带参数的构造函数 </span></span><br><span class="line">		<span class="built_in">strcpy</span>(_ptr,ptr);			<span class="comment">//将字符串赋值给string </span></span><br><span class="line">		_size=<span class="built_in">strlen</span>(_ptr);			<span class="comment">//将字符串的大小和容量更新为当前值 </span></span><br><span class="line">		_capacity=<span class="built_in">strlen</span>(_ptr);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">MyString</span>(<span class="type">const</span> MyString&amp; str):_ptr(<span class="literal">nullptr</span>),_size(<span class="number">0</span>),_capacity(<span class="number">0</span>)&#123;		<span class="comment">//拷贝构造 </span></span><br><span class="line">		<span class="built_in">strcpy</span>(_ptr,str._ptr);</span><br><span class="line">		_size=<span class="built_in">strlen</span>(_ptr);</span><br><span class="line">		_capacity=<span class="built_in">strlen</span>(_ptr);</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">MyString</span>()&#123;					<span class="comment">//析构函数 </span></span><br><span class="line">		<span class="keyword">if</span>(_ptr)&#123;</span><br><span class="line">			<span class="keyword">delete</span>[] _ptr;</span><br><span class="line">			_ptr=<span class="literal">nullptr</span>;</span><br><span class="line">			_size=<span class="number">0</span>;</span><br><span class="line">			_capacity=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><br>上述代码基本没有新难点。 </p>
<h3 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符"></a>重载运算符</h3><p>下面代码对一些运算符进行了重载<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MyString&amp; <span class="keyword">operator</span>=(MyString str)&#123;			<span class="comment">//对=符号进行重载 </span></span><br><span class="line">	<span class="built_in">strcpy</span>(_ptr,str._ptr);</span><br><span class="line">	_size=<span class="built_in">strlen</span>(_ptr);</span><br><span class="line">	_capacity=<span class="built_in">strlen</span>(_ptr);</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> n) <span class="type">const</span>&#123;		<span class="comment">//对[]符号进行重载,用以实现字符串随机访问 </span></span><br><span class="line">	<span class="built_in">assert</span>(n&lt;_size);</span><br><span class="line">	<span class="keyword">return</span> _ptr[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyString&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> <span class="type">char</span>&amp; c)&#123;		<span class="comment">//对+=重载，来实现+=字符的操作 </span></span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">push_back</span>(c);</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>; </span><br><span class="line">&#125;</span><br><span class="line">MyString&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> <span class="type">char</span>* str)&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">append</span>(str);</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">MyString&amp; <span class="keyword">operator</span>+=(<span class="type">const</span> MyString&amp; str)&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;<span class="built_in">append</span>(str._ptr);</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>string的方法为了能够满足地址，指针和string三种情况的调用，往往要多次重写方法。建议先实现一些常用的方法再来完成运算符重载，这样可以直接调用已经写好的方法，避免出错，简化代码。例如上述代码中的push_back()与append()方法可以提前写好调试完成。</p>
<p> assert()方法在<assert.h>头文件中定义，用来对内部条件进行判定。一旦内部表达式为false,就向stderr打印一条错误信息，并终止程序。</p>
<h3 id="方法实现"><a href="#方法实现" class="headerlink" title="方法实现"></a>方法实现</h3><p>下面代码实现了一些常用的方法。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span></span>&#123;			<span class="comment">//strlen方法从当前指针位置开始向后累加,计算到\0为止的字符串长度 </span></span><br><span class="line">    	<span class="type">size_t</span> length=<span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">if</span>(str==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">while</span>(*str++!=<span class="string">&#x27;\0&#x27;</span>) length++;</span><br><span class="line">    	<span class="keyword">return</span> length;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">strcpy</span><span class="params">(<span class="type">char</span> *strDest, <span class="type">const</span> <span class="type">char</span> *strSrc)</span></span>&#123;		<span class="comment">//strcpy将strSrc的内容复制到strDest中,并且返回strDest的头指针 </span></span><br><span class="line"> 	<span class="built_in">assert</span>((strDest!=<span class="literal">NULL</span>) &amp;&amp; (strSrc !=<span class="literal">NULL</span>));			<span class="comment">//如果两个字符串都是空的就直接中断 </span></span><br><span class="line"> 	<span class="type">char</span> *address = strDest;							<span class="comment">//用address指向strDest开始地址</span></span><br><span class="line"> 	<span class="keyword">while</span>( (*strDest++ = * strSrc++) != <span class="string">&#x27;\0&#x27;</span> );</span><br><span class="line"> 	<span class="keyword">return</span> address ;									<span class="comment">//返回strDest开始地址                       </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reserve</span><span class="params">(<span class="type">size_t</span> newCapacity)</span></span>&#123;			<span class="comment">//reserve用来修改的是capacity </span></span><br><span class="line">	<span class="keyword">if</span> (newCapacity&gt;_capacity)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">char</span>* str = <span class="keyword">new</span> <span class="type">char</span>[newCapacity+<span class="number">1</span>];<span class="comment">//开新的空间</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">size_t</span> i=<span class="number">0</span>;i&lt;_size;i++)&#123;</span><br><span class="line">			str[i] = _ptr[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">delete</span>[] _ptr;</span><br><span class="line">		_ptr = str;</span><br><span class="line">		_capacity = newCapacity;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">size_t</span> newSize)</span></span>&#123;							<span class="comment">//resize用来修改的是size </span></span><br><span class="line">	<span class="keyword">if</span>(newSize&gt;_capacity)&#123;								<span class="comment">//如果string容量不足，要先开辟容量 </span></span><br><span class="line">		<span class="built_in">reserve</span>(newSize);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(newSize&gt;_size)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(_ptr+_size,<span class="string">&#x27;/0&#x27;</span>, newSize-_size);	<span class="comment">//memset用来对一块空间进行初始化,这里将没有赋值但在string容器内的内存赋值为/0</span></span><br><span class="line">	&#125;</span><br><span class="line">	_size=newSize;</span><br><span class="line">	_ptr[_size]=<span class="string">&#x27;\0&#x27;</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> <span class="type">char</span>&amp; c)</span></span>&#123;				<span class="comment">//在string后面插入新的字符 </span></span><br><span class="line">	<span class="type">int</span> newCapacity;</span><br><span class="line">	<span class="keyword">if</span>(_size==_capacity)&#123;					<span class="comment">//string已满,需要扩容 </span></span><br><span class="line">		<span class="keyword">if</span>(_capacity==<span class="number">0</span>)&#123;					<span class="comment">//string的容量为0,此时扩容为 32</span></span><br><span class="line">			newCapacity=<span class="number">32</span>; 			</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			newCapacity=_capacity*<span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">reserve</span>(newCapacity);				<span class="comment">//执行实际的扩容操作 </span></span><br><span class="line">	&#125;</span><br><span class="line">	_ptr[_size]=c;</span><br><span class="line">	_size++;</span><br><span class="line">	_ptr[_size]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> _size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">capacity</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> _capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> newLength=<span class="built_in">strlen</span>(str);</span><br><span class="line">	<span class="keyword">if</span>(newLength+_size&gt;_capacity)&#123;<span class="comment">//容量不足，需要扩容 </span></span><br><span class="line">		<span class="built_in">reserve</span>(newLength+_size);</span><br><span class="line">	&#125;</span><br><span class="line">	_ptr[newLength+_size]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=_size;i&lt;=_size+newLength;i++)&#123;<span class="comment">//将str内容复制过来 </span></span><br><span class="line">		_ptr[i]=str[i-_size];</span><br><span class="line">	&#125;</span><br><span class="line">	_size+=newLength;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">size_t</span> position,<span class="type">const</span> <span class="type">char</span>&amp; c)</span></span>&#123;<span class="comment">//插入一个字符 </span></span><br><span class="line">	<span class="built_in">assert</span>(position&lt;=_size);</span><br><span class="line">	<span class="keyword">if</span> (_size == _capacity)&#123;</span><br><span class="line">		<span class="type">size_t</span> newCapacity;</span><br><span class="line">		<span class="keyword">if</span>(_capacity==<span class="number">0</span>)&#123;</span><br><span class="line">			newCapacity=<span class="number">32</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			newCapacity=_capacity*<span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">reserve</span>(newCapacity);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">size_t</span> endPosition=_size;</span><br><span class="line">	<span class="keyword">while</span> (endPosition-position)</span><br><span class="line">	&#123;</span><br><span class="line">		_ptr[endPosition] =_ptr[endPosition<span class="number">-1</span>];		<span class="comment">//将插入点后面的元素右移一位 </span></span><br><span class="line">		--endPosition;</span><br><span class="line">	&#125;</span><br><span class="line">	_ptr[position]=c; 					<span class="comment">//插入新字符 </span></span><br><span class="line">	_ptr[++_size] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">size_t</span> position, <span class="type">const</span> <span class="type">char</span>* str)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(_size+<span class="built_in">strlen</span>(str)&gt;_capacity)&#123;<span class="comment">//如果容量不足，就进行扩容 </span></span><br><span class="line">		<span class="built_in">reserve</span>(_size+<span class="built_in">strlen</span>(str));</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(str);i++)&#123;</span><br><span class="line">		<span class="built_in">insert</span>(position++,str[i]);	<span class="comment">//偷个懒，直接调用上面一个insert </span></span><br><span class="line">	&#125;</span><br><span class="line">	_ptr[_size]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(<span class="type">size_t</span> position,<span class="type">size_t</span> length)</span></span>&#123;	<span class="comment">//用来删除指定位置的指定长度字符串 </span></span><br><span class="line">	<span class="built_in">assert</span>(position&lt;_size&amp;&amp;position&gt;=<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (position+length&gt;=_size)&#123;			<span class="comment">//删除点后面没有需要保留的字符。直接将后续全部删除 </span></span><br><span class="line">		_ptr[position]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">		_size=position;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">size_t</span> start =position+length;			<span class="comment">//start为后半部分保留的字符指针，将后半部分逐个前移到删除点 </span></span><br><span class="line">	<span class="keyword">while</span>(start&lt;_size)&#123;</span><br><span class="line">		_ptr[position++] =_ptr[start++];</span><br><span class="line">	&#125;</span><br><span class="line">	_size-=length;</span><br><span class="line">	_ptr[_size]=<span class="string">&#x27;\0&#x27;</span>;						<span class="comment">//&#x27;/0&#x27;不能忘 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find</span><span class="params">(<span class="type">const</span> <span class="type">char</span>&amp; c, <span class="type">size_t</span> position=<span class="number">0</span>)</span></span>&#123;<span class="comment">//查找position位置后面的第一个c的位置 </span></span><br><span class="line">	<span class="built_in">assert</span>(position&lt;_size);</span><br><span class="line">	<span class="keyword">while</span>(position&lt;_size)&#123;</span><br><span class="line">		<span class="keyword">if</span> (_ptr[position]==c)&#123;</span><br><span class="line">			<span class="keyword">return</span> position;</span><br><span class="line">		&#125;</span><br><span class="line">		position++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;								<span class="comment">//查不到就返回-1 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">strstr</span><span class="params">(<span class="type">char</span> *src,<span class="type">char</span> *substr)</span></span>&#123; 		<span class="comment">//用于查询src中是否存在substr </span></span><br><span class="line">	<span class="built_in">assert</span>(src != <span class="literal">NULL</span> &amp;&amp; substr != <span class="literal">NULL</span>); </span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> size = <span class="built_in">strlen</span>(src); </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i,++src)&#123; </span><br><span class="line">		<span class="type">char</span> *p = src; </span><br><span class="line">		<span class="keyword">for</span>(<span class="type">char</span> *q = substr;;p++,q++)&#123; </span><br><span class="line">  		<span class="keyword">if</span>(*q == <span class="string">&#x27;\0&#x27;</span>)&#123;<span class="comment">//在src中找到连续的substr子串停止并返回 </span></span><br><span class="line">    		<span class="keyword">return</span> src; </span><br><span class="line">  			&#125; </span><br><span class="line">  		<span class="keyword">if</span>(*q != *p)&#123; </span><br><span class="line">    		<span class="keyword">break</span>; </span><br><span class="line">  			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find</span><span class="params">(<span class="type">char</span>* str, <span class="type">size_t</span> position=<span class="number">0</span>)</span></span>&#123;</span><br><span class="line">	<span class="built_in">assert</span>(position&lt; _size);</span><br><span class="line">	<span class="type">char</span>* s=<span class="built_in">strstr</span>(_ptr+position, str);</span><br><span class="line">	<span class="keyword">if</span> (s)&#123;</span><br><span class="line">		<span class="keyword">return</span> s - _ptr;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>​        这部分代码量最然比较大，但大部分内容还是常规的顺序表操作。<br>​        值得一提的是，其中reserve()方法用来修改的是_capacity的值，也就是最大容量。而resize()方法用来修改的是_size,也就是已占用的空间。这让我对_size和_capacity的意义出现了混淆。所以我使用原版的string进行了验证，令我意外的是原版的string中_size与_capacity似乎是始终相等的。于是我通过下面的代码进行测试：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	string s=<span class="string">&quot;abcabcabcabcabc&quot;</span>;                        <span class="comment">//一个随意的字符串</span></span><br><span class="line">	cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;s.size() is &quot;</span>&lt;&lt;s.<span class="built_in">size</span>()&lt;&lt;endl;              <span class="comment">//输出当前的字符串长度和容量</span></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;s.capacity() is &quot;</span>&lt;&lt;s.<span class="built_in">capacity</span>()&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	s.<span class="built_in">reserve</span>(<span class="number">600</span>);                                    <span class="comment">//将字符串扩容</span></span><br><span class="line">	s.<span class="built_in">resize</span>(<span class="number">500</span>);                                     <span class="comment">//修改字符串长度</span></span><br><span class="line">	cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;s.size() is &quot;</span>&lt;&lt;s.<span class="built_in">size</span>()&lt;&lt;endl;              <span class="comment">//再次输出字符串长度和容量</span></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;s.capacity() is &quot;</span>&lt;&lt;s.<span class="built_in">capacity</span>()&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;|&quot;</span>&lt;&lt;(<span class="type">int</span>)s[<span class="number">490</span>]&lt;&lt;<span class="string">&quot;|&quot;</span>&lt;&lt;endl;                 <span class="comment">//尝试获取新增加的有效空间的字符的ASCII码</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>得到了以下结果：</p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202306131015002.png" alt="img"></p>
<p>当我使用reserve()方法与resize()方法修改string的长度时，情况果然发生了改变。为了让结果更加明显，设置了500和600两个比较夸张的数字，得到的字符串后面出现了大量的空白。猜测是resize()导致的原字符串后面的填充，于是让程序输出后面随意一个空格的ASCII码，果然其值为0.也就是说，在string中，如果用户强行将其_size提高，那么新增的有效空间会用ASCII码为0的空字符填充。<br>    由此可见，假如用户实际使用的空间&lt;_size&lt;_capacity，那么此时string中的存储情况是这样的：</p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202306131015276.png" alt="img"></p>
<p>另外，起初我使用的resize()的值大于reserve()的值，导致结果中size和capacity仍然是同样大的。这种现象是因为，当resize()的参数值大于reserve()时，会自动调用reserve()将string进行扩容，并扩容到resize()的大小。这一点在上面的resize()方法中已经体现。</p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>下面代码实现了string的迭代器。由于是顺序存储，所以迭代器并不复杂。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span>* iterator;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">char</span>* const_iterator;</span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>&#123;<span class="comment">//首元素位置 </span></span><br><span class="line">	<span class="keyword">return</span> _ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span></span>&#123;<span class="comment">//末元素位置 </span></span><br><span class="line">	<span class="keyword">return</span> _ptr+_size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">const_iterator <span class="title">begin</span><span class="params">()</span><span class="type">const</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> _ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">const_iterator <span class="title">end</span><span class="params">()</span><span class="type">const</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> _ptr + _size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>​        为了让string能够符合用户习惯地输入和输出，需要对输入和输出进行一些处理。本质上其实属于’&lt;&lt;’和’&gt;&gt;’运算符的重载。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="comment">//在MyString对象类中，加入以下代码：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="type">const</span> MyString&amp; str);</span><br><span class="line"><span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; in, MyString&amp; str);</span><br><span class="line">    <span class="comment">//其中friend是声明友元函数。友元函数可以调用本类中的私有部分。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//在MyString对象之外加入以下代码：</span></span><br><span class="line">    </span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MyString&amp; str)&#123;<span class="comment">//重载输出运算符,注意添加头文件iostream </span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">size_t</span> i=<span class="number">0</span>;i&lt;str.<span class="built_in">size</span>();i++)&#123;				</span><br><span class="line">			out&lt;&lt;str[i];</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; in, MyString&amp; str)&#123;<span class="comment">//重载输入运算符 </span></span><br><span class="line">		<span class="type">char</span> ch;</span><br><span class="line">		str.<span class="built_in">resize</span>(<span class="number">0</span>);</span><br><span class="line">		str._size = str._capacity = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> ((ch=<span class="built_in">getchar</span>())!=EOF)&#123;</span><br><span class="line">			<span class="keyword">if</span> (ch==<span class="string">&#x27;\n&#x27;</span>)&#123;							<span class="comment">//输入以回车作为结束 </span></span><br><span class="line">				<span class="keyword">return</span> in;</span><br><span class="line">			&#125;</span><br><span class="line">			str+=ch;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​        在对‘&lt;&lt;’的重载中，主要实现的是用户可以通过cout&lt;&lt;StringName;的方式直接打印整个字符串。在对’&gt;&gt;’的重载中，主要实现的是以用户输入的回车键作为输入的结尾。当然，如果你喜欢也可以做一些个性化的输入输出设置。</p>
<h2 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a><a href="https://leetcode.cn/problems/reverse-string/">344. 反转字符串</a></h2><blockquote>
<p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。</p>
<p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p>
<p>示例 1：</p>
<p>输入：s = [“h”,”e”,”l”,”l”,”o”]<br>输出：[“o”,”l”,”l”,”e”,”h”]<br>示例 2：</p>
<p>输入：s = [“H”,”a”,”n”,”n”,”a”,”h”]<br>输出：[“h”,”a”,”n”,”n”,”a”,”H”]</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 翻转字符数组，可以直接调用reverse</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 使用双指针，左右互换直到相遇</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=s.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[left],s[right]);</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="541-反转字符串-II"><a href="#541-反转字符串-II" class="headerlink" title="541. 反转字符串 II"></a><a href="https://leetcode.cn/problems/reverse-string-ii/">541. 反转字符串 II</a></h2><blockquote>
<p>给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。</p>
<p>如果剩余字符少于 k 个，则将剩余字符全部反转。<br>如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</p>
<p>示例 1：</p>
<p>输入：s = “abcdefg”, k = 2<br>输出：”bacdfeg”<br>示例 2：</p>
<p>输入：s = “abcd”, k = 2<br>输出：”bacd”</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 翻转字符串加强版，右指针每次移动2k</span></span><br><span class="line"><span class="comment">// 最后如果left越界结束循环，right越界，left不越界则说明到了最后，需要将最后所有的翻转</span></span><br><span class="line"><span class="comment">// k大于s.size的情况优先判断</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseStr</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(k&gt;s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=k<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="type">int</span> temp = right;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                <span class="built_in">swap</span>(s[left],s[right]);</span><br><span class="line">                right--;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            right = temp+<span class="number">2</span>*k;</span><br><span class="line">            left = temp+k+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(right&gt;=s.<span class="built_in">size</span>())right=s.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 思路没理清，边界条件没考虑好，直接写代码效率很低，还是需要先理清思路再写代码</span></span><br></pre></td></tr></table></figure>
<h2 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a></h2><blockquote>
<p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p>
<p>示例 1：</p>
<p>输入：s = “We are happy.”<br>输出：”We%20are%20happy.”</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单题</span></span><br><span class="line"><span class="comment">// 直接思路，再写一个字符串，是空格+&quot;%20&quot;,不是就加原来的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">         string t;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i:s)&#123;</span><br><span class="line">             <span class="keyword">if</span>(i==<span class="string">&#x27; &#x27;</span>) t += <span class="string">&quot;%20&quot;</span>;</span><br><span class="line">             <span class="keyword">else</span> t += i;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 双指针思路，需要额外分配空间，使用指针遍历</span></span><br><span class="line"><span class="comment">// 碰到空格时移动，因为分配的空间在后面，所以需要后序遍历</span></span><br><span class="line"><span class="comment">// 前序遍历会覆盖信息</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> nums=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i:s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="string">&#x27; &#x27;</span>) nums++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> slow = s.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        s.<span class="built_in">resize</span>(s.<span class="built_in">size</span>()+<span class="number">2</span>*nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> fast=s.<span class="built_in">size</span>()<span class="number">-1</span>;fast&gt;<span class="number">0</span>;fast--,slow--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[slow] == <span class="string">&#x27; &#x27;</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                s[fast] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                s[--fast] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                s[--fast] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                s[fast] = s[slow];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 用时上可能不分上下，但是双指针占用的空间更少  </span></span><br></pre></td></tr></table></figure>
<h2 id="151-反转字符串中的单词"><a href="#151-反转字符串中的单词" class="headerlink" title="151. 反转字符串中的单词"></a><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. 反转字符串中的单词</a></h2><blockquote>
<p>给你一个字符串 s ，请你反转字符串中 单词 的顺序。</p>
<p>单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。</p>
<p>返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。</p>
<p>注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p>
<p>示例 1：</p>
<p>输入：s = “the sky is blue”<br>输出：”blue is sky the”<br>示例 2：</p>
<p>输入：s = “  hello world  “<br>输出：”world hello”<br>解释：反转后的字符串中不能存在前导空格和尾随空格。<br>示例 3：</p>
<p>输入：s = “a good   example”<br>输出：”example good a”<br>解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个题思路很重要</span></span><br><span class="line"><span class="comment">// 首先反转每个单词，再反转整体</span></span><br><span class="line"><span class="comment">// 如何翻转每个单词，需要用到双指针来判断单词的左右限</span></span><br><span class="line"><span class="comment">// 当左右指针都不为‘ ’的时候开始，先要初始化位置</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        s += <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right&lt;s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">while</span>(right&lt;s.<span class="built_in">size</span>()&amp;&amp;s[right]==<span class="string">&#x27; &#x27;</span>) s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>()+right);</span><br><span class="line">            <span class="keyword">if</span>(right&gt;=s.<span class="built_in">size</span>()) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">while</span>(s[right]!=<span class="string">&#x27; &#x27;</span>) right++; <span class="comment">// 查找第一个‘ ’位置</span></span><br><span class="line">            <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>()+left, s.<span class="built_in">begin</span>()+right);</span><br><span class="line">            left = ++right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>());</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 用时16s，这是因为调用的erase方法的时间复杂度是O(n)的</span></span><br><span class="line"><span class="comment">// 将题目中的方法改为双指针</span></span><br><span class="line"><span class="comment">// 快慢指针，遍历时先移动，然后翻转，再移动</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(string&amp; s,<span class="type">int</span> left,<span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(;left&lt;right;left++,right--)&#123;</span><br><span class="line">            <span class="type">int</span> cur = s[left];</span><br><span class="line">            s[left] = s[right];</span><br><span class="line">            s[right] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        s += <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> r=<span class="number">0</span>;r&lt;s.<span class="built_in">size</span>();r++,l++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[r]!=<span class="string">&#x27; &#x27;</span>) s[l] = s[r];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(s[r]==<span class="string">&#x27; &#x27;</span>&amp;&amp;r&lt;s.<span class="built_in">size</span>()) r++;</span><br><span class="line">                <span class="keyword">if</span>(l!=<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">reverse</span>(s,temp,l<span class="number">-1</span>);</span><br><span class="line">                    s[l] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                    temp=l+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> l--;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">resize</span>(l<span class="number">-1</span>); <span class="comment">// resize一下大小，去掉无关项</span></span><br><span class="line">        <span class="built_in">reverse</span>(s,<span class="number">0</span>,s.<span class="built_in">size</span>()); <span class="comment">// 翻转整体字符串</span></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 第一次做的时候还是有思路，不过很繁琐</span></span><br><span class="line"><span class="comment">// 首先将所有非空格的字符的下标全部记录到一个数组中</span></span><br><span class="line"><span class="comment">// 得到一个数组类似[2,3,4,5,7,8,10,11]</span></span><br><span class="line"><span class="comment">// 然后根据数组元素是否连续判断单词的位置，然后翻转坐标</span></span><br><span class="line"><span class="comment">// 但是考虑到使用双指针没有办法一次翻转，新建一个等长数组</span></span><br><span class="line"><span class="comment">// 当判断到为不连续时回溯，特殊考虑最后一次的情况</span></span><br><span class="line"><span class="comment">// 使用处理好的下标数组，新建字符串填充</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; index;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            index.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        string t;</span><br><span class="line">        <span class="type">int</span> pre = index[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = index.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; index1 = index;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;index.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp=left;</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(left&gt;=index.<span class="built_in">size</span>()<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span>(index[left+<span class="number">1</span>] -index[left]&gt;<span class="number">1</span> ) <span class="keyword">break</span>;</span><br><span class="line">                left ++;</span><br><span class="line">            &#125;</span><br><span class="line">            right = right -left +temp;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=left-temp;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                index1[right+i] = index[temp+i];</span><br><span class="line">            &#125;</span><br><span class="line">            right--;</span><br><span class="line">            left ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> &amp;i:index1)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre-i&gt;<span class="number">1</span>) t.<span class="built_in">push_back</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">            t.<span class="built_in">push_back</span>(s[i]);</span><br><span class="line">            pre = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="剑指-Offer-58-II-左旋转字符串"><a href="#剑指-Offer-58-II-左旋转字符串" class="headerlink" title="剑指 Offer 58 - II. 左旋转字符串"></a><a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">剑指 Offer 58 - II. 左旋转字符串</a></h2><blockquote>
<p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p>
<p>示例 1：</p>
<p>输入: s = “abcdefg”, k = 2<br>输出: “cdefgab”<br>示例 2：</p>
<p>输入: s = “lrloseumgh”, k = 6<br>输出: “umghlrlose”</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 与上面一样，先翻转前面的，再反转后面的，整体反转</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseLeftWords</span><span class="params">(string s, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">begin</span>()+n);</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>()+n,s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="28-找出字符串中第一个匹配项的下标"><a href="#28-找出字符串中第一个匹配项的下标" class="headerlink" title="28. 找出字符串中第一个匹配项的下标"></a><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">28. 找出字符串中第一个匹配项的下标</a></h2><blockquote>
<p>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回  -1 。</p>
<p>示例 1：</p>
<p>输入：haystack = “sadbutsad”, needle = “sad”<br>输出：0<br>解释：”sad” 在下标 0 和 6 处匹配。<br>第一个匹配项的下标是 0 ，所以返回 0 。<br>示例 2：</p>
<p>输入：haystack = “leetcode”, needle = “leeto”<br>输出：-1<br>解释：”leeto” 没有在 “leetcode” 中出现，所以返回 -1 。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匹配问题，第一反应滑动窗口+哈希表</span></span><br><span class="line"><span class="comment">// 先创建一个哈希表，然后将待查找字符写入</span></span><br><span class="line"><span class="comment">// 左右指针滑动窗口遍历</span></span><br><span class="line"><span class="comment">// 右指针开始滑动，遍历到的字符--，如果遍历的字符为负值</span></span><br><span class="line"><span class="comment">// 左指针开始滑动，直至该字符不为负值，如果右指针-左指针+1等于查找字符长度</span></span><br><span class="line"><span class="comment">// 证明字符组成一致，指针同时遍历，一致则返回left</span></span><br><span class="line"><span class="comment">// 返回左指针下标，如果达到边界条件right越界，返回-1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">hashtable</span><span class="params">(<span class="number">26</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> &amp;i:needle) hashtable[i-<span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right&lt;haystack.<span class="built_in">size</span>())&#123;</span><br><span class="line">            hashtable[haystack[right]-<span class="string">&#x27;a&#x27;</span>] --;</span><br><span class="line">            <span class="keyword">while</span>(hashtable[haystack[right]-<span class="string">&#x27;a&#x27;</span>]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                hashtable[haystack[left]-<span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">                left ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(right-left+<span class="number">1</span>==needle.<span class="built_in">size</span>())&#123;</span><br><span class="line">                <span class="type">int</span> flag=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;needle.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(needle[j]!=haystack[left+j])&#123;</span><br><span class="line">                        flag = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(flag) <span class="keyword">return</span> left;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><blockquote>
<p>在一个串中查找是否出现过另一个串，这是KMP的看家本领。</p>
</blockquote>
<p>上面的题可以采用另一个做法，也就是KMP算法，KMP主要应用在字符串匹配上。因为是由这三位学者发明的：Knuth，Morris和Pratt，所以取了三位学者名字的首字母。所以叫做KMP。</p>
<p>KMP的主要思想是<strong>当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。</strong></p>
<p>里面的关键是前缀表。了解前缀表就要先了解前缀，后缀，以及最大公共前后缀的概念。</p>
<ul>
<li><strong>前缀表有什么作用呢？</strong></li>
</ul>
<p><strong>前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。</strong></p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202306132242976.gif" alt="KMP详解1"></p>
<p>可以看出，文本串中第六个字符b 和 模式串的第六个字符f，不匹配了。如果暴力匹配，发现不匹配，此时就要从头匹配了。</p>
<p>但如果使用前缀表，就不会从头匹配，而是从上次已经匹配的内容开始匹配，找到了模式串中第三个字符b继续开始匹配。</p>
<ul>
<li><strong>前缀表是如何记录的呢？</strong></li>
</ul>
<p><strong>前缀表会记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。</strong>当前位置匹配失败，找到之前已经匹配上的位置，再重新匹配，此也意味着在某个字符失配时，前缀表会告诉你下一步匹配中，模式串应该跳到哪个位置。</p>
<ul>
<li><strong>前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串</strong>。</li>
</ul>
<p>比如：有一个字符串 abcd</p>
<p>前缀就有 a，ab，abc，三个</p>
<ul>
<li><strong>后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串</strong>。</li>
</ul>
<p>比如：有一个字符串 abcd</p>
<p>后缀就有 bcd，cd，d，三个</p>
<ul>
<li><strong>最长相等前后缀是前后缀相等的最长长度，注意无论是前缀，还是后缀都是顺序</strong></li>
</ul>
<p>比如：有一个字符串 abab</p>
<p>前缀就有 a，ab，aba，三个</p>
<p>后缀有bab，ab，b三个</p>
<p>这样最长的前后缀就是2</p>
<ul>
<li><strong>前缀表怎么计算呢</strong></li>
</ul>
<p>比如：有一个字符串 abab</p>
<p>从第一位开始，计算各个长度的最长相等前后缀</p>
<p>第一个是a，前后缀都没有，记为0</p>
<p>第二个是ab，前缀a，后缀b，没有共同，记为0</p>
<p>第三个是aba，前缀a，ab，后缀ba，a，共同为a，记为1</p>
<p>第四个是abab，前缀a，ab，aba，后缀有bab，ab，b，共同ab，记为2</p>
<p>那么该字符串的前缀表就为0,0,1,2</p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202306132241745.gif" alt="KMP精讲2"></p>
<ul>
<li><strong>前缀表的原理讲清楚了，那么如何代码实现呢？</strong></li>
</ul>
<p>很多KMP算法的实现都是使用next数组来做回退操作，next数组就可以是前缀表，但是<strong>很多实现都是把前缀表统一减一，由于前缀表的性质减一相当于（右移一位，没有匹配设为-1），之后作为next数组。这里是为了回退时直接查本位，方便后续代码使用，但是使用时需要+1。</strong></p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202306132251043.gif" alt="KMP精讲3"></p>
<p><strong>构造next数组其实就是计算模式串s，前缀表的过程。</strong> 主要有如下三步：</p>
<ol>
<li>初始化：<strong>定义两个指针i和j，j指向前缀末尾位置，i指向后缀末尾位置。</strong></li>
<li>处理前后缀不相同的情况</li>
<li>处理前后缀相同的情况</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 减一情况</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span>* next, <span class="type">const</span> string&amp; s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">-1</span>;</span><br><span class="line">    next[<span class="number">0</span>] = j; <span class="comment">// 初始值赋值为-1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 注意i从1开始</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; s[i] != s[j + <span class="number">1</span>]) &#123; <span class="comment">// 前后缀不相同了</span></span><br><span class="line">            j = next[j]; <span class="comment">// 向前回退</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == s[j + <span class="number">1</span>]) &#123; <span class="comment">// 找到相同的前后缀</span></span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        next[i] = j; <span class="comment">// 将j（前缀的长度）赋给next[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不减一情况</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span>* next, <span class="type">const</span> string&amp; s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 初始值赋值为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 注意i从1开始</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j]) &#123; <span class="comment">// j要保证大于0，因为下面有取j-1作为数组下标的操作</span></span><br><span class="line">            j = next[j<span class="number">-1</span>]; <span class="comment">// 注意这里，是要找前一位的对应的回退位置了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == s[j]) &#123; <span class="comment">// 找到相同的前后缀</span></span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        next[i] = j; <span class="comment">// 将j（前缀的长度）赋给next[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>最后得到前缀表就可以根据前缀表进行匹配。</p>
</li>
<li><p>KMP 算法虽然有着良好的理论时间复杂度上限，但大部分语言自带的字符串查找函数并不是用 KMP 算法实现的。这是因为在实现 API 时，我们需要在平均时间复杂度和最坏时间复杂度二者之间权衡。普通的暴力匹配算法以及优化的 BM 算法拥有比 KMP 算法更为优秀的平均时间复杂度；</p>
<p>学习 KMP 算法时，一定要理解其本质。如果放弃阅读晦涩难懂的材料（即使大部分讲解 KMP 算法的材料都包含大量的图，但图毕竟只能描述特殊而非一般情况）而是直接去阅读代码，是永远无法学会 KMP 算法的，甚至无法理解 KMP 算法关键代码中的任意一行。</p>
</li>
</ul>
<h2 id="459-重复的子字符串"><a href="#459-重复的子字符串" class="headerlink" title="459. 重复的子字符串"></a><a href="https://leetcode.cn/problems/repeated-substring-pattern/">459. 重复的子字符串</a></h2><blockquote>
<p>给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。</p>
<p>示例 1:</p>
<p>输入: s = “abab”<br>输出: true<br>解释: 可由子串 “ab” 重复两次构成。<br>示例 2:</p>
<p>输入: s = “aba”<br>输出: false<br>示例 3:</p>
<p>输入: s = “abcabcabcabc”<br>输出: true<br>解释: 可由子串 “abc” 重复四次构成。 (或子串 “abcabc” 重复两次构成。)</p>
</blockquote>
<p>题解参考：<a href="https://writings.sh/post/algorithm-repeated-string-pattern">周期字符串问题（两种方法） | 春水煎茶 - 王超的个人博客 (writings.sh)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 关于重复子串的问题，使用上面的KMP算法，</span></span><br><span class="line"><span class="comment">// 可以预期最后得到的前缀表是0,1,2,0,1,0,1,2,3,4,5,6,7,8...</span></span><br><span class="line"><span class="comment">// 除了最后的一个连续的序列，之前不连续的就是最小连续的字符串</span></span><br><span class="line"><span class="comment">// 要想整个字符串都由一个子串构成，那么整体长度一定和最小子串成倍数关系</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getNext</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; next;</span><br><span class="line">        next.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> r=<span class="number">1</span>;r&lt;s.<span class="built_in">size</span>();r++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(l!=<span class="number">0</span>&amp;&amp;s[l]!=s[r]) l = next[l<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(s[l]==s[r]) l++;</span><br><span class="line">            next.<span class="built_in">push_back</span>(l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; next = <span class="built_in">getNext</span>(s);</span><br><span class="line">        <span class="type">int</span> num = s.<span class="built_in">size</span>()-next.<span class="built_in">back</span>();</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>()%num||num==s.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 如果字符串在其掐头去尾的双倍字符串中，它就是周期串 。</span></span><br><span class="line"><span class="comment">// 由于以上结论，可以拼接两个字符串，然后去掉头和尾</span></span><br><span class="line"><span class="comment">// 如果中间能和原始串匹配，则必为周期串</span></span><br><span class="line"><span class="comment">// 这里也是使用KMP算法，但是应用场景有所不同</span></span><br><span class="line"><span class="comment">// 这样就是一个字符串匹配的问题</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getNext</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; next;</span><br><span class="line">        next.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> r=<span class="number">1</span>;r&lt;s.<span class="built_in">size</span>();r++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(l!=<span class="number">0</span>&amp;&amp;s[l]!=s[r]) l = next[l<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(s[l]==s[r]) l++;</span><br><span class="line">            next.<span class="built_in">push_back</span>(l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; next = <span class="built_in">getNext</span>(s);</span><br><span class="line">        string d_s = s+s;</span><br><span class="line">        d_s.<span class="built_in">pop_back</span>();</span><br><span class="line">        d_s.<span class="built_in">erase</span>(d_s.<span class="built_in">begin</span>());</span><br><span class="line">        <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;d_s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(index!=<span class="number">0</span>&amp;&amp;s[index] != d_s[i]) index = next[index<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(s[index] == d_s[i]) index++;</span><br><span class="line">            <span class="keyword">if</span>(index == s.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>字符串这里用到了之前用过很多次的双指针，滑动窗口，对于字符串翻转，左旋等问题，使用部分旋转再整体旋转的思路，到后面的KMP算法真的有些难以理解，字符串的掐头去尾判周期的方法也是真的秀，新方法get。</p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202306171806108.png" alt="BlueProtocol_20230616_195025"></p>
<p>图片记：生病发烧吃掉的四天</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++算法</tag>
      </tags>
  </entry>
  <entry>
    <title>代码随想录(day3)</title>
    <url>/link/suixiangluday3.html</url>
    <content><![CDATA[<blockquote>
<p>刷题参考：<a href="https://www.programmercarl.com/">代码随想录 (programmercarl.com)</a></p>
<p>题目来源：<a href="https://leetcode.cn/problems/binary-search">力扣（LeetCode）</a></p>
</blockquote>
<h1 id="Day-3：哈希表"><a href="#Day-3：哈希表" class="headerlink" title="Day 3：哈希表"></a>Day 3：哈希表</h1><h2 id="基础理论"><a href="#基础理论" class="headerlink" title="基础理论"></a>基础理论</h2><p>hash table也叫做散列表，<strong>哈希表是根据关键码的值而直接进行访问的数据结构</strong>。<strong>当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法</strong>。</p>
<p>但是哈希法也是<strong>牺牲了空间换取了时间</strong>，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/2021010423484818.png" alt="哈希表2"></p>
<p>上面是一个简单的哈希表，哈希表就是将一些现实的变量，通过哈希函数转换为一些固定的码值，然后将值保存到数组位置，当想查询时，现将名称转换为对应的码值，再使用码值查询。</p>
<p>如果学生的数量大于哈希表的大小怎么办，此时就算哈希函数计算的再均匀，也避免不了会有几位学生的名字同时映射到哈希表 同一个索引下标的位置。这时候就说发生了<strong>哈希碰撞</strong>。</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/2021010423494884.png" alt="哈希表3"></p>
<p>一般哈希碰撞有两种解决方法， 拉链法和线性探测法。</p>
<ul>
<li>拉链法：发生冲突的元素都被存储在链表中，要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。</li>
</ul>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210104235015226.png" alt="哈希表4"></p>
<ul>
<li>线性探测法：使用线性探测法，一定要保证tableSize大于dataSize。 我们需要依靠哈希表中的空位来解决碰撞问题。</li>
</ul>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210104235109950.png" alt="哈希表5"></p>
<h2 id="常见的三种哈希结构"><a href="#常见的三种哈希结构" class="headerlink" title="常见的三种哈希结构"></a>常见的三种哈希结构</h2><p>当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。</p>
<ul>
<li>数组</li>
<li>set （集合）</li>
<li>map(映射)</li>
</ul>
<p>这里数组就没啥可说的了，我们来看一下set。</p>
<p>在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>集合</th>
<th>底层实现</th>
<th>是否有序</th>
<th>数值是否可以重复</th>
<th>能否更改数值</th>
<th>查询效率</th>
<th>增删效率</th>
</tr>
</thead>
<tbody>
<tr>
<td>std::set</td>
<td>红黑树</td>
<td>有序</td>
<td>否</td>
<td>否</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td>std::multiset</td>
<td>红黑树</td>
<td>有序</td>
<td>是</td>
<td>否</td>
<td>O(logn)</td>
<td>O(logn)</td>
</tr>
<tr>
<td>std::unordered_set</td>
<td>哈希表</td>
<td>无序</td>
<td>否</td>
<td>否</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
</div>
<p>std::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>映射</th>
<th>底层实现</th>
<th>是否有序</th>
<th>数值是否可以重复</th>
<th>能否更改数值</th>
<th>查询效率</th>
<th>增删效率</th>
</tr>
</thead>
<tbody>
<tr>
<td>std::map</td>
<td>红黑树</td>
<td>key有序</td>
<td>key不可重复</td>
<td>key不可修改</td>
<td>O(logn)</td>
<td>O(logn)</td>
</tr>
<tr>
<td>std::multimap</td>
<td>红黑树</td>
<td>key有序</td>
<td>key可重复</td>
<td>key不可修改</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td>std::unordered_map</td>
<td>哈希表</td>
<td>key无序</td>
<td>key不可重复</td>
<td>key不可修改</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
</div>
<p>std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。</p>
<p>当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。</p>
<p>那么再来看一下map ，在map 是一个key value 的数据结构，map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。</p>
<h2 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242. 有效的字母异位词"></a><a href="https://leetcode.cn/problems/valid-anagram/">242. 有效的字母异位词</a></h2><blockquote>
<p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p>
<p>注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。</p>
<p>示例 1:</p>
<p>输入: s = “anagram”, t = “nagaram”<br>输出: true<br>示例 2:</p>
<p>输入: s = “rat”, t = “car”<br>输出: false</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把字符加入hash表，一个加一个减，最后遍历，都为0返回</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span>&amp; i:s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mp[i]) mp[i]++;</span><br><span class="line">            <span class="keyword">else</span> mp[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span>&amp; i:t)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mp.<span class="built_in">find</span>(i)!=mp.<span class="built_in">end</span>()) mp[i]--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i:mp)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i.second) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 用时12ms，此时使用的结构为map</span></span><br><span class="line"><span class="comment">// 更换为数组实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mp</span><span class="params">(<span class="number">26</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i:s) mp[i-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i:t) mp[i-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i:mp) <span class="keyword">if</span>(i) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 用时8ms，数组实现比map实现更快</span></span><br></pre></td></tr></table></figure>
<h2 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383. 赎金信"></a><a href="https://leetcode.cn/problems/ransom-note/">383. 赎金信</a></h2><blockquote>
<p>给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。</p>
<p>如果可以，返回 true ；否则返回 false 。</p>
<p>magazine 中的每个字符只能在 ransomNote 中使用一次。</p>
<p>示例 1：</p>
<p>输入：ransomNote = “a”, magazine = “b”<br>输出：false<br>示例 2：</p>
<p>输入：ransomNote = “aa”, magazine = “ab”<br>输出：false<br>示例 3：</p>
<p>输入：ransomNote = “aa”, magazine = “aab”<br>输出：true</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 26个字母？组成？计数！哈希表！数组！！</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">hash</span><span class="params">(<span class="number">26</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i:magazine) hash[i-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i:ransomNote) hash[i-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i:hash) <span class="keyword">if</span>(i&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a><a href="https://leetcode.cn/problems/group-anagrams/">49. 字母异位词分组</a></h2><blockquote>
<p>给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。</p>
<p>字母异位词 是由重新排列源单词的所有字母得到的一个新单词。</p>
<p>示例 1:</p>
<p>输入: strs = [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”]<br>输出: [[“bat”],[“nat”,”tan”],[“ate”,”eat”,”tea”]]<br>示例 2:</p>
<p>输入: strs = [“”]<br>输出: [[“”]]<br>示例 3:</p>
<p>输入: strs = [“a”]<br>输出: [[“a”]]</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中等题，将字母异位词组合在一起</span></span><br><span class="line"><span class="comment">// 常规思路，对字符串进行排序，排序完成后的字符串作为键值</span></span><br><span class="line"><span class="comment">// 键值对应的数值为字符串数组，最后遍历字典就能得到结果</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        unordered_map&lt;string, vector&lt;string&gt;&gt; mp;</span><br><span class="line">        <span class="keyword">for</span> (string&amp; str: strs) &#123;</span><br><span class="line">                string key = str;</span><br><span class="line">                <span class="built_in">sort</span>(key.<span class="built_in">begin</span>(), key.<span class="built_in">end</span>());</span><br><span class="line">                mp[key].<span class="built_in">emplace_back</span>(str);</span><br><span class="line">            &#125;</span><br><span class="line">            vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">                ans.<span class="built_in">emplace_back</span>(it-&gt;second);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词"></a><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词</a></h2><blockquote>
<p>给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p>
<p>异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。</p>
<p>示例 1:</p>
<p>输入: s = “cbaebabacd”, p = “abc”<br>输出: [0,6]<br>解释:<br>起始索引等于 0 的子串是 “cba”, 它是 “abc” 的异位词。<br>起始索引等于 6 的子串是 “bac”, 它是 “abc” 的异位词。<br> 示例 2:</p>
<p>输入: s = “abab”, p = “ab”<br>输出: [0,1,2]<br>解释:<br>起始索引等于 0 的子串是 “ab”, 它是 “ab” 的异位词。<br>起始索引等于 1 的子串是 “ba”, 它是 “ab” 的异位词。<br>起始索引等于 2 的子串是 “ab”, 它是 “ab” 的异位词。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先想到的应该是哈希表+固定大小滑动窗口</span></span><br><span class="line"><span class="comment">// 结合上一题，也可以看成是排序后查找相同key值，但是由于排序操作，大字符串会超时</span></span><br><span class="line"><span class="comment">// 判断哈希表中正元素的个数来替代排序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>()&lt;p.<span class="built_in">size</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span>&amp;i:p)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash.<span class="built_in">find</span>(i)==hash.<span class="built_in">end</span>()) hash[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> hash[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=p.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> need=p.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash.<span class="built_in">find</span>(s[i])!=hash.<span class="built_in">end</span>())&#123;</span><br><span class="line">                hash[s[i]]--;</span><br><span class="line">                <span class="keyword">if</span>(hash[s[i]]&gt;=<span class="number">0</span>) need--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(;right&lt;s.<span class="built_in">size</span>();right++,left++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash.<span class="built_in">find</span>(s[right])!=hash.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                hash[s[right]]--;</span><br><span class="line">                <span class="keyword">if</span>(hash[s[right]]&gt;=<span class="number">0</span>) need--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (need==<span class="number">0</span>) res.<span class="built_in">emplace_back</span>(left);</span><br><span class="line">            <span class="keyword">if</span>(hash.<span class="built_in">find</span>(s[left])!=hash.<span class="built_in">end</span>())&#123;</span><br><span class="line">                hash[s[left]]++;</span><br><span class="line">                <span class="keyword">if</span>(hash[s[left]]&gt;<span class="number">0</span>) need++;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 以上方法运行用时16s</span></span><br><span class="line"><span class="comment">// 将上述方法的哈希表map换成数组，当right指针是字符串以外的数，哈希表中对应位置小于0</span></span><br><span class="line"><span class="comment">// 调整左指针到恰当位置，使得哈希表中对应位置等于0；</span></span><br><span class="line"><span class="comment">// 如果right指针连续指向的都为正确字符，当右指针-左指针+1 与字符串p等长时，证明找到了相同构造的字符串</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>()&lt;p.<span class="built_in">size</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">hash</span><span class="params">(<span class="number">26</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i:p) hash[i-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;r&lt;s.<span class="built_in">size</span>();r++)&#123;</span><br><span class="line">            hash[s[r]-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            <span class="keyword">while</span>(hash[s[r]-<span class="string">&#x27;a&#x27;</span>]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                hash[s[l]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(r-l+<span class="number">1</span>==p.<span class="built_in">size</span>()) res.<span class="built_in">push_back</span>(l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 运行时长8ms</span></span><br></pre></td></tr></table></figure>
<h2 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a><a href="https://leetcode.cn/problems/intersection-of-two-arrays/">349. 两个数组的交集</a></h2><blockquote>
<p>给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。</p>
<p>示例 1：</p>
<p>输入：nums1 = [1,2,2,1], nums2 = [2,2]<br>输出：[2]<br>示例 2：</p>
<p>输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]<br>输出：[9,4]<br>解释：[4,9] 也是可通过的</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先应该可以想到的是排序双指针</span></span><br><span class="line"><span class="comment">// 还可以想到的是哈希表，保存一个，然后另一个对比</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; out;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; hashtable;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i:nums1) </span><br><span class="line">            <span class="keyword">if</span>(hashtable.<span class="built_in">find</span>(i)==hashtable.<span class="built_in">end</span>())</span><br><span class="line">                hashtable[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums2.<span class="built_in">begin</span>(),nums2.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i:nums2) </span><br><span class="line">            <span class="keyword">if</span>(hashtable.<span class="built_in">find</span>(i)!=hashtable.<span class="built_in">end</span>())</span><br><span class="line">               <span class="keyword">if</span>(out.<span class="built_in">empty</span>()||i != out.<span class="built_in">back</span>())out.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="350-两个数组的交集-II"><a href="#350-两个数组的交集-II" class="headerlink" title="350. 两个数组的交集 II"></a><a href="https://leetcode.cn/problems/intersection-of-two-arrays-ii/">350. 两个数组的交集 II</a></h2><blockquote>
<p>给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。</p>
<p>示例 1：</p>
<p>输入：nums1 = [1,2,2,1], nums2 = [2,2]<br>输出：[2,2]<br>示例 2:</p>
<p>输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]<br>输出：[4,9]</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 上一题中因为重复还要判断一下去重，这个不用了</span></span><br><span class="line"><span class="comment">// 但要考虑个数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersect</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; out;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; hashtable;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i:nums1) </span><br><span class="line">            <span class="keyword">if</span>(hashtable.<span class="built_in">find</span>(i)==hashtable.<span class="built_in">end</span>())</span><br><span class="line">                hashtable[i]=<span class="number">1</span>;</span><br><span class="line">        	<span class="keyword">else</span> hashtable[i]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i:nums2) </span><br><span class="line">            <span class="keyword">if</span>(hashtable.<span class="built_in">find</span>(i)!=hashtable.<span class="built_in">end</span>())&#123;</span><br><span class="line">                hashtable[i]--;</span><br><span class="line">               <span class="keyword">if</span>(hashtable[i]&gt;=<span class="number">0</span>) out.<span class="built_in">push_back</span>(i);</span><br><span class="line">            &#125; </span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a><a href="https://leetcode.cn/problems/happy-number/">202. 快乐数</a></h2><blockquote>
<p>编写一个算法来判断一个数 n 是不是快乐数。</p>
<p>「快乐数」 定义为：</p>
<p>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。<br>然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。<br>如果这个过程 结果为 1，那么这个数就是快乐数。<br>如果 n 是 快乐数 就返回 true ；不是，则返回 false 。</p>
<p>示例 1：</p>
<p>输入：n = 19<br>输出：true<br>解释：<br>$1^2 + 9^2 = 82$<br>$8^2 + 2^2 = 68$<br>$6^2 + 8^2 = 100$<br>$1^2 + 0^2 + 0^2 = 1$<br>示例 2：</p>
<p>输入：n = 2<br>输出：false</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 题目说的比较清楚，只存在两种情况，最后返回1，否则出现循环</span></span><br><span class="line"><span class="comment">// 因此，挨个计算，当为1时返回true，当出现重复值时，返回false</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            <span class="type">int</span> num = n%<span class="number">10</span>;</span><br><span class="line">            sum += num*num;</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; hash;</span><br><span class="line">        hash.<span class="built_in">insert</span>(n);</span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">1</span>)&#123;</span><br><span class="line">            n = <span class="built_in">sum</span>(n);</span><br><span class="line">            <span class="keyword">if</span>(hash.<span class="built_in">find</span>(n)==hash.<span class="built_in">end</span>()) hash.<span class="built_in">insert</span>(n);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></h2><blockquote>
<p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
<p>示例 1：</p>
<p>输入：nums = [2,7,11,15], target = 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。<br>示例 2：</p>
<p>输入：nums = [3,2,4], target = 6<br>输出：[1,2]<br>示例 3：</p>
<p>输入：nums = [3,3], target = 6<br>输出：[0,1]</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 梦开始的地方两数之和，可以暴力双循环</span></span><br><span class="line"><span class="comment">// 这里使用哈希表的高效查找，第一遍将数组写入哈希表，第二遍开始查，只需要两遍</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hashtable;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++) hashtable[target-nums[i]] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++) </span><br><span class="line">            <span class="keyword">if</span>(hashtable.<span class="built_in">find</span>(nums[i])!=hashtable.<span class="built_in">end</span>())</span><br><span class="line">                <span class="keyword">if</span>(i != hashtable[nums[i]])</span><br><span class="line">                    <span class="keyword">return</span> &#123;i,hashtable[nums[i]]&#125;;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 用时20ms</span></span><br><span class="line"><span class="comment">// 修改一下，因为假设只存在一组，所以可以单次循环中先插后查</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hashtable;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hashtable.<span class="built_in">find</span>(nums[i])!=hashtable.<span class="built_in">end</span>())&#123;</span><br><span class="line">                 <span class="keyword">if</span>(i != hashtable[nums[i]])</span><br><span class="line">                    <span class="keyword">return</span> &#123;i,hashtable[nums[i]]&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> hashtable[target-nums[i]] = i;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 用时12ms</span></span><br></pre></td></tr></table></figure>
<h2 id="454-四数相加-II"><a href="#454-四数相加-II" class="headerlink" title="454. 四数相加 II"></a><a href="https://leetcode.cn/problems/4sum-ii/">454. 四数相加 II</a></h2><blockquote>
<p>给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：</p>
<p>0 &lt;= i, j, k, l &lt; n<br>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</p>
<p>示例 1：</p>
<p>输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]<br>输出：2<br>解释：<br>两个元组如下：</p>
<ol>
<li>(0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0</li>
<li>(1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0<br>示例 2：</li>
</ol>
<p>输入：nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]<br>输出：1</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// n数之和，分组+两数相加</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, vector&lt;<span class="type">int</span>&gt;&amp; nums3, vector&lt;<span class="type">int</span>&gt;&amp; nums4)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>&amp;i:nums1)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span>&amp;j:nums2)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mp[i+j]) mp[i+j]++;</span><br><span class="line">                <span class="keyword">else</span> mp[i+j]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>&amp;i:nums3)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span>&amp;j:nums4)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mp[-i-j]) res+=mp[-i-j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 运行时间224ms，当数据量较大时，使用迭代器能够实现更快的效果</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, vector&lt;<span class="type">int</span>&gt;&amp; nums3, vector&lt;<span class="type">int</span>&gt;&amp; nums4)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>&amp;i:nums1)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span>&amp;j:nums2)&#123;</span><br><span class="line">                it = mp.<span class="built_in">find</span>(i+j);</span><br><span class="line">                <span class="keyword">if</span>(it==mp.<span class="built_in">end</span>()) mp[i+j]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> it-&gt;second++; <span class="comment">// 使用迭代器取值，减少一次取值时间</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>&amp;i:nums3)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span>&amp;j:nums4)&#123;</span><br><span class="line">                it = mp.<span class="built_in">find</span>(-i-j);</span><br><span class="line">                <span class="keyword">if</span>(it!=mp.<span class="built_in">end</span>()) res+=it-&gt;second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></h2><blockquote>
<p>给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请</p>
<p>你返回所有和为 0 且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<p>示例 1：</p>
<p>输入：nums = [-1,0,1,2,-1,-4]<br>输出：[[-1,-1,2],[-1,0,1]]<br>解释：<br>nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。<br>nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。<br>nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。<br>不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。<br>注意，输出的顺序和三元组的顺序并不重要。<br>示例 2：</p>
<p>输入：nums = [0,1,1]<br>输出：[]<br>解释：唯一可能的三元组和不为 0 。<br>示例 3：</p>
<p>输入：nums = [0,0,0]<br>输出：[[0,0,0]]<br>解释：唯一可能的三元组和为 0 。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 梦碎的地方三数之和</span></span><br><span class="line"><span class="comment">// 直接三重循环，暴力解法，超时</span></span><br><span class="line"><span class="comment">// 排序+分组哈希表+去重 正常去重超时，智商不够，下一个</span></span><br><span class="line"><span class="comment">// 排序+双指针，因为这道题不要求下标，只需要考虑值的情况就好了</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>()<span class="number">-2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">0</span> &amp;&amp; nums[i]==nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> left = i+<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> right = i+<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">while</span>(nums[right]+nums[left]+nums[i]&lt;<span class="number">0</span>&amp;&amp;left&gt;=right) &#123;</span><br><span class="line">                <span class="keyword">if</span>(right&lt;nums.<span class="built_in">size</span>()<span class="number">-1</span>) right++;</span><br><span class="line">                <span class="keyword">else</span> left++;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">while</span>(left&lt;right&amp;&amp;right&lt;nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">                <span class="type">int</span> sum=nums[right]+nums[left]+nums[i];</span><br><span class="line">                <span class="keyword">if</span> (sum&gt;<span class="number">0</span>) right--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;<span class="number">0</span>)left++;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(&#123;nums[i],nums[left],nums[right]&#125;);</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                    <span class="keyword">while</span>(nums[left]==nums[left<span class="number">-1</span>]&amp;&amp;left&lt;right)left++;</span><br><span class="line">                    <span class="keyword">while</span>(nums[right]==nums[right+<span class="number">1</span>]&amp;&amp;left&lt;right)right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 人麻了，调试了半小时边界条件</span></span><br><span class="line"><span class="comment">// 主要步骤，首先排序，然后从第一个位置开始遍历，每次遍历寻找另外两个位置；</span></span><br><span class="line"><span class="comment">// 首先确定左右指针的极限位置，然后相向运动，直至相撞</span></span><br></pre></td></tr></table></figure>
<h2 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a><a href="https://leetcode.cn/problems/4sum/">18. 四数之和</a></h2><blockquote>
<p>给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：</p>
<p>0 &lt;= a, b, c, d &lt; n<br>a、b、c 和 d 互不相同<br>nums[a] + nums[b] + nums[c] + nums[d] == target<br>你可以按 任意顺序 返回答案 。 </p>
<p>示例 1：</p>
<p>输入：nums = [1,0,-1,0,-2,2], target = 0<br>输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]<br>示例 2：</p>
<p>输入：nums = [2,2,2,2,2], target = 8<br>输出：[[2,2,2,2]]</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 四数之和是三数之和的扩展，注意测试中有很大的数，相加超过了int的上下限，需要改为long</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span>&amp; target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&lt;<span class="number">4</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;nums.<span class="built_in">size</span>()<span class="number">-3</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target&gt;=<span class="number">0</span>&amp;&amp;nums[j]&gt;target) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(j!=<span class="number">0</span> &amp;&amp; nums[j]==nums[j<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=j+<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>()<span class="number">-2</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i!=j+<span class="number">1</span> &amp;&amp; nums[i]==nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> left = i+<span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> right = i+<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">while</span>((<span class="type">long</span>)nums[right]+nums[left]+nums[i]+nums[j]&lt;target&amp;&amp;left&lt;right) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(right&lt;nums.<span class="built_in">size</span>()<span class="number">-1</span>) right++;</span><br><span class="line">                    <span class="keyword">else</span> left++;</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">while</span>(left&lt;right&amp;&amp;right&lt;nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">                    <span class="type">long</span> sum=(<span class="type">long</span>)nums[right]+nums[left]+nums[i]+nums[j];</span><br><span class="line">                    <span class="keyword">if</span> (sum&gt;target) right--;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;target)left++;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        res.<span class="built_in">push_back</span>(&#123;nums[j],nums[i],nums[left],nums[right]&#125;);</span><br><span class="line">                        left++;</span><br><span class="line">                        right--;</span><br><span class="line">                        <span class="keyword">while</span>(nums[left]==nums[left<span class="number">-1</span>]&amp;&amp;left&lt;right)left++;</span><br><span class="line">                        <span class="keyword">while</span>(nums[right]==nums[right+<span class="number">1</span>]&amp;&amp;left&lt;right)right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从开始的简单的使用哈希表对字符进行计数，到后面的字符串作为key，再到哈希表与双指针的结合，使用迭代器对程序进行加速，重点的两数之和，由于是返回下标所以用哈希表做比较好，但是也可使用返回排序后下标的排序，在使用双指针，后面的n数之和也是使用双指针+循环的方法，但要注意去重的实现，n数相加可以将其分为两部分，转换为两数之和，使用哈希表进行处理。</p>
<p>总之，这一章真的有很多内容，哈希表的使用，双指针的使用，再来一遍估计还有可能卡住，有些地方的条件还是需要调试。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++算法</tag>
      </tags>
  </entry>
  <entry>
    <title>代码随想录(day2)</title>
    <url>/link/suixiangluday2.html</url>
    <content><![CDATA[<blockquote>
<p>刷题参考：<a href="https://www.programmercarl.com/">代码随想录 (programmercarl.com)</a></p>
<p>题目来源：<a href="https://leetcode.cn/problems/binary-search">力扣（LeetCode）</a></p>
</blockquote>
<h1 id="Day-2：链表"><a href="#Day-2：链表" class="headerlink" title="Day 2：链表"></a>Day 2：链表</h1><h2 id="基础理论"><a href="#基础理论" class="headerlink" title="基础理论"></a>基础理论</h2><ul>
<li>单链表：链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）。链表的入口节点称为链表的头结点也就是head。</li>
</ul>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806194529815.png" alt="链表1"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 还是有必要手写一下链表的结构的</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    <span class="built_in">ListNode</span>()</span><br><span class="line">        :<span class="built_in">val</span>(<span class="number">0</span>),<span class="built_in">next</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x)</span><br><span class="line">        :<span class="built_in">val</span>(x),<span class="built_in">next</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x,ListNode* y)</span><br><span class="line">        :<span class="built_in">val</span>(x),<span class="built_in">next</span>(y)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结构体里包含两个数据以及三个构造函数</span></span><br></pre></td></tr></table></figure>
<ul>
<li>双链表：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。双链表 既可以向前查询也可以向后查询。</li>
</ul>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806194559317.png" alt="链表2"></p>
<ul>
<li>循环链表：链表首尾相连。循环链表可以用来解决约瑟夫环问题。</li>
</ul>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806194629603.png" alt="链表4"></p>
<ul>
<li>删除节点</li>
</ul>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806195114541-20230310121459257.png" alt="链表-删除节点"></p>
<p>只要将C节点的next指针 指向E节点就可以了。</p>
<p>那有同学说了，D节点不是依然存留在内存里么？只不过是没有在这个链表里而已。</p>
<p>是这样的，所以在C++里<strong>最好是再手动释放这个D节点，释放这块内存</strong>。</p>
<p>其他语言例如Java、Python，就有自己的内存回收机制，就不用自己手动释放了。</p>
<ul>
<li>添加节点</li>
</ul>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806195134331-20230310121503147.png" alt="链表-添加节点"></p>
<p>可以看出链表的增添和删除都是O(1)操作，也不会影响到其他节点。</p>
<p>但是要注意，<strong>要是删除第五个节点，需要从头节点查找到第四个节点通过next指针进行删除操作，查找的时间复杂度是O(n)。</strong></p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806195200276.png" alt="链表-链表与数据性能对比"></p>
<h2 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203. 移除链表元素"></a><a href="https://leetcode.cn/problems/remove-linked-list-elements/">203. 移除链表元素</a></h2><blockquote>
<p>给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。</p>
<p>示例 1：</p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg" alt="img"></p>
<p>输入：head = [1,2,6,3,4,5,6], val = 6<br>输出：[1,2,3,4,5]<br>示例 2：</p>
<p>输入：head = [], val = 1<br>输出：[]<br>示例 3：</p>
<p>输入：head = [7,7,7,7], val = 7<br>输出：[]</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 算是二刷了，简单题</span></span><br><span class="line"><span class="comment">// 判断当前节点的下一个节点值是否为指定值，是则下个节点指向下下个</span></span><br><span class="line"><span class="comment">// 不是将节点移动到下一个</span></span><br><span class="line"><span class="comment">// 在链表章节，使用虚拟头是一个十分关键的点，能省很多事，比如为空的情况等等</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* vhead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);  <span class="comment">// 创建虚拟头</span></span><br><span class="line">        vhead-&gt;next = head;</span><br><span class="line">        ListNode* cur=vhead;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;next-&gt;val==val)&#123; </span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vhead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707. 设计链表"></a><a href="https://leetcode.cn/problems/design-linked-list/">707. 设计链表</a></h2><blockquote>
<p>你可以选择使用单链表或者双链表，设计并实现自己的链表。</p>
<p>单链表中的节点应该具备两个属性：val 和 next 。val 是当前节点的值，next 是指向下一个节点的指针/引用。</p>
<p>如果是双向链表，则还需要属性 prev 以指示链表中的上一个节点。假设链表中的所有节点下标从 0 开始。</p>
<p>实现 MyLinkedList 类：</p>
<p>MyLinkedList() 初始化 MyLinkedList 对象。<br>int get(int index) 获取链表中下标为 index 的节点的值。如果下标无效，则返回 -1 。<br>void addAtHead(int val) 将一个值为 val 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。<br>void addAtTail(int val) 将一个值为 val 的节点追加到链表中作为链表的最后一个元素。<br>void addAtIndex(int index, int val) 将一个值为 val 的节点插入到链表中下标为 index 的节点之前。如果 index 等于链表的长度，那么该节点会被追加到链表的末尾。如果 index 比长度更大，该节点将 不会插入 到链表中。<br>void deleteAtIndex(int index) 如果下标有效，则删除链表中下标为 index 的节点。</p>
<p>示例：</p>
<p>输入<br>[“MyLinkedList”, “addAtHead”, “addAtTail”, “addAtIndex”, “get”, “deleteAtIndex”, “get”]<br>[[], [1], [3], [1, 2], [1], [1], [1]]<br>输出<br>[null, null, null, null, 2, null, 3]</p>
<p>解释<br>MyLinkedList myLinkedList = new MyLinkedList();<br>myLinkedList.addAtHead(1);<br>myLinkedList.addAtTail(3);<br>myLinkedList.addAtIndex(1, 2);    // 链表变为 1-&gt;2-&gt;3<br>myLinkedList.get(1);              // 返回 2<br>myLinkedList.deleteAtIndex(1);    // 现在，链表变为 1-&gt;3<br>myLinkedList.get(1);              // 返回 3</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 作为一个中等难度的题，其实也没有太多难的地方，简单题的集合，能够对链表有更清晰的理解</span></span><br><span class="line"><span class="comment">// 本身作为一个类，里面是没有链表节点的定义的，也就是需要自己先写一个结构体/类来定义节点</span></span><br><span class="line"><span class="comment">// 作为一个数据结构类，最基本的应该有size大小，并且有个初始的节点，这里初始化一个虚拟头，方便操作</span></span><br><span class="line"><span class="comment">// 完成构造函数的初始化</span></span><br><span class="line"><span class="comment">// 按照顺序来进行类方法的编写：初始化-&gt; 插入数据 -&gt; 获取数据 -&gt; 指定删除数据 -&gt; 指定插入</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ListNode</span>&#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        ListNode* next;</span><br><span class="line">        <span class="built_in">ListNode</span>()</span><br><span class="line">            :<span class="built_in">val</span>(<span class="number">0</span>),<span class="built_in">next</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">        <span class="built_in">ListNode</span>(<span class="type">int</span> val)</span><br><span class="line">            :<span class="built_in">val</span>(val),<span class="built_in">next</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    ListNode* vhead;</span><br><span class="line">    <span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        vhead = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;=<span class="number">0</span> &amp;&amp; index &lt; size)&#123;</span><br><span class="line">            ListNode* cur = vhead;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=index;i++) cur = cur-&gt;next;</span><br><span class="line">            <span class="keyword">return</span> cur-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">        ListNode* head = vhead-&gt;next;</span><br><span class="line">        vhead-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">        vhead-&gt;next-&gt;next = head; </span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">        ListNode* cur = vhead;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next) cur = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; index, <span class="type">const</span> <span class="type">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;=<span class="number">0</span>) <span class="built_in">addAtHead</span>(val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(index&lt;=size)&#123;</span><br><span class="line">            ListNode* cur = vhead;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;index;i++) cur = cur-&gt;next;</span><br><span class="line">            ListNode* temp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">            cur-&gt;next-&gt;next = temp;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;=<span class="number">0</span> &amp;&amp; index &lt; size)&#123;</span><br><span class="line">            ListNode* cur = vhead;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;index;i++) cur = cur-&gt;next;</span><br><span class="line">            ListNode* temp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = temp-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> temp;</span><br><span class="line">            <span class="keyword">if</span>(size) size --;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList* obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(index);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 碰到了一些问题，由于部分代码可以复用，导致copy代码时没注意修改变量</span></span><br><span class="line"><span class="comment">// 调了半个小时发现是index写成了size，引以为戒</span></span><br></pre></td></tr></table></figure>
<h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></h2><blockquote>
<p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p>
<p>示例 1：</p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="img"></p>
<p>输入：head = [1,2,3,4,5]<br>输出：[5,4,3,2,1]<br>示例 2：</p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" alt="img"></p>
<p>输入：head = [1,2]<br>输出：[2,1]<br>示例 3：</p>
<p>输入：head = []<br>输出：[]</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 话不多说，先上链表头，等等，好像不用</span></span><br><span class="line"><span class="comment">// 链表翻转的步骤，首先确定初始状态，要想后面指向前一个，需要两个指针来完成</span></span><br><span class="line"><span class="comment">// 加入有两个元素，那么第一个指向null，与第二个之间的联系就断了，也就是需要有额外的指针辅助</span></span><br><span class="line"><span class="comment">// 所以当转换开始时应该是null &lt;- 0  1-&gt; null</span></span><br><span class="line"><span class="comment">// 这时候右指针指向左指针即0&lt;-1，会丢掉右指针的下一位信息，所以需要先保存下右指针的下一位作为临时变量</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* left = head;</span><br><span class="line">        ListNode* right = head-&gt;next;</span><br><span class="line">        left-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            ListNode* temp = right-&gt;next;</span><br><span class="line">            right-&gt;next = left;</span><br><span class="line">            left = right;</span><br><span class="line">            right = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></h2><blockquote>
<p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>
<p>示例 1：</p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg" alt="img"></p>
<p>输入：head = [1,2,3,4]<br>输出：[2,1,4,3]<br>示例 2：</p>
<p>输入：head = []<br>输出：[]<br>示例 3：</p>
<p>输入：head = [1]<br>输出：[1]</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先来个虚拟头，可以看到又是交换，双指针安排</span></span><br><span class="line"><span class="comment">// 当没有交换的时候，快指针每隔两个一次，慢指针交换后的下一个即为下次的交换的慢指针</span></span><br><span class="line"><span class="comment">// 交换时，先将慢指针指向快指针的下一个，慢指针的上一位指向快指针，快指针指向慢指针</span></span><br><span class="line"><span class="comment">// 慢指针的上位更新为慢指针，慢指针更新为慢指针下一位，快指针更新为慢指针的下一位</span></span><br><span class="line"><span class="comment">// 以上操作最少需要两个元素，为空和只有单个元素的情况，单独考虑</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span> || head-&gt;next==<span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* vhead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        vhead-&gt;next = head;</span><br><span class="line">        ListNode* temp=vhead;</span><br><span class="line">        ListNode* left=head;</span><br><span class="line">        ListNode* right = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>( right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            left-&gt;next = right-&gt;next;</span><br><span class="line">            temp-&gt;next = right;</span><br><span class="line">            right-&gt;next = left;</span><br><span class="line">            temp = left;</span><br><span class="line">            left = left-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(left== <span class="literal">nullptr</span>) <span class="keyword">break</span>;</span><br><span class="line">            right = left-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vhead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h2><blockquote>
<p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p>
<p>示例 1：</p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" alt="img"></p>
<p>输入：head = [1,2,3,4,5], n = 2<br>输出：[1,2,3,5]<br>示例 2：</p>
<p>输入：head = [1], n = 1<br>输出：[]<br>示例 3：</p>
<p>输入：head = [1,2], n = 1<br>输出：[1]</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 上来先加个虚拟头，然后一看题目，删除倒数的index</span></span><br><span class="line"><span class="comment">// 首先想到，先遍历一边求总数，再减一下，得到正序，变简单题</span></span><br><span class="line"><span class="comment">// 但是，需要遍历两次，有没有遍历一次的方法呢</span></span><br><span class="line"><span class="comment">// 没错，又又又是双指针，两个指针，一个先动，一个不动</span></span><br><span class="line"><span class="comment">// 当先动的指针动了n步后，两个一起开始动，当先动的到末尾，后动的刚好是需要删除的位置</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* vhead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        vhead-&gt;next=head;</span><br><span class="line">        ListNode* left = vhead;</span><br><span class="line">        ListNode* right = vhead;</span><br><span class="line">        <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num&gt;n) left = left-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> num++;</span><br><span class="line">            right = right-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        left-&gt;next = left-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> vhead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="面试题-02-07-链表相交"><a href="#面试题-02-07-链表相交" class="headerlink" title="面试题 02.07. 链表相交"></a><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">面试题 02.07. 链表相交</a></h2><blockquote>
<p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</p>
<p>图示两个链表在节点 c1 开始相交：</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt="img"></p>
<p>题目数据 保证 整个链式结构中不存在环。</p>
<p>注意，函数返回结果后，链表必须 保持其原始结构 。</p>
<p>示例 1：</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png" alt="img"></p>
<p>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3<br>输出：Intersected at ‘8’<br>解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。<br>从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。<br>在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。<br>示例 2：</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_2.png" alt="img"></p>
<p>输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1<br>输出：Intersected at ‘2’<br>解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。<br>从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。<br>在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。<br>示例 3：</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png" alt="img"></p>
<p>输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2<br>输出：null<br>解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。<br>由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。<br>这两个链表不相交，因此返回 null 。</p>
<p>提示：</p>
<p>listA 中节点数目为 m<br>listB 中节点数目为 n<br>$0 &lt;= m, n &lt;= 3 * 10^4$<br>$1 &lt;= Node.val &lt;= 10^5$<br>$0 &lt;= skipA &lt;= m$<br>$0 &lt;= skipB &lt;= n$<br>如果 listA 和 listB 没有交点，$intersectVal$ 为 0<br>如果 listA 和 listB 有交点，$intersectVal == listA[skipA + 1] == listB[skipB + 1]$</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 看到链表先上虚。。。，这个应该是用不到了</span></span><br><span class="line"><span class="comment">// 先判断只要有一个为空，直接返回null</span></span><br><span class="line"><span class="comment">// 暴力解法，双循环，挨个比较就完事了</span></span><br><span class="line"><span class="comment">// 因为是第二次做，所以做过环形链表求入口，这里可以把链表尾与其中一个头相连，</span></span><br><span class="line"><span class="comment">// 然后求入口，这样其实多少算是破坏了结构，需要记录末端尾指针，恢复结构</span></span><br><span class="line"><span class="comment">// 另外fast要在slow前更新，这样能避免只有单个元素时，slow先得到空指针</span></span><br><span class="line"><span class="comment">// 还要注意一点，就是设置的主链headA只有单个元素，且它就是环的入口</span></span><br><span class="line"><span class="comment">// 这样就是整体一个环，第二个循环时，谁也追不上谁</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(headA==<span class="literal">nullptr</span> || headB==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(headA==headB) <span class="keyword">return</span> headA;</span><br><span class="line">        ListNode *slow = headA;</span><br><span class="line">        ListNode *fast = headA;</span><br><span class="line">        <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        ListNode *last; </span><br><span class="line">        <span class="keyword">while</span>(slow!=fast || slow == headA)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast-&gt;next == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(flag==<span class="number">0</span>)fast-&gt;next = headB;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    last-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                last = fast;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(fast-&gt;next-&gt;next == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(flag==<span class="number">0</span>)fast-&gt;next-&gt;next = headB;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    last-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                last = fast-&gt;next;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(slow==headA) &#123;</span><br><span class="line">                last-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="keyword">return</span> headA;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = headA;</span><br><span class="line">        <span class="keyword">while</span>(slow!=fast)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        last-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 这个方法做完，这tm是简单题？没错，环形列表是中等题</span></span><br><span class="line"><span class="comment">// 讲道理，这个题也是第二次做了，但是给我留下的印象没有环形列表深</span></span><br><span class="line"><span class="comment">// 查看题解后发现，还是使用双指针，没错，只是两个指针分别指向两个链表</span></span><br><span class="line"><span class="comment">// 当指针指到头就回来继续，这样当两个指针相等的时候就是交点，都为空就是null</span></span><br><span class="line"><span class="comment">// 很神奇，但是可以简单的数学证明</span></span><br><span class="line"><span class="comment">// m = a+c；n = b+c；</span></span><br><span class="line"><span class="comment">// m+n = a+c+b+c</span></span><br><span class="line"><span class="comment">// n+m = b+c+a+c</span></span><br><span class="line"><span class="comment">// 可以看出即使a不等于b，第二轮也能得到最终结果</span></span><br><span class="line"><span class="comment">// 当没有交点时，都指向null</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (headA == <span class="literal">nullptr</span> || headB == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *pA = headA, *pB = headB;</span><br><span class="line">        <span class="keyword">while</span> (pA != pB) &#123;</span><br><span class="line">            pA = pA == <span class="literal">nullptr</span> ? headB : pA-&gt;next;</span><br><span class="line">            pB = pB == <span class="literal">nullptr</span> ? headA : pB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 有意思的来了,上面的程序用时40ms</span></span><br><span class="line"><span class="comment">// 但时当将循环的时候换为只在自己上面循环，依旧能得到结果，用时320ms</span></span><br><span class="line"><span class="comment">// 另外双循环的版本，用时660ms</span></span><br><span class="line"><span class="comment">// 其实这种情况本质上讲也是一种双循环的优化版本</span></span><br><span class="line"><span class="comment">// 只不过当两数组相等时，只需要循环一次，当不等时，循环一轮能比较两个节点，而双循环每次只能比较一个节点</span></span><br><span class="line"><span class="comment">// 最终的时间用时约为双循环的一半，两数组长度相差越大，用时越短。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (headA == <span class="literal">nullptr</span> || headB == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *pA = headA, *pB = headB;</span><br><span class="line">        <span class="keyword">while</span> (pA != pB) &#123;</span><br><span class="line">            pA = pA == <span class="literal">nullptr</span> ? headA : pA-&gt;next;</span><br><span class="line">            pB = pB == <span class="literal">nullptr</span> ? headB : pB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h2><blockquote>
<p>给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>
<p>不允许修改 链表。</p>
<p>示例 1：</p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p>
<p>输入：head = [3,2,0,-4], pos = 1<br>输出：返回索引为 1 的链表节点<br>解释：链表中有一个环，其尾部连接到第二个节点。<br>示例 2：</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p>
<p>输入：head = [1,2], pos = 0<br>输出：返回索引为 0 的链表节点<br>解释：链表中有一个环，其尾部连接到第一个节点。<br>示例 3：</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p>
<p>输入：head = [1], pos = -1<br>输出：返回 null<br>解释：链表中没有环。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 环形列表，没做过的不太好想到，双指针做，上面一题也试过了</span></span><br><span class="line"><span class="comment">// 考虑好情况，直接写代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span> || head-&gt;next==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* slow=head,*fast = head;</span><br><span class="line">        <span class="keyword">while</span>(slow!=fast || slow==head)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast-&gt;next==<span class="literal">nullptr</span> || fast-&gt;next-&gt;next==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(slow==head) <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = head;</span><br><span class="line">        <span class="keyword">while</span>(slow!=fast)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>链表这一章节中，学会使用虚拟的链表头，能省去很多麻烦，后面的很多题基本都用到了双指针，这里主要是快慢指针，在判断两列表交点和环形链表入口时，需要有一定的思考水平，第一次碰到很有可能没有思路，也是属于是一些很有启发性的方法吧。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++算法</tag>
      </tags>
  </entry>
  <entry>
    <title>代码随想录(day1)</title>
    <url>/link/suixiangluday1.html</url>
    <content><![CDATA[<blockquote>
<p>刷题参考：<a href="https://www.programmercarl.com/">代码随想录 (programmercarl.com)</a></p>
<p>题目来源：<a href="https://leetcode.cn/problems/binary-search">力扣（LeetCode）</a></p>
</blockquote>
<h1 id="Day-1：数组"><a href="#Day-1：数组" class="headerlink" title="Day 1：数组"></a>Day 1：数组</h1><h2 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h2><blockquote>
<p>数组是非常基础的数据结构，在面试中，考察数组的题目一般在思维上都不难，主要是考察对代码的掌控能力。</p>
</blockquote>
<ol>
<li><strong>数组是存放在连续内存空间上的相同类型数据的集合。</strong></li>
</ol>
<ul>
<li><strong>数组下标都是从0开始的。</strong></li>
<li><strong>数组内存空间的地址是连续的</strong></li>
</ul>
<ol>
<li><strong>因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。</strong></li>
</ol>
<p>​        <strong>数组的元素是不能删的，只能覆盖。</strong></p>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/%E7%AE%97%E6%B3%95%E9%80%9A%E5%85%B3%E6%95%B0%E7%BB%841.png" alt="算法通关数组1"></p>
<ol>
<li><strong>数组，vector和array的区别和联系</strong></li>
</ol>
<ul>
<li>共同点<br>（1.）都和数组相似，都可以使用标准数组的表示方法来访问每个元素（<strong>array和vector都对下标运算符[ ]进行了重载</strong>）<br>（2.）<strong>三者的存储都是连续的，可以进行随机访问</strong></li>
<li>不同点<br>（0.）数组是不安全的，array和vector是比较安全的（有效的避免越界等问题）<br>（1.）<strong>array对象和数组存储在相同的内存区域（栈）</strong>中，<strong>vector对象存储在自由存储区（堆）</strong><br>（2.）array可以将一个对象赋值给另一个array对象，但是数组不行<br>（3.）<strong>vector属于变长的容器</strong>，即可以根据数据的插入和删除重新构造容器容量；但是<strong>array和数组属于定长容器</strong><br>（4.）<strong>vector和array提供了更好的数据访问机制</strong>，即可以使用front()和back()以及at()（at()可以避免a[-1]访问越界的问题）访问方式，使得访问更加安全。而数组只能通过下标访问，在写程序中很容易出现越界的错误<br>（5.）<strong>vector和array提供了更好的遍历机制</strong>，即有正向迭代器和反向迭代器<br>（6.）<strong>vector和array提供了size()和Empty()</strong>，而<strong>数组只能通过sizeof()/strlen()以及遍历计数</strong>来获取大小和是否为空<br>（7.）<strong>vector和array提供了两个容器对象的内容交换</strong>，<strong>swap()的机制</strong>，而数组对于交换只能通过遍历的方式逐个交换元素<br>（8.）<strong>array提供了初始化所有成员的方法fill（）</strong><br>（9.）由于vector的动态内存变化的机制，在插入和删除时，需要考虑迭代的是否有效问题<br>（10.）<strong>vector和array在声明变量后</strong>，在声明周期完成后，<strong>会自动地释放其所占用的内存</strong>。对于<strong>数组如果用new[ ]/malloc申请的空间</strong>，<strong>必须用对应的delete[ ]和free来释放内存</strong>。</li>
</ul>
<p><strong>那么二维数组在内存的空间地址是连续的么？</strong></p>
<p>不同编程语言的内存管理是不一样的，以C++为例，在C++中二维数组是连续分布的。</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210310150641186.png" alt="数组内存"></p>
<p>Java的二维数组可能是如下排列的方式：</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201214111631844.png" alt="算法通关数组3"></p>
<h2 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a><a href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a></h2><blockquote>
<p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p>
<p>示例 1:</p>
<p>输入: nums = [-1,0,3,5,9,12], target = 9<br>输出: 4<br>解释: 9 出现在 nums 中并且下标为 4<br>示例 2:</p>
<p>输入: nums = [-1,0,3,5,9,12], target = 2<br>输出: -1<br>解释: 2 不存在 nums 中因此返回 -1</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp = (right+left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[temp]&gt;target) right=temp<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[temp]==target) <span class="keyword">return</span> temp;</span><br><span class="line">            <span class="keyword">else</span> left = temp+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 现在考虑nums=[0,1]，target=1的情况，这时候left=0，right=1</span></span><br><span class="line"><span class="comment">// temp=0，这样导致一直在循环，</span></span><br><span class="line"><span class="comment">// 开始想只需要在左右相加时使(right+left+1)/2即可解决</span></span><br><span class="line"><span class="comment">// 但如果target=0呢，这样又不行了</span></span><br><span class="line"><span class="comment">// 人傻了，只需要将边界条件调整，当中间值不符合条件</span></span><br><span class="line"><span class="comment">// 更新左右指针时右边界-1，左边界+1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数组在python中对应的是列表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right):</span><br><span class="line">            temp = (left+right)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span>(nums[temp] &gt; target):</span><br><span class="line">                right = temp-<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> (nums[temp] == target):</span><br><span class="line">                <span class="keyword">return</span> temp</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = temp+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 突然好不习惯，python中数据类型是非指定的，除法得到的为小数</span></span><br><span class="line"><span class="comment"># 需要//整除代替除法</span></span><br></pre></td></tr></table></figure>
<h2 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a><a href="https://leetcode.cn/problems/search-insert-position/">35. 搜索插入位置</a></h2><blockquote>
<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>请必须使用时间复杂度为 O(log n) 的算法。</p>
<p>示例 1:</p>
<p>输入: nums = [1,3,5,6], target = 5<br>输出: 2<br>示例 2:</p>
<p>输入: nums = [1,3,5,6], target = 2<br>输出: 1<br>示例 3:</p>
<p>输入: nums = [1,3,5,6], target = 7<br>输出: 4</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 题目给定一个排序完成的数组，如果目标值存在，返回目标值索引，如果目标值不存在，返回其插入位置</span></span><br><span class="line"><span class="comment">// 首先要求long n的复杂度的算法，应该使用二分查找来查找</span></span><br><span class="line"><span class="comment">// 题目需要插入操作在c++中必然使用vector</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target&lt;nums[<span class="number">0</span>]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (target&gt;nums[nums.<span class="built_in">size</span>()<span class="number">-1</span>]) <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp = (left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[temp]&gt;target) right = temp<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[temp]==target) <span class="keyword">return</span> temp;</span><br><span class="line">            <span class="keyword">else</span> left = temp+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[left]&gt;target) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> left+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 该题只需要得到插入位置，正常来讲，目标存在即直接使用二分查找</span></span><br><span class="line"><span class="comment">// 不存在则需要考虑不存在的情况</span></span><br><span class="line"><span class="comment">// 情况1：在两个值中间插入，这时候跳出，left=right，</span></span><br><span class="line"><span class="comment">// 如果该值比目标值大，即应该在该值前插入，left刚好为插入位置</span></span><br><span class="line"><span class="comment">// 如果该值比目标值小，即应该在该值后插入，插入位置的坐标应为left+1</span></span><br><span class="line"><span class="comment">// 情况2：在开头插入，此时目标值小于初始值，返回0</span></span><br><span class="line"><span class="comment">// 情况3：在结尾插入，此时目标值大于最大值，返回nums.size()</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchInsert</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span>(target&lt;nums[<span class="number">0</span>]): </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (target&gt;nums[<span class="built_in">len</span>(nums)-<span class="number">1</span>]):</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right):</span><br><span class="line">            temp = (left+right)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span>(nums[temp]&gt;target):</span><br><span class="line">                right = temp - <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> (nums[temp]==target):</span><br><span class="line">         	   <span class="keyword">return</span> temp</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = temp+<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums[left]&gt;target):</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> left+<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="循环不变量"><a href="#循环不变量" class="headerlink" title="循环不变量"></a>循环不变量</h2><blockquote>
<p>以上两道题虽然解出来，但是似乎并没有总结出什么通用的，或者有能学到的二分法的经验，在前面两个题目中遇到的问题，<strong>1. 边界条件难确定，导致死循环；2. 查看题解，其实代码量不需要这么多。</strong></p>
</blockquote>
<p>针对以上问题，最最重要的应该是<strong>明确边界条件，并使得该边界条件在循环中不发生变化</strong>，即循环不变量。</p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202306102207384.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当边界条件为[]闭区间时，35.搜索插入位置 即查找大于等于target的值 有以下代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=nums.<span class="built_in">size</span>()<span class="number">-1</span>;  <span class="comment">// 闭区间所以初始条件为[0,len(nums)-1]</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)  <span class="comment">// 闭区间最后两个值可以相等</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//int mid = (left + right)/2;  // 这里取中值，但不应使用该写法</span></span><br><span class="line">            <span class="type">int</span> mid = left + (right - left)/<span class="number">2</span>; <span class="comment">// 防止right=2e31-1时的越位</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;target) left = mid+<span class="number">1</span>;  </span><br><span class="line">            <span class="keyword">else</span> right = mid<span class="number">-1</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;  <span class="comment">// 通过最后情况的思考，选择左</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 当边界条件为[)闭区间时，有以下代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=nums.<span class="built_in">size</span>(); </span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left)/<span class="number">2</span>; </span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;target) left = mid+<span class="number">1</span>; </span><br><span class="line">            <span class="keyword">else</span> right = mid; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 当边界条件为()闭区间时，有以下代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">-1</span>,right=nums.<span class="built_in">size</span>(); </span><br><span class="line">        <span class="keyword">while</span>(left &lt; right<span class="number">-1</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left)/<span class="number">2</span>; </span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;target) left = mid; </span><br><span class="line">            <span class="keyword">else</span> right = mid; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 当边界条件为(]闭区间时，有以下代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">-1</span>,right=nums.<span class="built_in">size</span>()<span class="number">-1</span>;  </span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = right - (right - left)/<span class="number">2</span>; <span class="comment">// 因为判断时右边为闭区间</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;target) left = mid;  </span><br><span class="line">            <span class="keyword">else</span> right = mid<span class="number">-1</span>;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right+<span class="number">1</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 总结：二分查找不管是哪种区间，都是先判断左边界，返回值根据最终的情况进行输出</span></span><br><span class="line"><span class="comment">// 很多语言都是采用左闭右开区间来进行设计，可确定使用这一种形式</span></span><br></pre></td></tr></table></figure>
<h2 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h2><blockquote>
<p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。</p>
<p>如果数组中不存在目标值 target，返回 [-1, -1]。</p>
<p>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</p>
<p>示例 1：</p>
<p>输入：nums = [5,7,7,8,8,10], target = 8<br>输出：[3,4]<br>示例 2：</p>
<p>输入：nums = [5,7,7,8,8,10], target = 6<br>输出：[-1,-1]<br>示例 3：</p>
<p>输入：nums = [], target = 0<br>输出：[-1,-1]</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二分查找的题无非就是判断四种关系，&lt;,&lt;=,&gt;,&gt;=</span></span><br><span class="line"><span class="comment">// 该题目首先找 &gt;= target的位置，再找 &lt; target+1 的位置，可转换为 &gt;=target+1的位置-1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 搬过上次写的代码</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=nums.<span class="built_in">size</span>()<span class="number">-1</span>;  <span class="comment">// 闭区间所以初始条件为[0,len(nums)-1]</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)  <span class="comment">// 闭区间最后两个值可以相等</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left)/<span class="number">2</span>; <span class="comment">// 防止right=2e31-1时的越位</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;target) left = mid+<span class="number">1</span>; </span><br><span class="line">            <span class="keyword">else</span> right = mid<span class="number">-1</span>;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left; <span class="comment">// 通过最后情况的思考，选择左</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;; <span class="comment">// 单独判断数组为空的情况</span></span><br><span class="line">		<span class="type">int</span> left,right;</span><br><span class="line">         left = <span class="built_in">searchInsert</span>(nums,target);</span><br><span class="line">         <span class="comment">// 这里判断条件时应先判断是否等于数组长度，防止后续判断越界</span></span><br><span class="line">         <span class="keyword">if</span>(left == nums.<span class="built_in">size</span>() || nums[left]!=target) <span class="keyword">return</span> &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;; </span><br><span class="line">         right = <span class="built_in">searchInsert</span>(nums,target+<span class="number">1</span>);</span><br><span class="line">         <span class="keyword">return</span> &#123;left,right<span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchInsert</span>(<span class="params">self,nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left,right = <span class="number">0</span>,<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">while</span> left&lt;right:</span><br><span class="line">            mid = left + (right-left)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid]&lt;target: left = mid+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span> : right = mid</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchRange</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums)==<span class="number">0</span> : <span class="keyword">return</span> [-<span class="number">1</span>,-<span class="number">1</span>]</span><br><span class="line">        left = self.searchInsert(nums, target)</span><br><span class="line">        <span class="keyword">if</span> left==<span class="built_in">len</span>(nums) <span class="keyword">or</span> nums[left] != target: <span class="keyword">return</span> [-<span class="number">1</span>,-<span class="number">1</span>]</span><br><span class="line">        right = self.searchInsert(nums, target+<span class="number">1</span>)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> [left,right]</span><br></pre></td></tr></table></figure>
<h2 id="69-x-的平方根"><a href="#69-x-的平方根" class="headerlink" title="69. x 的平方根 "></a><a href="https://leetcode.cn/problems/sqrtx/">69. x 的平方根 </a></h2><blockquote>
<p>给你一个非负整数 x ，计算并返回 x 的 算术平方根 。</p>
<p>由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。</p>
<p>注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。</p>
<p> 示例 1：</p>
<p>输入：x = 4<br>输出：2<br>示例 2：</p>
<p>输入：x = 8<br>输出：2<br>解释：8 的算术平方根是 2.82842…, 由于返回类型是整数，小数部分将被舍去。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 因为所求为整数，即在所给x之前的所有整数中找到a，使得a*a&lt;=x,(a+1)*(a+1)&gt;x</span></span><br><span class="line"><span class="comment">// a*a可能会出现越界，改为a&lt;x/a</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	    <span class="type">int</span> left=<span class="number">0</span>,right=x;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="type">int</span> mid = right-(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (mid==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(mid&lt;x/mid) left = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(mid==x/mid) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> right = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left&lt;= x/left?left:left<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="367-有效的完全平方数"><a href="#367-有效的完全平方数" class="headerlink" title="367. 有效的完全平方数"></a><a href="https://leetcode.cn/problems/valid-perfect-square/">367. 有效的完全平方数</a></h2><blockquote>
<p>给你一个正整数 num 。如果 num 是一个完全平方数，则返回 true ，否则返回 false 。</p>
<p>完全平方数 是一个可以写成某个整数的平方的整数。换句话说，它可以写成某个整数和自身的乘积。</p>
<p>不能使用任何内置的库函数，如  sqrt 。</p>
<p>示例 1：</p>
<p>输入：num = 16<br>输出：true<br>解释：返回 true ，因为 4 * 4 = 16 且 4 是一个整数。<br>示例 2：</p>
<p>输入：num = 14<br>输出：false<br>解释：返回 false ，因为 3.742 * 3.742 = 14 但 3.742 不是一个整数。</p>
<p><strong>提示：</strong></p>
<ul>
<li>$1 &lt;= num &lt;= 2^{31} - 1$</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 与上道题类似，直接搬过来</span></span><br><span class="line"><span class="comment">// 需要注意的是该题的范围取值从1开始，所以修改区间范围</span></span><br><span class="line"><span class="comment">// 当整除时自动向下取整需要再判断余数为0</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">1</span>,right=num;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="type">int</span> mid = right-(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(mid&lt;num/mid) left = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(mid==num/mid &amp;&amp; num%mid==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><blockquote>
<p>双指针是一个很常用的方法，根据两个指针的运动顺序不同，可以分为同向双指针和相向双指针</p>
<p>二分查找用到的就是相向指针也叫碰撞指针</p>
<p>同向指针有快慢指针和滑动窗口</p>
</blockquote>
<h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><p>类似于龟兔赛跑，两个链表上的指针从同一节点出发，其中一个指针前进速度是另一个指针的两倍。利用快慢指针可以用来解决某些算法问题，比如</p>
<ol>
<li>计算链表的中点：快慢指针从头节点出发，每轮迭代中，快指针向前移动两个节点，慢指针向前移动一个节点，最终当快指针到达终点的时候，慢指针刚好在中间的节点。</li>
<li>判断链表是否有环：如果链表中存在环，则在链表上不断前进的指针会一直在环里绕圈子，且不能知道链表是否有环。使用快慢指针，当链表中存在环时，两个指针最终会在环中相遇。</li>
<li>判断链表中环的起点：当我们判断出链表中存在环，并且知道了两个指针相遇的节点，我们可以让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。</li>
<li>求链表中环的长度：只要相遇后一个不动，另一个前进直到相遇算一下走了多少步就好了</li>
<li>求链表倒数第k个元素：先让其中一个指针向前走k步，接着两个指针以同样的速度一起向前进，直到前面的指针走到尽头了，则后面的指针即为倒数第k个元素。（严格来说应该叫先后指针而非快慢指针）</li>
</ol>
<h3 id="碰撞指针"><a href="#碰撞指针" class="headerlink" title="碰撞指针"></a>碰撞指针</h3><p>一般都是<strong>排好序的数组或链表</strong>，否则无序的话这两个指针的位置也没有什么意义。特别注意两个指针的循环条件在循环体中的变化，小心右指针跑到左指针左边去了。常用来解决的问题有</p>
<ol>
<li><p>二分查找问题</p>
</li>
<li><p>n数之和问题：比如两数之和问题，先对数组排序然后左右指针找到满足条件的两个数。如果是三数问题就转化为一个数和另外两个数的两数问题。以此类推。</p>
</li>
</ol>
<h3 id="滑动窗口法"><a href="#滑动窗口法" class="headerlink" title="滑动窗口法"></a>滑动窗口法</h3><p>两个指针，一前一后组成滑动窗口，并计算滑动窗口中的元素的问题。</p>
<p>这类问题一般包括</p>
<ol>
<li><p>字符串匹配问题</p>
</li>
<li><p>子数组问题</p>
</li>
<li>连续子数组求和问题</li>
</ol>
<h2 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a><a href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a></h2><blockquote>
<p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p>说明:</p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<p>// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝<br>int len = removeElement(nums, val);</p>
<p>// 在函数里修改输入数组对于调用者是可见的。<br>// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。<br>for (int i = 0; i &lt; len; i++) {<br>   print(nums[i]);<br>}</p>
<p>示例 1：</p>
<p>输入：nums = [3,2,2,3], val = 3<br>输出：2, nums = [2,2]<br>解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。<br>示例 2：</p>
<p>输入：nums = [0,1,2,2,3,0,4,2], val = 2<br>输出：5, nums = [0,1,4,0,3]<br>解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</p>
<p>提示：</p>
<p>0 &lt;= nums.length &lt;= 100<br>0 &lt;= nums[i] &lt;= 50<br>0 &lt;= val &lt;= 100</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 因为数组只能进行覆盖操作，所以需要使用双指针</span></span><br><span class="line"><span class="comment">// 左指针去更新数组，右指针指向原始数组的位置</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == val) <span class="keyword">continue</span>;  <span class="comment">// 当数组等于约定值慢指针不进行更新</span></span><br><span class="line">            nums[slow] = nums[i];</span><br><span class="line">            slow++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;  <span class="comment">// 最后slow为新数组的长度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26. 删除有序数组中的重复项"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">26. 删除有序数组中的重复项</a></h2><blockquote>
<p>给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。</p>
<p>考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过：</p>
<p>更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。<br>返回 k 。<br>判题标准:</p>
<p>系统会用下面的代码来测试你的题解:</p>
<p>int[] nums = […]; // 输入数组<br>int[] expectedNums = […]; // 长度正确的期望答案</p>
<p>int k = removeDuplicates(nums); // 调用</p>
<p>assert k == expectedNums.length;<br>for (int i = 0; i &lt; k; i++) {<br>    assert nums[i] == expectedNums[i];<br>}<br>如果所有断言都通过，那么您的题解将被 通过。</p>
<p>示例 1：</p>
<p>输入：nums = [1,1,2]<br>输出：2, nums = [1,2,_]<br>解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。<br>示例 2：</p>
<p>输入：nums = [0,0,1,1,1,2,2,3,3,4]<br>输出：5, nums = [0,1,2,3,4]<br>解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先，给定的数组为单调数组，即重复元素挨在一起</span></span><br><span class="line"><span class="comment">// 使用两个指针判断后面指针是否等于前面指针</span></span><br><span class="line"><span class="comment">// 相等后面指针继续，不等更新前指针，后指针继续</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> fast=<span class="number">0</span>;fast&lt;nums.<span class="built_in">size</span>();fast++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast]==nums[slow]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                slow++;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 最后返回值为元素个数，故return为slow+1</span></span><br></pre></td></tr></table></figure>
<h2 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a><a href="https://leetcode.cn/problems/move-zeroes/">283. 移动零</a></h2><blockquote>
<p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p>请注意 ，必须在不复制数组的情况下原地对数组进行操作。</p>
<p>示例 1:</p>
<p>输入: nums = [0,1,0,3,12]<br>输出: [1,3,12,0,0]<br>示例 2:</p>
<p>输入: nums = [0]<br>输出: [0]</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将0移动到数组末尾，其余元素不动，而且不能复制数组</span></span><br><span class="line"><span class="comment">// 采用双指针移除0元素，当快指针到头，慢指针后的所有元素赋值为0</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> fast=<span class="number">0</span>;fast&lt;nums.<span class="built_in">size</span>();fast++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast]==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(;slow&lt;nums.<span class="built_in">size</span>();slow++)&#123;</span><br><span class="line">            nums[slow]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="844-比较含退格的字符串"><a href="#844-比较含退格的字符串" class="headerlink" title="844. 比较含退格的字符串"></a><a href="https://leetcode.cn/problems/backspace-string-compare/">844. 比较含退格的字符串</a></h2><blockquote>
<p>给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true 。# 代表退格字符。</p>
<p>注意：如果对空文本输入退格字符，文本继续为空。</p>
<p>示例 1：</p>
<p>输入：s = “ab#c”, t = “ad#c”<br>输出：true<br>解释：s 和 t 都会变成 “ac”。<br>示例 2：</p>
<p>输入：s = “ab##”, t = “c#d#”<br>输出：true<br>解释：s 和 t 都会变成 “”。<br>示例 3：</p>
<p>输入：s = “a#c”, t = “b”<br>输出：false<br>解释：s 会变成 “c”，但 t 仍然是 “b”。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先了解题意，有退格符，可先分别对两个字符串进行更新后判断</span></span><br><span class="line"><span class="comment">// 单个字符串更新时，使用双指针，如果快指针指向#，那么慢指针就回退一位</span></span><br><span class="line"><span class="comment">// 考虑可能出现越位，应限制slow最小为0</span></span><br><span class="line"><span class="comment">// 如果快指针指向字符，慢指针等于快指针，并加一</span></span><br><span class="line"><span class="comment">// 判断两个字符串处理后长度是否相等，相等再进行字符比对</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strprocess</span><span class="params">(string &amp; s)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> slow=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> fast=<span class="number">0</span>;fast&lt;s.<span class="built_in">size</span>();fast++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[fast]==<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(slow) sslow--;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                s[slow] = s[fast];</span><br><span class="line">                slow ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">backspaceCompare</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sslow=<span class="built_in">strprocess</span>(s);</span><br><span class="line">        <span class="type">int</span> tslow=<span class="built_in">strprocess</span>(t);</span><br><span class="line">        <span class="keyword">if</span>(sslow != tslow) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;sslow;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] != t[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977. 有序数组的平方"></a><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a></h2><blockquote>
<p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p>
<p>示例 1：</p>
<p>输入：nums = [-4,-1,0,3,10]<br>输出：[0,1,9,16,100]<br>解释：平方后，数组变为 [16,1,0,9,100]<br>排序后，数组变为 [0,1,9,16,100]</p>
<p>示例 2：</p>
<p>输入：nums = [-7,-3,2,3,11]<br>输出：[4,9,9,49,121]</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先看到题目的想法，数组求平方后排序</span></span><br><span class="line"><span class="comment">// 但是题目给了是非递减序列，只是应为有负数，导致平方后不是正确顺序</span></span><br><span class="line"><span class="comment">// 两边的平方必然有一个为最大值</span></span><br><span class="line"><span class="comment">// 这样的话，可以建一个等长数组，保存值，从两边开始，使用双指针遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">1</span>) <span class="keyword">return</span> &#123;nums[<span class="number">0</span>]*nums[<span class="number">0</span>]&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res=nums;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> dleft = nums[left]* nums[left];</span><br><span class="line">        <span class="type">int</span> dright =  nums[right]* nums[right];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=nums.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dleft&gt;=dright)&#123;</span><br><span class="line">                res[i] = dleft;</span><br><span class="line">                left ++; </span><br><span class="line">                <span class="keyword">if</span> (left&gt;right) <span class="keyword">break</span>;</span><br><span class="line">                dleft = nums[left]* nums[left];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                res[i] = dright;</span><br><span class="line">                right --; </span><br><span class="line">                <span class="keyword">if</span> (left&gt;right) <span class="keyword">break</span>;</span><br><span class="line">                dright = nums[right]* nums[right];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 当给的数组中只有一个元素时，直接返回该值的平方</span></span><br><span class="line"><span class="comment">// 要考虑数组的越位情况</span></span><br></pre></td></tr></table></figure>
<h2 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a></h2><blockquote>
<p>给定一个含有 n 个正整数的数组和一个正整数 target 。</p>
<p>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。 </p>
<p>示例 1：</p>
<p>输入：target = 7, nums = [2,3,1,2,4,3]<br>输出：2<br>解释：子数组 [4,3] 是该条件下的长度最小的子数组。<br>示例 2：</p>
<p>输入：target = 4, nums = [1,4,4]<br>输出：1<br>示例 3：</p>
<p>输入：target = 11, nums = [1,1,1,1,1,1,1,1]<br>输出：0</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 连续数组求和问题，应该使用滑动窗口解决</span></span><br><span class="line"><span class="comment">// 题目要求最小连续长度，应将满足条件的连续数组长度设置为变量，</span></span><br><span class="line"><span class="comment">// 当符合条件的新的连续数组小于变量时更新</span></span><br><span class="line"><span class="comment">// 终止条件应该为右指针越界，或者左指针等于右指针</span></span><br><span class="line"><span class="comment">// 当数组中只有单个值时，单独判断</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[<span class="number">0</span>]&gt;=target) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=<span class="number">1</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> sum = nums[left];  <span class="comment">// 考虑到存在单个数大于给定值的问题，采用左闭右开区间</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;right &amp;&amp; right&lt;=nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum&gt;=target)&#123;</span><br><span class="line">                <span class="keyword">if</span>(res.<span class="built_in">empty</span>() || res.<span class="built_in">back</span>()&gt;(right-left)) res.<span class="built_in">emplace_back</span>(right-left);</span><br><span class="line">                sum -= nums[left];</span><br><span class="line">                left ++;</span><br><span class="line">                <span class="keyword">if</span>(left==right) <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// 考虑只有单个数组时，出现左指针与右指针相等，直接return 1;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (right &gt;= nums.<span class="built_in">size</span>()) <span class="keyword">break</span>;</span><br><span class="line">                sum += nums[right];</span><br><span class="line">                right++; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> res.<span class="built_in">back</span>();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 上述代码中由于采用了左闭右开区间，数组为1的情况下不需要额外判断，可减少代码行数</span></span><br><span class="line"><span class="comment">// 但是在测试中，由于测试时的代码运行更多了，代码精简后，整体速度和整体的占用空间均有上升</span></span><br></pre></td></tr></table></figure>
<h2 id="904-水果成篮"><a href="#904-水果成篮" class="headerlink" title="904. 水果成篮"></a><a href="https://leetcode.cn/problems/fruit-into-baskets/">904. 水果成篮</a></h2><blockquote>
<p>你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。</p>
<p>你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：</p>
<p>你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。<br>你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。<br>一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。<br>给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。</p>
<p>示例 1：</p>
<p>输入：fruits = [1,2,1]<br>输出：3<br>解释：可以采摘全部 3 棵树。</p>
<p>示例 2：</p>
<p>输入：fruits = [0,1,2,2]<br>输出：3<br>解释：可以采摘 [1,2,2] 这三棵树。<br>如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。</p>
<p>示例 3：</p>
<p>输入：fruits = [1,2,3,2,2]<br>输出：4<br>解释：可以采摘 [2,3,2,2] 这四棵树。<br>如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。</p>
<p>示例 4：</p>
<p>输入：fruits = [3,3,3,1,2,1,1,2,3,3,4]<br>输出：5<br>解释：可以采摘 [1,2,1,1,2] 这五棵树。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 本质上看是判断数组中连续值的个数，因此应采用滑动窗口解决</span></span><br><span class="line"><span class="comment">// 判断只有两个篮子，当果树数量为2以下直接返回果树数量</span></span><br><span class="line"><span class="comment">// 滑动窗口采用两个指针，无论哪一个指针进行滑动另外一个指针应暂时不动</span></span><br><span class="line"><span class="comment">// 不动的指针占了一个篮子，需要一个变量保存另一个指针的当前值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalFruit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; fruits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(fruits.<span class="built_in">size</span>()&lt;=<span class="number">2</span>) <span class="keyword">return</span> fruits.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>,right=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> temp=fruits[right];</span><br><span class="line">        <span class="type">int</span> start = right;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &lt;fruits.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span> (temp == fruits[left])&#123;  <span class="comment">// 如果开始只有一个种类</span></span><br><span class="line">                <span class="keyword">if</span>(fruits[right]!=temp)&#123; <span class="comment">// 当出现第二个种类时</span></span><br><span class="line">                    start = right;  <span class="comment">// 将第二个值的的初始位置记录到start</span></span><br><span class="line">                    temp = fruits[right];  <span class="comment">// temp更新新的数值</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;  <span class="comment">// 当有两个种类之后</span></span><br><span class="line">                <span class="keyword">if</span>(fruits[right]==fruits[left] || fruits[right]==temp)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(fruits[right]!=fruits[right<span class="number">-1</span>]) start = right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    left = start;</span><br><span class="line">                    start = right;</span><br><span class="line">                    temp = fruits[right];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">            <span class="keyword">if</span>(right-left&gt;res) res=right-left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* 变量变化表格</span></span><br><span class="line"><span class="comment">step：      0  1  2  3  4  5  6  7   步骤</span></span><br><span class="line"><span class="comment">left：   /  0  0  2  2  2  2  6  6   左指针</span></span><br><span class="line"><span class="comment">right：  /  1  2  3  4  5  6  7  8   右指针</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">fruits： 1  1  6  5  6  6  5  1  1   原数组</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">temp：      1  6  5  5  5  5  1  1   除左指针外的篮子之中的种类</span></span><br><span class="line"><span class="comment">start：     1  2  3  4  4  6  7  7   每个连续值的第一个值的索引</span></span><br><span class="line"><span class="comment">res：       2  3  2  3  4  5  2  3   最终结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 有点懵，应该还是提前画好表更好一点</span></span><br><span class="line"><span class="comment">// 上面的代码可以说很乱，下面代码更好理解</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalFruit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; fruits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(fruits.<span class="built_in">size</span>()&lt;=<span class="number">2</span>) <span class="keyword">return</span> fruits.<span class="built_in">size</span>();  <span class="comment">// 如果整体小于2，返回数组长度</span></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>,right=<span class="number">1</span>;  <span class="comment">// 定义两个变量作为滑动窗口的两边</span></span><br><span class="line">        <span class="keyword">for</span>(;right&lt;fruits.<span class="built_in">size</span>();right++)&#123;  <span class="comment">// 确定右边初始位置</span></span><br><span class="line">            <span class="keyword">if</span>(fruits[right] != fruits[left]) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right == fruits.<span class="built_in">size</span>()) <span class="keyword">return</span> right; <span class="comment">//如果右边初始位置等于最长长度，说明数组中只有一种</span></span><br><span class="line">        <span class="type">int</span> cnt= fruits[right];  <span class="comment">// 初始化第二种果树，第一种果树为左指针指的位置</span></span><br><span class="line">        <span class="type">int</span> res=right+<span class="number">1</span>; <span class="comment">// 初始化最长序列长度</span></span><br><span class="line">        <span class="keyword">for</span>(;right&lt;fruits.<span class="built_in">size</span>();right ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fruits[right] != fruits[left] &amp;&amp; fruits[right] != cnt)&#123; <span class="comment">//如果不在两种之中</span></span><br><span class="line">                <span class="keyword">if</span>(right-left&gt;res) res = right-left;  <span class="comment">// 当前长度已经是两种最长，更新最长序列长度</span></span><br><span class="line">                left = right<span class="number">-1</span>;  <span class="comment">// 更换左边界</span></span><br><span class="line">                <span class="keyword">while</span>(fruits[left]==fruits[left<span class="number">-1</span>]) left--;</span><br><span class="line">                cnt= fruits[right];  <span class="comment">// 更换水果种类</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right-left&gt;res) res=right-left;  <span class="comment">// 最后因为到达边界，没有更新最大长度，需要额外更新一次</span></span><br><span class="line">        <span class="keyword">return</span> res; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a><a href="https://leetcode.cn/problems/minimum-window-substring/">76. 最小覆盖子串</a></h2><blockquote>
<p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。</p>
<p>注意：</p>
<p>对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。<br>如果 s 中存在这样的子串，我们保证它是唯一的答案。</p>
<p>示例 1：</p>
<p>输入：s = “ADOBECODEBANC”, t = “ABC”<br>输出：”BANC”<br>解释：最小覆盖子串 “BANC” 包含来自字符串 t 的 ‘A’、’B’ 和 ‘C’。<br>示例 2：</p>
<p>输入：s = “a”, t = “a”<br>输出：”a”<br>解释：整个字符串 s 是最小覆盖子串。<br>示例 3:</p>
<p>输入: s = “a”, t = “aa”<br>输出: “”<br>解释: t 中两个字符 ‘a’ 均应包含在 s 的子串中，<br>因此没有符合条件的子字符串，返回空字符串。</p>
</blockquote>
<p>解题思路：<a href="https://leetcode.cn/problems/minimum-window-substring/solution/by-flix-1kac/">『 一招吃遍七道 』滑动窗口的应用 - 最小覆盖子串 - 力扣（LeetCode）</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是一道困难题，使用的是哈希表联合滑动窗口使用</span></span><br><span class="line"><span class="comment">// 首先将t内的字符写入字典mp中</span></span><br><span class="line"><span class="comment">// 将所需的总字符数记为need</span></span><br><span class="line"><span class="comment">// 开始用滑动窗口遍历s，先移动right，判断字符是否在mp中，是则--，如果字符对应的值为正，则need--</span></span><br><span class="line"><span class="comment">// 当need=0，记录长度，移动left，判断字符是否在mp中，是则++，如果字符对应的值为正，则need++</span></span><br><span class="line"><span class="comment">// 也就是need&gt;0时移动right，need=0，移动left</span></span><br><span class="line"><span class="comment">// 边界条件应该为need&gt;0 &amp;&amp; right&gt;s.size()</span></span><br><span class="line"><span class="comment">// 使用数组记录满足条件的左右指针，最后取出相应的字符串</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">const</span> <span class="type">char</span> &amp;i:t)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mp.<span class="built_in">find</span>(i) == mp.<span class="built_in">end</span>()) mp[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> mp[i] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> need = t.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(need==<span class="number">0</span>||right&lt;s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(need&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mp.<span class="built_in">find</span>(s[right]) != mp.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    mp[s[right]]--;</span><br><span class="line">                    <span class="keyword">if</span>(mp[s[right]]&gt;=<span class="number">0</span>) need--;</span><br><span class="line">                &#125;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (res.<span class="built_in">empty</span>()) res=&#123;left,right&#125;;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(res[<span class="number">1</span>]-res[<span class="number">0</span>]&gt;right-left) res=&#123;left,right&#125;;</span><br><span class="line">                <span class="keyword">if</span>(mp.<span class="built_in">find</span>(s[left]) != mp.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    mp[s[left]]++;</span><br><span class="line">                    <span class="keyword">if</span>(mp[s[left]]&gt;<span class="number">0</span>) need++;</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        string strres;</span><br><span class="line">        <span class="keyword">if</span>(res.<span class="built_in">empty</span>()) <span class="keyword">return</span> strres;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=res[<span class="number">0</span>];i&lt;res[<span class="number">1</span>];i++)&#123;</span><br><span class="line">            strres.<span class="built_in">append</span>(<span class="number">1</span>,s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strres;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="面试题-17-18-最短超串"><a href="#面试题-17-18-最短超串" class="headerlink" title="面试题 17.18. 最短超串"></a><a href="https://leetcode.cn/problems/shortest-supersequence-lcci/">面试题 17.18. 最短超串</a></h2><blockquote>
<p>假设你有两个数组，一个长一个短，短的元素均不相同。找到长数组中包含短数组所有的元素的最短子数组，其出现顺序无关紧要。</p>
<p>返回最短子数组的左端点和右端点，如有多个满足条件的子数组，返回左端点最小的一个。若不存在，返回空数组。</p>
<p>示例 1:</p>
<p>输入:<br>big = [7,5,9,0,2,1,3,5,7,9,1,1,5,8,8,9,7]<br>small = [1,5,9]<br>输出: [7,10]<br>示例 2:</p>
<p>输入:<br>big = [1,2,3]<br>small = [4]<br>输出: []</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该题为中等题，思路与上题一致</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">shortestSeq</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; big, vector&lt;<span class="type">int</span>&gt;&amp; small)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">const</span> <span class="type">int</span> &amp;i:small)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mp.<span class="built_in">find</span>(i) == mp.<span class="built_in">end</span>()) mp[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> mp[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> need = small.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(need==<span class="number">0</span> || right&lt;big.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(need&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mp.<span class="built_in">find</span>(big[right]) != mp.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    mp[big[right]]--;</span><br><span class="line">                    <span class="keyword">if</span>(mp[big[right]]&gt;=<span class="number">0</span>) need--;</span><br><span class="line">                &#125;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(res.<span class="built_in">empty</span>()||res[<span class="number">1</span>]-res[<span class="number">0</span>]&gt;right-left<span class="number">-1</span>) res=&#123;left,right<span class="number">-1</span>&#125;;</span><br><span class="line">                <span class="keyword">if</span>(mp.<span class="built_in">find</span>(big[left]) != mp.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    mp[big[left]]++;</span><br><span class="line">                    <span class="keyword">if</span>(mp[big[left]]&gt;<span class="number">0</span>) need++;</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="59-螺旋矩阵-II"><a href="#59-螺旋矩阵-II" class="headerlink" title="59. 螺旋矩阵 II"></a><a href="https://leetcode.cn/problems/spiral-matrix-ii/">59. 螺旋矩阵 II</a></h2><blockquote>
<p>给你一个正整数 n ，生成一个包含 1 到 $n^2$ 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。</p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg" alt="img"></p>
<p>示例 1：</p>
<p>输入：n = 3<br>输出：[[1,2,3],[8,9,4],[7,6,5]]<br>示例 2：</p>
<p>输入：n = 1<br>输出：[[1]]</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是一道模拟相关的题，不涉及算法，但要注意循环中的不变量</span></span><br><span class="line"><span class="comment">// 明显可以看出当n为奇数时，有中心块，偶数时没有</span></span><br><span class="line"><span class="comment">// 当n=2时，可分解为1-&gt;2-&gt;3-&gt;4</span></span><br><span class="line"><span class="comment">// 当n=3时，可分解为1,2-&gt;3,4-&gt;5,6-&gt;7,8-&gt;9</span></span><br><span class="line"><span class="comment">// 首先可以写n=1的特殊情况，然后在考虑规律</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> &#123;&#123;<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">        <span class="type">int</span> x=<span class="number">0</span>,y=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> legth=n<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> num=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(legth&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;legth;i++)&#123;</span><br><span class="line">                res[y][x+i] = num;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            x += legth;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;legth;i++)&#123;</span><br><span class="line">                res[y+i][x] = num;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            y+=legth;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;legth;i++)&#123;</span><br><span class="line">                res[y][x-i] = num;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            x-=legth;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;legth;i++)&#123;</span><br><span class="line">                res[y-i][x] = num;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            y-=(legth<span class="number">-1</span>);</span><br><span class="line">            x++;</span><br><span class="line">            legth -= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n%<span class="number">2</span>==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        res[n/<span class="number">2</span>][n/<span class="number">2</span>] = num;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a><a href="https://leetcode.cn/problems/spiral-matrix/">54. 螺旋矩阵</a></h2><blockquote>
<p>给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。</p>
<p>示例 1：</p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg" alt="img"></p>
<p>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[1,2,3,6,9,8,7,4,5]</p>
<p>示例 2：</p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg" alt="img"></p>
<p>输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br>输出：[1,2,3,4,8,12,11,10,9,5,6,7]</p>
</blockquote>
<h2 id="剑指-Offer-29-顺时针打印矩阵"><a href="#剑指-Offer-29-顺时针打印矩阵" class="headerlink" title="剑指 Offer 29. 顺时针打印矩阵"></a><a href="https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">剑指 Offer 29. 顺时针打印矩阵</a></h2><blockquote>
<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<p>示例 1：</p>
<p>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[1,2,3,6,9,8,7,4,5]<br>示例 2：</p>
<p>输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br>输出：[1,2,3,4,8,12,11,10,9,5,6,7]</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 两道题就是完全一致，和上个题思路一致</span></span><br><span class="line"><span class="comment">// 只需要考虑最后一圈的情况即可</span></span><br><span class="line"><span class="comment">// 这道题还有为空的情况需额外判断</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="type">int</span> x=<span class="number">0</span>,y=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ylen = matrix.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> xlen = matrix[<span class="number">0</span>].<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(ylen&gt;<span class="number">0</span> &amp;&amp; xlen&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;xlen;i++)&#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(matrix[y][x+i]);</span><br><span class="line">            &#125;</span><br><span class="line">            x += xlen;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ylen;i++)&#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(matrix[y+i][x]);</span><br><span class="line">            &#125;</span><br><span class="line">            y += ylen;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;xlen;i++)&#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(matrix[y][x-i]);</span><br><span class="line">            &#125;</span><br><span class="line">            x -= xlen;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ylen;i++)&#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(matrix[y-i][x]);</span><br><span class="line">            &#125;</span><br><span class="line">            y -= ylen<span class="number">-1</span>;</span><br><span class="line">            x++;</span><br><span class="line">            xlen -=<span class="number">2</span>;</span><br><span class="line">            ylen -= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ylen&lt;<span class="number">0</span>&amp;&amp;xlen&lt;<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ylen==<span class="number">0</span> &amp;&amp; xlen==<span class="number">0</span>) res.<span class="built_in">emplace_back</span>(matrix[y][x]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ylen==<span class="number">0</span> &amp;&amp; xlen&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=xlen;i++)</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(matrix[y][x+i]);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ylen&gt;<span class="number">0</span> &amp;&amp; xlen==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=ylen;i++)</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(matrix[y+i][x]);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>主要学习的有数组的基本操作，双指针的操作，快慢指针，对撞指针，滑动窗口的使用，以及循环不变量的使用。</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++算法</tag>
      </tags>
  </entry>
  <entry>
    <title>yaml文件读写</title>
    <url>/link/yaml0410.html</url>
    <content><![CDATA[<h1 id="yaml文件读写"><a href="#yaml文件读写" class="headerlink" title="yaml文件读写"></a>yaml文件读写</h1><h2 id="一、yaml文件介绍"><a href="#一、yaml文件介绍" class="headerlink" title="一、yaml文件介绍"></a>一、yaml文件介绍</h2><p>yaml是一个专门用来写配置文件的语言。</p>
<h6 id="1-yaml文件规则"><a href="#1-yaml文件规则" class="headerlink" title="1. yaml文件规则"></a>1. yaml文件规则</h6><ul>
<li>区分大小写；</li>
<li>使用缩进表示层级关系；</li>
<li>使用空格键缩进，而非Tab键缩进</li>
<li>缩进的空格数目不固定，只需要相同层级的元素左侧对齐；</li>
<li>文件中的字符串不需要使用引号标注，但若字符串包含有特殊字符则需用引号标注；</li>
<li>注释标识为#</li>
</ul>
<h6 id="2-yaml文件数据结构"><a href="#2-yaml文件数据结构" class="headerlink" title="2. yaml文件数据结构"></a>2. yaml文件数据结构</h6><ul>
<li>对象：键值对的集合（简称 “映射或字典”）<br> 键值对用冒号 “:” 结构表示，冒号与值之间需用空格分隔</li>
<li>数组：一组按序排列的值（简称 “序列或列表”）<br> 数组前加有 “-” 符号，符号与值之间需用空格分隔</li>
<li>纯量(scalars)：单个的、不可再分的值（如：字符串、bool值、整数、浮点数、时间、日期、null等）<br> None值可用null可 ~ 表示</li>
</ul>
<h2 id="二、python中读取yaml配置文件"><a href="#二、python中读取yaml配置文件" class="headerlink" title="二、python中读取yaml配置文件"></a>二、python中读取yaml配置文件</h2><h6 id="1-前提条件"><a href="#1-前提条件" class="headerlink" title="1. 前提条件"></a>1. 前提条件</h6><p>python中读取yaml文件前需要安装pyyaml和导入yaml模块：</p>
<ul>
<li>使用yaml需要安装的模块为pyyaml（pip3 install pyyaml）;</li>
<li>导入的模块为yaml（import yaml）</li>
</ul>
<h6 id="2-读取yaml文件数据"><a href="#2-读取yaml文件数据" class="headerlink" title="2. 读取yaml文件数据"></a>2. 读取yaml文件数据</h6><p>python通过open方式读取文件数据，再通过load函数将数据转化为列表或字典；</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_yaml_data</span>(<span class="params">yaml_file</span>):</span><br><span class="line">    <span class="comment"># 打开yaml文件</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;***获取yaml文件数据***&quot;</span>)</span><br><span class="line">    file = <span class="built_in">open</span>(yaml_file, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    file_data = file.read()</span><br><span class="line">    file.close()</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(file_data)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;类型：&quot;</span>, <span class="built_in">type</span>(file_data))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将字符串转化为字典或列表</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;***转化yaml数据为字典或列表***&quot;</span>)</span><br><span class="line">    data = yaml.safe_l(file_data)</span><br><span class="line">    <span class="built_in">print</span>(data)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;类型：&quot;</span>, <span class="built_in">type</span>(data))</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">current_path = os.path.abspath(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">yaml_path = os.path.join(current_path, <span class="string">&quot;config.yaml&quot;</span>)</span><br><span class="line">get_yaml_data(yaml_path)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">***获取yaml文件数据***</span></span><br><span class="line"><span class="string"># yaml键值对：即python中字典</span></span><br><span class="line"><span class="string">usr: my</span></span><br><span class="line"><span class="string">psw: 123455</span></span><br><span class="line"><span class="string">类型：&lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line"><span class="string">***转化yaml数据为字典或列表***</span></span><br><span class="line"><span class="string">&#123;&#x27;usr&#x27;: &#x27;my&#x27;, &#x27;psw&#x27;: 123455&#125;</span></span><br><span class="line"><span class="string">类型：&lt;class &#x27;dict&#x27;&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h6 id="3-yaml文件数据为键值对"><a href="#3-yaml文件数据为键值对" class="headerlink" title="3. yaml文件数据为键值对"></a>3. yaml文件数据为键值对</h6><p>（1）yaml文件中内容为键值对：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># yaml键值对：即python中字典</span></span><br><span class="line">usr: my</span><br><span class="line">psw: 123455</span><br><span class="line">s: <span class="string">&quot; abc\n&quot;</span></span><br></pre></td></tr></table></figure>
<p>python解析yaml文件后获取的数据：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;usr&#x27;</span>: <span class="string">&#x27;my&#x27;</span>, <span class="string">&#x27;psw&#x27;</span>: 123455, <span class="string">&#x27;s&#x27;</span>: <span class="string">&#x27; abc\n&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>（2）yaml文件中内容为“键值对’嵌套”键值对”</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># yaml键值对嵌套：即python中字典嵌套字典</span></span><br><span class="line">usr1:</span><br><span class="line">  name: a</span><br><span class="line">  psw: 123</span><br><span class="line">usr2:</span><br><span class="line">  name: b</span><br><span class="line">  psw: 456</span><br><span class="line">  </span><br><span class="line">Conv2d:</span><br><span class="line">   in_channels: 3</span><br><span class="line">   out_channels: 96</span><br><span class="line">   kernel_size: 11</span><br><span class="line">   stride: 4</span><br><span class="line">LocalResponseNorm:</span><br><span class="line">   size: 5</span><br><span class="line">   alpha: 0.001</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>python解析yaml文件后获取的数据：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;usr1&#x27;</span>: &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;psw&#x27;</span>: 123&#125;, <span class="string">&#x27;usr2&#x27;</span>: &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;psw&#x27;</span>: 456&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>（3）yaml文件中“键值对”中嵌套“数组”</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># yaml键值对中嵌套数组</span></span><br><span class="line">usr3:</span><br><span class="line">  - a</span><br><span class="line">  - b</span><br><span class="line">  - c</span><br><span class="line">usr4:</span><br><span class="line">  - b</span><br></pre></td></tr></table></figure>
<p>python解析yaml文件后获取的数据：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;usr3&#x27;</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], <span class="string">&#x27;usr4&#x27;</span>: [<span class="string">&#x27;b&#x27;</span>]&#125;</span><br></pre></td></tr></table></figure>
<h6 id="4-yaml文件数据为数组"><a href="#4-yaml文件数据为数组" class="headerlink" title="4. yaml文件数据为数组"></a>4. yaml文件数据为数组</h6><p>（1）yaml文件中内容为数组</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># yaml数组</span></span><br><span class="line">- a</span><br><span class="line">- b</span><br><span class="line">- 5</span><br></pre></td></tr></table></figure>
<p>python解析yaml文件后获取的数据：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span>&#x27;a&#x27;<span class="punctuation">,</span> &#x27;b&#x27;<span class="punctuation">,</span> <span class="number">5</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>（2）yaml文件“数组”中嵌套“键值对”</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># yaml<span class="string">&quot;数组&quot;</span>中嵌套<span class="string">&quot;键值对&quot;</span></span></span><br><span class="line">- usr1: aaa</span><br><span class="line">- psw1: <span class="number">111</span></span><br><span class="line">  usr2: bbb</span><br><span class="line">  psw2: <span class="number">222</span></span><br></pre></td></tr></table></figure>
<p>python解析yaml文件后获取的数据：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[&#123;<span class="string">&#x27;usr1&#x27;</span>: <span class="string">&#x27;aaa&#x27;</span>&#125;, &#123;<span class="string">&#x27;psw1&#x27;</span>: 111, <span class="string">&#x27;usr2&#x27;</span>: <span class="string">&#x27;bbb&#x27;</span>, <span class="string">&#x27;psw2&#x27;</span>: 222&#125;]</span><br></pre></td></tr></table></figure>
<h6 id="5-yaml文件中基本数据类型："><a href="#5-yaml文件中基本数据类型：" class="headerlink" title="5. yaml文件中基本数据类型："></a>5. yaml文件中基本数据类型：</h6><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"># 纯量</span><br><span class="line">s_val: name              # 字符串：&#123;<span class="string">&#x27;s_val&#x27;</span>: <span class="string">&#x27;name&#x27;</span>&#125;</span><br><span class="line">spec_s_val: <span class="string">&quot;name\n&quot;</span>    # 特殊字符串：&#123;<span class="string">&#x27;spec_s_val&#x27;</span>: <span class="string">&#x27;name\n&#x27;</span></span><br><span class="line">num_val: <span class="number">31.14</span>          # 数字：&#123;<span class="string">&#x27;num_val&#x27;</span>: <span class="number">31.14</span>&#125;</span><br><span class="line">bol_val: <span class="keyword">true</span>           # 布尔值：&#123;<span class="string">&#x27;bol_val&#x27;</span>: True&#125;</span><br><span class="line">nul_val: <span class="keyword">null</span>           # <span class="keyword">null</span>值：&#123;<span class="string">&#x27;nul_val&#x27;</span>: None&#125;</span><br><span class="line">nul_val1: ~             # <span class="keyword">null</span>值：&#123;<span class="string">&#x27;nul_val1&#x27;</span>: None&#125;</span><br><span class="line">time_val: <span class="number">2018</span><span class="number">-03</span><span class="number">-01</span>t11:<span class="number">33</span>:<span class="number">22.55</span><span class="number">-06</span>:<span class="number">00</span>     # 时间值：&#123;<span class="string">&#x27;time_val&#x27;</span>: datetime.datetime(<span class="number">2018</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">17</span>, <span class="number">33</span>, <span class="number">22</span>, <span class="number">550000</span>)&#125;</span><br><span class="line">date_val: <span class="number">2019</span><span class="number">-01</span><span class="number">-10</span>    # 日期值：&#123;<span class="string">&#x27;date_val&#x27;</span>: datetime.date(<span class="number">2019</span>, <span class="number">1</span>, <span class="number">10</span>)&#125;</span><br></pre></td></tr></table></figure>
<h6 id="6-yaml文件中引用"><a href="#6-yaml文件中引用" class="headerlink" title="6. yaml文件中引用"></a>6. yaml文件中引用</h6><p>yaml文件中内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">animal3: &amp;animal3 fish</span><br><span class="line"><span class="built_in">test</span>: *animal3</span><br></pre></td></tr></table></figure>
<p>python读取的数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;animal3&#x27;</span>: <span class="string">&#x27;fish&#x27;</span>, <span class="string">&#x27;test&#x27;</span>: <span class="string">&#x27;fish&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三、python中读取多个yaml文档"><a href="#三、python中读取多个yaml文档" class="headerlink" title="三、python中读取多个yaml文档"></a>三、python中读取多个yaml文档</h2><h6 id="1-多个文档在一个yaml文件，使用-—-分隔方式来分段"><a href="#1-多个文档在一个yaml文件，使用-—-分隔方式来分段" class="headerlink" title="1. 多个文档在一个yaml文件，使用 —- 分隔方式来分段"></a>1. 多个文档在一个yaml文件，使用 —- 分隔方式来分段</h6><p>如：yaml文件中数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 分段yaml文件中多个文档</span></span><br><span class="line">---</span><br><span class="line">animal1: dog</span><br><span class="line">age: 2</span><br><span class="line">---</span><br><span class="line">animal2: <span class="built_in">cat</span></span><br><span class="line">age: 3</span><br></pre></td></tr></table></figure>
<h6 id="2-python脚本读取一个yaml文件中多个文档方法"><a href="#2-python脚本读取一个yaml文件中多个文档方法" class="headerlink" title="2. python脚本读取一个yaml文件中多个文档方法"></a>2. python脚本读取一个yaml文件中多个文档方法</h6><p>python获取yaml数据时需使用load_all函数来解析全部的文档，再从中读取对象中的数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># yaml文件中含有多个文档时，分别获取文档中数据</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_yaml_load_all</span>(<span class="params">yaml_file</span>):</span><br><span class="line">    <span class="comment"># 打开yaml文件</span></span><br><span class="line">    file = <span class="built_in">open</span>(yaml_file, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    file_data = file.read()</span><br><span class="line">    file.close()</span><br><span class="line">    all_data = yaml.load_all(file_data)</span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> all_data:</span><br><span class="line">        <span class="built_in">print</span>(data)</span><br><span class="line">current_path = os.path.abspath(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">yaml_path = os.path.join(current_path, <span class="string">&quot;config.yaml&quot;</span>)</span><br><span class="line">get_yaml_load_all(yaml_path)</span><br><span class="line"><span class="string">&quot;&quot;&quot;结果</span></span><br><span class="line"><span class="string">&#123;&#x27;animal1&#x27;: &#x27;dog&#x27;, &#x27;age&#x27;: 2&#125;</span></span><br><span class="line"><span class="string">&#123;&#x27;animal2&#x27;: &#x27;cat&#x27;, &#x27;age&#x27;: 3&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="四、python对象生成yaml文档"><a href="#四、python对象生成yaml文档" class="headerlink" title="四、python对象生成yaml文档"></a>四、python对象生成yaml文档</h2><h6 id="1-直接导入yaml（即import-yaml）生成的yaml文档"><a href="#1-直接导入yaml（即import-yaml）生成的yaml文档" class="headerlink" title="1. 直接导入yaml（即import yaml）生成的yaml文档"></a>1. 直接导入yaml（即import yaml）生成的yaml文档</h6><p>通过yaml.dump()方法不会将列表或字典数据进行转化yaml标准模式，只会将数据生成到yaml文档中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将python对象生成yaml文档</span></span><br><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_yaml_doc</span>(<span class="params">yaml_file</span>):</span><br><span class="line">    py_object = &#123;<span class="string">&#x27;school&#x27;</span>: <span class="string">&#x27;zhang&#x27;</span>,</span><br><span class="line">                 <span class="string">&#x27;students&#x27;</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]&#125;</span><br><span class="line">    file = <span class="built_in">open</span>(yaml_file, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    yaml.dump(py_object, file)</span><br><span class="line">    file.close()</span><br><span class="line">current_path = os.path.abspath(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">yaml_path = os.path.join(current_path, <span class="string">&quot;generate.yaml&quot;</span>)</span><br><span class="line">generate_yaml_doc(yaml_path)</span><br><span class="line"><span class="string">&quot;&quot;&quot;结果</span></span><br><span class="line"><span class="string">school: zhang</span></span><br><span class="line"><span class="string">students: [a, b]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h6 id="2-使用ruamel模块中的yaml方法生成标准的yaml文档"><a href="#2-使用ruamel模块中的yaml方法生成标准的yaml文档" class="headerlink" title="2. 使用ruamel模块中的yaml方法生成标准的yaml文档"></a>2. 使用ruamel模块中的yaml方法生成标准的yaml文档</h6><p>（1）使用ruamel模块中yaml前提条件</p>
<ul>
<li>使用yaml需要安装的模块：ruamel.yaml（pip3 install ruamel.yaml）;</li>
<li>导入的模块：from ruamel import yaml</li>
</ul>
<p>（2）ruamel模块生成yaml文档</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">generate_yaml_doc_ruamel</span>(<span class="params">yaml_file</span>):</span><br><span class="line">    <span class="keyword">from</span> ruamel <span class="keyword">import</span> yaml</span><br><span class="line">    py_object = &#123;<span class="string">&#x27;school&#x27;</span>: <span class="string">&#x27;zhang&#x27;</span>,</span><br><span class="line">                 <span class="string">&#x27;students&#x27;</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]&#125;</span><br><span class="line">    file = <span class="built_in">open</span>(yaml_file, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    yaml.dump(py_object, file, Dumper=yaml.RoundTripDumper)</span><br><span class="line">    file.close()</span><br><span class="line">current_path = os.path.abspath(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">yaml_path = os.path.join(current_path, <span class="string">&quot;generate.yaml&quot;</span>)</span><br><span class="line">generate_yaml_doc_ruamel(yaml_path)</span><br><span class="line"><span class="string">&quot;&quot;&quot;结果</span></span><br><span class="line"><span class="string">school: zhang</span></span><br><span class="line"><span class="string">students:</span></span><br><span class="line"><span class="string">- a</span></span><br><span class="line"><span class="string">- b</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>（3）ruamel模块读取yaml文档</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过from ruamel import yaml读取yaml文件</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_yaml_data_ruamel</span>(<span class="params">yaml_file</span>):</span><br><span class="line">    <span class="keyword">from</span> ruamel <span class="keyword">import</span> yaml</span><br><span class="line">    file = <span class="built_in">open</span>(yaml_file, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    data = yaml.load(file.read(), Loader=yaml.Loader)</span><br><span class="line">    file.close()</span><br><span class="line">    <span class="built_in">print</span>(data)</span><br><span class="line">current_path = os.path.abspath(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">yaml_path = os.path.join(current_path, <span class="string">&quot;dict_config.yaml&quot;</span>)</span><br><span class="line">get_yaml_data_ruamel(yaml_path)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>yaml</tag>
      </tags>
  </entry>
  <entry>
    <title>评价方法及标准</title>
    <url>/link/pingjia0331.html</url>
    <content><![CDATA[<h1 id="机器学习之模型评价方法及标准"><a href="#机器学习之模型评价方法及标准" class="headerlink" title="机器学习之模型评价方法及标准"></a>机器学习之模型评价方法及标准</h1><blockquote>
<p>在模型训练中，能够有一个评价模型好坏的标准至关重要，能够帮忙选出表现最好的模型。</p>
</blockquote>
<h2 id="1-模型评价方法"><a href="#1-模型评价方法" class="headerlink" title="1. 模型评价方法"></a>1. 模型评价方法</h2><h2 id="1-1-留出法"><a href="#1-1-留出法" class="headerlink" title="1.1. 留出法"></a>1.1. 留出法</h2><p>​        也就是最常见的模型划分方法，划分为训练集和测试集，一般比例为3:1或者4:1，当作为模型评估标准时，可以按照该方法多次随机划分，能得到多个不同的测试集训练集组合，平均他们的结果，作为评价模型好坏的标准。</p>
<h3 id="1-2-交叉验证法"><a href="#1-2-交叉验证法" class="headerlink" title="1.2. 交叉验证法"></a>1.2. 交叉验证法</h3><p>​        也就是常说的k折交叉验证，将数据集分为k份，每次取k-1份作为训练集，1份作为验证集，共有k种不同的数据集，最后训练k次。当作为评价标准时，可以进行多次的k折交叉验证，取平均作为最后结果，例如“10次10折交叉验证”。极端情况下，每次只使用一个样本作为测试集，被称为留一法。</p>
<h3 id="1-3-自助法"><a href="#1-3-自助法" class="headerlink" title="1.3. 自助法"></a>1.3. 自助法</h3><p>​        数据集划分时，使用留出法会因为数据集规模大小不同带来估计偏差，留一法受训练样本规模变化的影响小，但是计算复杂度高。基于自主采样的自助法是一个比较好的解决方法。</p>
<p>​        给定一个包含有m个数据集的数据集D：</p>
<ul>
<li>每次随机从D中挑选一个样本，拷贝放入训练集中并放回</li>
<li>重复m次，得到包含有m个样本的训练集</li>
<li>剩下的样本作为验证集</li>
</ul>
<p>​        在上面这个过程中，经过概率计算，大概会有三分之一的数据作为验证集保留，这样能够在初始的数据集中得到更多不同的训练集，对集成学习有好处。</p>
<p>​        但是，这种方法破坏了数据集的样本分布，当样本数量足够时，留出法和交叉验证法更常用。</p>
<h2 id="2-评价标准"><a href="#2-评价标准" class="headerlink" title="2. 评价标准"></a>2. 评价标准</h2><h3 id="2-1-均方误差，错误率与精度"><a href="#2-1-均方误差，错误率与精度" class="headerlink" title="2.1. 均方误差，错误率与精度"></a>2.1. 均方误差，错误率与精度</h3><ul>
<li>最常用的回归性能度量“均方误差”</li>
</ul>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202303312113732.png" alt="image-20230331211334986"></p>
<ul>
<li>分类最常用的性能度量</li>
</ul>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202303312114904.png" alt="image-20230331211444005"></p>
<h3 id="2-2-查准率，查全率与-F1"><a href="#2-2-查准率，查全率与-F1" class="headerlink" title="2.2. 查准率，查全率与 F1"></a>2.2. 查准率，查全率与 F1</h3><p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202303312115634.png" alt="image-20230331211541247"></p>
<p>​        一般来讲，查准率和查全率不能兼得，当希望尽可能的增加正例判断的成功概率，可以通过增加选中的样本数，当所有的样本全判断为正例时，查全率为1，相应的查准率会降低。只有在简单的任务中，才有可能做到查准率和查全率都很高。</p>
<p>​        P-R曲线能够较为直观的显示出样本总体的查全率和查准率：</p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202303312126731.png" alt="image-20230331212600251"></p>
<ul>
<li>首先将所有的样本按照正样本概率从大到小排列</li>
<li>逐个将样本作为正例进行预测，每次计算当前的查准率和查全率</li>
<li>以查准率为纵轴，查全率为横轴画出图像得到P-R曲线</li>
</ul>
<p>​        当P-R曲线上一个学习器的曲线被另一个完全包住，则可断言，后面的学习器性能优于前者。</p>
<p>​        常用的综合考虑查准率与查全率的是F1度量：</p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202303312132491.png" alt="image-20230331213208302"></p>
<p>​        更一般的是$F_{\beta}$度量：</p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202303312133197.png" alt="image-20230331213330915"></p>
<p>​        当$\beta = 1$时即为F1度量，当$\beta &gt; 1$时查全率有更大影响，当$\beta &lt; 1$时查准率有更大影响。</p>
<p>F1-score适用于二分类问题，对于多分类问题，将二分类的F1-score推广，有Micro-F1和Macro-F1两种度量。</p>
<p><strong>【Macro-F1】</strong></p>
<p>​        统计各个类别的TP、FP、FN、TN，分别计算各自的Precision和Recall，得到各自的F1值，然后取平均值得到Macro-F1。</p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202303312147201.png" alt="image-20230331214737524"></p>
<p><strong>【Micro-F1】</strong></p>
<p>​        统计各个类别的TP、FP、FN、TN，加和构成新的TP、FP、FN、TN，然后计算Micro-Precision和Micro-Recall，得到Micro-F1。具体的说，统计出来各个类别的混淆矩阵，然后把混淆矩阵“相加”起来，得到一个多类别的混淆矩阵，然后再计算F1score。</p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202303312148488.png" alt="image-20230331214832235"></p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202303312148498.png" alt="image-20230331214853139"></p>
<p><strong>【总结】</strong></p>
<p>​        从上面二者计算方式上可以看出，Macro-F1平等地看待各个类别，它的值会受到稀有类别的影响；而Micro-F1则更容易受到常见类别的影响。</p>
<h3 id="2-3-真正例率，假正例率与AUC"><a href="#2-3-真正例率，假正例率与AUC" class="headerlink" title="2.3. 真正例率，假正例率与AUC"></a>2.3. 真正例率，假正例率与AUC</h3><h4 id="2-3-1-概念"><a href="#2-3-1-概念" class="headerlink" title="2.3.1 概念"></a>2.3.1 概念</h4><p>​        真正例率（TPR）和假正例率（FPR）:</p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202303312153226.png" alt="image-20230331215332023"></p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202303312235264.png" alt="image-20230331223525494"></p>
<p>​        ROC曲线的绘画方式类似P-R曲线，过程如下：</p>
<ul>
<li>将测试样本按照正例概率从大到小排列</li>
<li>逐个将样本作为正例进行预测，每次计算当前的TPR和FPR</li>
<li>以TPR为纵轴，FPR为横轴画出图像得到P-R曲线</li>
</ul>
<p>​        评价标准一般计算AUC，曲线下面积，AUC面积大的效果好。</p>
<h4 id="2-3-2-AUC计算"><a href="#2-3-2-AUC计算" class="headerlink" title="2.3.2 AUC计算"></a>2.3.2 AUC计算</h4><ul>
<li>方法一：</li>
</ul>
<p>​        在有M个正样本,N个负样本的数据集里。一共有M<em>N对样本（一对样本即，一个正样本与一个负样本）。统计这M</em>N对样本里，正样本的预测概率大于负样本的预测概率的个数。<br>$\frac {\sum I(P<em>{正样本}，P</em>{负样本})}{M*N}$，其中，</p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202303312224462.png" alt="image-20230331222404262"></p>
<p>举一个例子</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>ID</th>
<th>label</th>
<th>pro</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>0</td>
<td>0.1</td>
</tr>
<tr>
<td>B</td>
<td>0</td>
<td>0.4</td>
</tr>
<tr>
<td>C</td>
<td>1</td>
<td>0.35</td>
</tr>
<tr>
<td>D</td>
<td>1</td>
<td>0.8</td>
</tr>
</tbody>
</table>
</div>
<p>假设有4条样本。2个正样本，2个负样本，那么M*N=4。即总共有4个样本对。分别是：$（D,B）,（D,A）,(C,B),（C,A$）。</p>
<p>在$（D,B）$样本对中，正样本D预测的概率大于负样本B预测的概率（也就是D的得分比B高），记为1。</p>
<p>同理，对于$（C,B）$。正样本C预测的概率小于负样本C预测的概率，记为0.</p>
<p>最后可以算得，总共有3个符合正样本得分高于负样本得分，故最后的AUC为$ \frac {1+1+1+0}{4} = 0.75$</p>
<p>在这个案例里，没有出现得分一致的情况，假如出现得分一致的时候，例如：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>ID</th>
<th>label</th>
<th>pro</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>0</td>
<td>0.1</td>
</tr>
<tr>
<td>B</td>
<td>0</td>
<td>0.4</td>
</tr>
<tr>
<td>C</td>
<td>1</td>
<td>0.4</td>
</tr>
<tr>
<td>D</td>
<td>1</td>
<td>0.8</td>
</tr>
</tbody>
</table>
</div>
<p>同样本是4个样本对，对于样本对（C,B）其I值为0.5。<br>最后的AUC为 $\frac {1+1+1+0.5}{4} = 0.875$</p>
<ul>
<li>方法二：</li>
</ul>
<p>​        另外一个方法就是利用下面的公式：</p>
<p>​                                                                        $AUC = \frac {\sum<em>{ins_i \in positiveclass}rank</em>{ins_i} - \frac {M \times (M+1)}{2}}{M \times N}$</p>
<p>​        $rank_{ins_i}$，代表第i条样本的序号。（概率得分从小到大排，排在第rank个位置）</p>
<p>​        $M,N$分别是正样本的个数和负样本的个数</p>
<p>​        $\sum_{ins_i \in positiveclass}$只把正样本的序号加起来。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>ID</th>
<th>label</th>
<th>pro</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>0</td>
<td>0.1</td>
</tr>
<tr>
<td>B</td>
<td>0</td>
<td>0.4</td>
</tr>
<tr>
<td>C</td>
<td>1</td>
<td>0.35</td>
</tr>
<tr>
<td>D</td>
<td>1</td>
<td>0.8</td>
</tr>
</tbody>
</table>
</div>
<p>将这个例子排序。按概率排序后得到：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>ID</th>
<th>label</th>
<th>pro</th>
<th>rank</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>0</td>
<td>0.1</td>
<td>1</td>
</tr>
<tr>
<td>C</td>
<td>1</td>
<td>0.35</td>
<td>2</td>
</tr>
<tr>
<td>B</td>
<td>0</td>
<td>0.4</td>
<td>3</td>
</tr>
<tr>
<td>D</td>
<td>1</td>
<td>0.8</td>
<td>4</td>
</tr>
</tbody>
</table>
</div>
<p>​        按照上面的公式，只把正样本的序号加起来也就是只把样本C,D的rank值加起来后减去一个常数项$ \frac{M(M+1)}{2}$</p>
<p>即：$\frac{(4+2) - \frac{2<em>(2+1)}{2}}{2</em>2} = \frac{6-3}{4} = 0.75$，这个答案和我们上面所计算的是一样的。</p>
<p>这个时候，有个问题，假如出现得分一致的情况怎么办？下面举一个例子说明：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>ID</th>
<th>label</th>
<th>pro</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>1</td>
<td>0.8</td>
</tr>
<tr>
<td>B</td>
<td>1</td>
<td>0.7</td>
</tr>
<tr>
<td>C</td>
<td>0</td>
<td>0.5</td>
</tr>
<tr>
<td>D</td>
<td>0</td>
<td>0.5</td>
</tr>
<tr>
<td>E</td>
<td>1</td>
<td>0.5</td>
</tr>
<tr>
<td>F</td>
<td>1</td>
<td>0.5</td>
</tr>
<tr>
<td>G</td>
<td>0</td>
<td>0.3</td>
</tr>
</tbody>
</table>
</div>
<p>​        在这个例子中，有4个取值概率为0.5，而且既有正样本也有负样本的情况。计算的时候，其实原则就是相等得分的rank取平均值。具体来说如下：<br>先排序：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>ID</th>
<th>label</th>
<th>pro</th>
<th>rank</th>
</tr>
</thead>
<tbody>
<tr>
<td>G</td>
<td>0</td>
<td>0.3</td>
<td>1</td>
</tr>
<tr>
<td>F</td>
<td>1</td>
<td>0.5</td>
<td>2</td>
</tr>
<tr>
<td>E</td>
<td>1</td>
<td>0.5</td>
<td>3</td>
</tr>
<tr>
<td>D</td>
<td>0</td>
<td>0.5</td>
<td>4</td>
</tr>
<tr>
<td>C</td>
<td>0</td>
<td>0.5</td>
<td>5</td>
</tr>
<tr>
<td>B</td>
<td>1</td>
<td>0.7</td>
<td>6</td>
</tr>
<tr>
<td>A</td>
<td>1</td>
<td>0.8</td>
<td>7</td>
</tr>
</tbody>
</table>
</div>
<p><strong>这里需要注意的是：相等概率得分的样本，无论正负，谁在前，谁在后无所谓。</strong></p>
<p>由于只考虑正样本的rank值：<br>对于正样本A，其rank值为7<br>对于正样本B，其rank值为6<br>对于正样本E，其rank值为（5+4+3+2）/4<br>对于正样本F，其rank值为（5+4+3+2）/4</p>
<p>最后我们得到：</p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202303312217497.png" alt="在这里插入图片描述"></p>
<h4 id="2-3-3-多分类下ROC曲线："><a href="#2-3-3-多分类下ROC曲线：" class="headerlink" title="2.3.3 多分类下ROC曲线："></a>2.3.3 多分类下ROC曲线：</h4><p>​        假设测试样本个数为m，类别个数为n。在训练完成后，计算出每个测试样本的在各类别下的概率或置信度，得到一个</p>
<p>$[m， n]$形状的矩阵P，每一行表示一个测试样本在各类别下概率值（按类别标签排序）。相应地，将每个测试样本的标签用</p>
<p>$[0,1,0,0,0,..]$形式表示，可以获得一个$[m， n]$的标签矩阵L。</p>
<ul>
<li><p>①方法一：</p>
<p>n类中每次取一个类别作为正例，其余作为反例，可以计算出各个阈值下的假正例率（FPR）和真正例率（TPR），从而绘</p>
<p>制出一条ROC曲线。这样总共可以绘制出n条ROC曲线。最后对n条ROC曲线取平均，即可得到最终的ROC曲线。</p>
</li>
<li><p>②方法二：</p>
<p>首先，对于一个测试样本：</p>
<p>1）标签只由0和1组成，1的位置表明了它的类别（可对应二分类问题中的‘’正’’），0就表示其他类别（‘’负‘’）；</p>
<p>2）要是分类器对该测试样本分类正确，则该样本标签中1对应的位置在概率矩阵P中的值是大于0对应的位置的概率值的。</p>
<p>基于这两点，将标签矩阵L和概率矩阵P分别按行展开，转置后形成两列，这就得到了一个二分类的结果。所以，此方法经</p>
<p>过计算后可以直接得到最终的ROC曲线。</p>
</li>
</ul>
<p>​        上面的两个方法得到的ROC曲线是不同的，当然曲线下的面积AUC也是不一样的。 在python中，方法1和方法2分别对应sklearn.metrics.roc_auc_score函数中参数average值为’macro’和’micro’的情况。</p>
<h3 id="2-4-代价敏感错误率以及代价曲线"><a href="#2-4-代价敏感错误率以及代价曲线" class="headerlink" title="2.4. 代价敏感错误率以及代价曲线"></a>2.4. 代价敏感错误率以及代价曲线</h3><p>​        在非均等代价下,我们所希望的不再是简单地最小化错误次数,而是希望最小化”总体代价”(total cost)。因此，我们引入”代价敏感”(cost-sensitive)错误率的这样一个代价敏感性指标：</p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202304041539047.png" alt="image-20230404153947927"></p>
<p>代价曲线绘制：</p>
<ol>
<li><p>ROC曲线上每一点对应了代价平面上的一条线段；</p>
</li>
<li><p>设ROC曲线上点的坐标为(TPR,FPR),则可相应计算出FNR；</p>
</li>
<li><p>然后在代价平面上绘制一条从(0,FPR)到(1,FNR)的线段,线段下的面积即表示了该条件下的期望总体代价;</p>
</li>
<li><p>如此将ROC曲线上的每个点转化为代价平面上的一条线段（例如红色线）；</p>
</li>
<li><p>然后取所有线段的下界形成代价曲线,围成的面积即为在所有条件下学习器的期望总体代价。</p>
</li>
</ol>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202304041528570.jpeg" alt="图片"></p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202304041537369.png" alt="image-20230404153725391"></p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202304041537817.png" alt="image-20230404153757284"></p>
<h3 id="2-5-比较总结"><a href="#2-5-比较总结" class="headerlink" title="2.5. 比较总结"></a>2.5. 比较总结</h3><ul>
<li>ROC曲线由于兼顾正例与负例，所以适用于评估分类器的整体性能，相比而言PR曲线完全聚焦于正例。</li>
<li>如果有多份数据且存在不同的类别分布，比如信用卡欺诈问题中每个月正例和负例的比例可能都不相同，这时候如果只想单纯地比较分类器的性能且剔除类别分布改变的影响，则ROC曲线比较适合，因为类别分布改变可能使得PR曲线发生变化时好时坏，这种时候难以进行模型比较；反之，如果想测试不同类别分布下对分类器的性能的影响，则PR曲线比较适合。</li>
<li>如果想要评估在相同的类别分布下正例的预测情况，则宜选PR曲线。</li>
<li>如果是不平衡类，正负样本比例悬殊的情况下：正样本的数目非常的稀有，而且很重要，那么选择PR会更合适，比如常见的目标检测任务中，一般正样本相对于负样本来占比小，所以通常选择PR曲线，计算mAP来对进行模型性能对比。</li>
<li>类别不平衡问题中，ROC曲线通常会给出一个乐观的效果估计，所以大部分时候还是PR曲线更好。</li>
<li>最后可以根据具体的应用，在曲线上找到最优的点，得到相对应的precision，recall，f1 score等指标，去调整模型的阈值，从而得到一个符合具体应用的模型。</li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>经典算法</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习之决策树（一）</title>
    <url>/link/jueceshu0304.html</url>
    <content><![CDATA[<h1 id="机器学习之决策树（一）"><a href="#机器学习之决策树（一）" class="headerlink" title="机器学习之决策树（一）"></a>机器学习之决策树（一）</h1><blockquote>
<p>决策树作为传统机器学习中目前仍常用的模型，其在处理表格数据时表现优秀，效果要比神经网络更好，也具有更好的可解释性。</p>
</blockquote>
<h1 id="为什么是决策树"><a href="#为什么是决策树" class="headerlink" title="为什么是决策树"></a>为什么是决策树</h1><blockquote>
<p>文本来自：<a href="https://blog.csdn.net/Datawhale/article/details/126112888">XGBoost 和随机森林在表格数据上优于深度学习？</a></p>
<p>论文地址：<a href="https://hal.archives-ouvertes.fr/hal-03723551/document">Why do tree-based models still outperform deep learning on typical tabular data?</a></p>
</blockquote>
<p>​        深度学习在图像、语言甚至音频等领域取得了巨大的进步。然而，在处理表格数据上，深度学习却表现一般。由于<strong>表格数据具有特征不均匀、样本量小、极值较大等特点</strong>，因此很难找到相应的不变量。</p>
<p>​        基于树的模型不可微，不能与深度学习模块联合训练，因此创建特定于表格的深度学习架构是一个非常活跃的研究领域。许多研究都声称可以击败或媲美基于树的模型，但他们的研究遭到很多质疑。</p>
<p>​        事实上，对表格数据的学习缺乏既定基准，这样一来研究人员在评估他们的方法时就有很多自由度。此外，与其他机器学习子域中的基准相比，大多数在线可用的表格数据集都很小，这使得评估更加困难。</p>
<p>​        为了缓解这些担忧，来自法国国家信息与自动化研究所、索邦大学等机构的研究者提出了一个表格数据基准，其能够评估最新的深度学习模型，并表明<strong>基于树的模型在中型表格数据集上仍然是 SOTA</strong>。</p>
<p>​        对于这一结论，文中给出了确凿的证据，<strong>在表格数据上，使用基于树的方法比深度学习（甚至是现代架构）更容易实现良好的预测</strong>，研究者并探明了其中的原因。</p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202303041928764.png" alt="a32eb04e979f7a62407591829134a220.png"></p>
<p>​        <strong>该研究为表格数据创建了一个新的基准（选取了 45 个开放数据集）</strong>，并通过 OpenML 共享这些数据集，这使得它们易于使用。</p>
<p>​        该研究在表格数据的多种设置下比较了深度学习模型和基于树的模型，并考虑了选择超参数的成本。该研究还分享了随机搜索的原始结果，这将使研究人员能够廉价地测试新算法以获得固定的超参数优化预算。</p>
<p>新基准参考 45 个表格数据集，选择基准如下 ：</p>
<ul>
<li>异构列，列应该对应不同性质的特征，从而排除图像或信号数据集。</li>
<li>维度低，数据集 d/n 比率低于 1/10。</li>
<li>无效数据集，删除可用信息很少的数据集。</li>
<li>I.I.D.（独立同分布）数据，移除类似流的数据集或时间序列。</li>
<li>真实世界数据，删除人工数据集，但保留一些模拟数据集。</li>
<li>数据集不能太小，删除特征太少（&lt; 4）和样本太少（&lt; 3 000）的数据集。</li>
<li>删除过于简单的数据集。</li>
<li>删除扑克和国际象棋等游戏的数据集，因为这些数据集目标都是确定性的。</li>
</ul>
<p>​        在基于树的模型中，研究者选择了 3 种 SOTA 模型：<strong>Scikit Learn 的 RandomForest，GradientBoostingTrees (GBTs) ， <a href="https://so.csdn.net/so/search?q=XGBoost&amp;spm=1001.2101.3001.7020">XGBoost</a> 。</strong>对深度模型进行了以下基准测试：<strong>MLP、Resnet 、FT Transformer、SAINT </strong>。</p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202303041932693.png" alt="e34364f36cb2fa1d83c5a554bb27e4ea.png"></p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202303041930408.png" alt="abf439024adcc94355531d8b16ae94eb.png"></p>
<p>​        图 1 和图 2 给出了不同类型数据集的基准测试结果。基于树的模型在各种超参数选择中击败了神经网络。事实上，<strong>处理表格数据的最佳方法有两个共有属性：它们是集成方法、bagging（<a href="https://so.csdn.net/so/search?q=随机森林&amp;spm=1001.2101.3001.7020">随机森林</a>）或 boosting（XGBoost、GBT），而这些方法中使用的弱学习器是决策树。</strong></p>
<p><strong>发现 1：神经网络（NN）倾向于过度平滑的解决方案</strong></p>
<p>​        如图 3 所示，对于较小的尺度，平滑训练集上的目标函数会显着降低基于树的模型的准确率，但几乎不会影响 NN。这些结果表明，<strong>数据集中的目标函数并不平滑，与基于树的模型相比，NN 难以适应这些不规则函数。</strong>这与 Rahaman 等人的发现一致，他们发现 NN 偏向于低频函数。基于决策树的模型学习分段（piece-wise）常函数，没有这样的偏置。</p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202307011633996.png" alt="6db257a9b397fb8672d559235662d94d.png"></p>
<p><strong>发现 2：非信息特征更能影响类似 MLP 的 NN</strong></p>
<p>​        <strong>表格数据集包含许多非信息（ uninformative）特征</strong>，对于每个数据集，该研究根据特征的重要性会选择丢弃一定比例的特征（通常按随机森林排序）。从图 4 可以看出，去除一半以上的特征对 GBT 的分类准确率影响不大。</p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202307011632058.png" alt="d1cb5cfcd9ea32b73c25e39e477e5fe4.png"></p>
<p>​        图 5 可以看到移除非信息特征 (5a) 减少了 MLP (Resnet) 与其他模型（FT Transformers 和基于树的模型）之间的性能差距 ，而添加非信息特征会扩大差距，这表明 <strong>MLP 对非信息特征的鲁棒性较差</strong>。在图 5a 中，当研究者移除更大比例的特征时，相应的也会删除有用信息特征。图 5b 表明，去除这些特征所带来的准确率下降可以通过去除非信息特征来补偿，与其他模型相比，这对 MLP 更有帮助（同时，该研究还删除了冗余特性，也不会影响模型性能）。</p>
<p><strong><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202307011632269.png" alt="72e655ababefb66125554a436fe2fe7d.png"></strong></p>
<p><strong>发现 3：通过旋转，数据是非不变的</strong></p>
<p>​        与其他模型相比，<strong>为什么 MLP 更容易受到非信息特征的影响？其中一个答案是，MLP 是旋转不变的</strong>：当对训练集和测试集特征应用旋转时，在训练集上学习 MLP 并在测试集上进行评估，这一过程是不变的。事实上，任何旋转不变的学习过程都具有最坏情况下的样本复杂度，该复杂度至少在不相关特征的数量上呈线性增长。直观地说，为了去除无用特征，旋转不变算法必须首先找到特征的原始方向，然后选择信息最少的特征。</p>
<p>​        图 6a 显示了当对数据集进行随机旋转时的测试准确率变化，证实<strong>只有 Resnets 是旋转不变的</strong>。值得注意的是，随机旋转颠倒了性能顺序：结果是 NN 在基于树的模型之上，Resnets 在 FT Transformer 之上，这表明旋转不变性是不可取的。事实上，表格数据通常具有单独含义，例如年龄、体重等。</p>
<p>​        图 6b 中显示：删除每个数据集中最不重要的一半特征（在旋转之前），会降低除 Resnets 之外的所有模型的性能，但与没有删除特征使用所有特征时相比，相比较而言，下降的幅度较小。</p>
<p><strong><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202307011631869.png" alt="1e3f99d968132ffa1528485552610680.png"></strong></p>
<h1 id="如何学习决策树"><a href="#如何学习决策树" class="headerlink" title="如何学习决策树"></a>如何学习决策树</h1><ul>
<li>首先，需要了解信息熵，条件熵，信息增益，信息增益率，基尼不纯度等概念</li>
<li>然后，学习单个的决策树，ID3，C4.5，CART</li>
<li>接着，学习集成的决策树，bagging（RF），boosting（GBDT，XGBoost，LightGBM，CatBoost）</li>
<li>最后，学习决策树的剪枝等操作</li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>经典算法</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习之决策树（二）</title>
    <url>/link/jueceshu03041.html</url>
    <content><![CDATA[<h1 id="机器学习之决策树（二）"><a href="#机器学习之决策树（二）" class="headerlink" title="机器学习之决策树（二）"></a>机器学习之决策树（二）</h1><blockquote>
<p>决策树学习前了解相关的概念很重要。</p>
</blockquote>
<h2 id="决策树相关概念"><a href="#决策树相关概念" class="headerlink" title="决策树相关概念"></a>决策树相关概念</h2><blockquote>
<p>文章来源：<a href="https://zhuanlan.zhihu.com/p/399549773?utm_id=0">https://zhuanlan.zhihu.com/p/399549773?utm_id=0</a></p>
</blockquote>
<p>​        决策树模型是一种if-else型的模型，通过对数据集的学习，生成树模型的内部节点，内部节点表示对一个属性的判断。以一个小球分类问题为例，假设有100个小球，其中40个为红色球，60个为蓝色球。而小球有三种特征，分别是表面粗糙度、半径和质量。现在需要依据这三个特征来推算出小球颜色。假设我们尝试使用小球半径这一特征来区分小球，如使用0.5作为分界。将这100个小球分到两个箱子里，大于0.5的在一个箱子里，小于等于0.5的在另一个箱子里。我们得到了如下图所示的结果</p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202303042219523.webp" alt="img"></p>
<p>​        凭感觉可以看出，使用这一特征对小球进行区分，看似红和蓝分的更开了。但这不够严谨，而且无法使用数字去比较使用不同特征去对小球分类获得的结果的好坏，也难以比较r使用0.4或者0.6分类，哪个效果更好。为了度量分类结果的好坏，引入了信息熵的概念。</p>
<p>​        从定义上讲，<strong>信息熵用来衡量不确定性，不确定性越强，则信息熵越大，不确定性越弱，则信息熵越小。</strong>其公式如下所示。</p>
<p>​                                                                      <script type="math/tex">H(X)=-\sum_{i=1}^{n} P(X=i) \log _{2} P(X=i)</script></p>
<p>​        有了信息熵，我们就可以量化计算之前的小球分类问题了。但为了表述准确，还需要引入两个概念，条件熵和信息增益。</p>
<p>​        <strong>条件熵，定义是在给定随机变量Y的条件下，随机变量X的不确定性。</strong>用通俗的话讲就是，施加一个条件后（如r&gt;0.5），在这一条件下的信息熵。可以类比条件概率去理解。</p>
<p>​                                                           <script type="math/tex">H(X \mid Y=v)=-\sum_{i=1}^{n} P(X=i \mid Y=v) \log _{2} P(X=i \mid Y=v)</script></p>
<p>​        <strong>信息增益则是用于衡量给定条件后，信息的不确定性减少了多少</strong>。即加了个条件后，信息熵的变化。</p>
<p>​                                                                              <script type="math/tex">I(X, Y)=H(X)-H(X \mid Y)</script></p>
<p>使用这三个概念，再来看小球分类问题。</p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202303042221385.webp" alt="img"></p>
<p>​        代入公式就可以算出叶子结点的条件熵以及根结点的信息熵。而信息增益则是父节点的熵减去子节点的加权熵。<strong>使用信息增益则可以用来衡量这一节点构建的好坏。</strong></p>
<p>​                                    <script type="math/tex">\text{信息增益 = 父节点熵 - 子节点的加权熵} = 0.971 - (0.62360.45+0.22540.55)/2=0.5664\\</script></p>
<h2 id="决策树原理"><a href="#决策树原理" class="headerlink" title="决策树原理"></a>决策树原理</h2><h3 id="ID3"><a href="#ID3" class="headerlink" title="ID3"></a>ID3</h3><p>​        理解了信息增益和决策树的基本概念之后，就可以开始学习决策树的构建算法。这一部分将借鉴于大名鼎鼎的西瓜书里的例子。以选西瓜为例（数据集的情况见下图），根结点(即原始数据集)中，<strong>有8个好瓜和9个坏瓜，信息熵为0.998</strong>。</p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202303042224021.webp" alt="img"></p>
<p>​        现在开始选择第一个特征，如果第一个特征选色泽，则根据前面介绍的方法，计算出的信息增益为0.109，即Gain(D,色泽)=0.109。同理，如果选择其他特征，则信息增益如下，</p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202303042224027.webp" alt="img"></p>
<p>​        而该算法的逻辑是<strong>每次进行特征选择时，选取最大信息增益的特征</strong>。而根据计算结果，纹理是信息增益最大的特征。因此该决策树的第一层就构建完成了，其结构见下图</p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202303042224897.webp" alt="img"></p>
<p>​        使用纹理这一<strong>特征将树的第一层构建完成之后，继续递归寻找除了纹理之外的特征的信息增益最大的特征</strong>。分别对纹理分类后的三个子节点计算增益，以纹理清晰这一子节点为例。继续计算各个特征带来的信息增益，得到如下计算结果。</p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202303042224952.webp" alt="img"></p>
<p>发现触感、根蒂、脐部的信息增益最大，三则任选其一即可。对这一层递归完成后，得到下图的树结构。</p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202303042224706.webp" alt="img"></p>
<p><strong>以此类推，直到叶子节点全部输出或无数据集可遍历即结束</strong>。</p>
<p>在这里总结一下，ID3的决策树算法的流程为：</p>
<ul>
<li><p>1.寻找最优特征，即计算信息增益</p>
</li>
<li><p>2.将最优特征的特征值作为有向边，判断子数据集</p>
</li>
</ul>
<blockquote>
<p>若子数据集均为同一类，则输出叶子节点；反之，若子数据集中仍有特征，重复1，2过程，若没有更多特征，则将最多的一类输出为叶子节点</p>
</blockquote>
<ul>
<li>3.叶子节点全部输出或无数据集可遍历即结束。</li>
</ul>
<p>​        但ID3算法的缺点依旧明显，从上述例子可以看出，<strong>该方法只适用于计算特征是离散的</strong>，比如触感是硬滑还是软粘这种特征，但<strong>不能处理比如0-1这样的连续特征值</strong>。并且用<strong>这种方式遍历构建决策树，会有过拟合问题</strong>。而且ID3倾向于选择大量值的属性(即特征值多的)。为了解决这些问题，引出了C4.5算法。</p>
<h3 id="C4-5"><a href="#C4-5" class="headerlink" title="C4.5"></a>C4.5</h3><p>​        <strong>为了解决特征值数量问题对信息增益计算的影响。该算法使用信息增益率替代信息增益作为寻找最优特征的判据</strong>。其计算公式就是信息增益除以子节点的熵。</p>
<p>​                                                            <script type="math/tex">GainRatio(D|A)=\frac{infoGain(D|A)}{IV(A)}</script></p>
<p>​                 <script type="math/tex">IV(A)=-\sum_{k=1}^{K}{\frac{|D_k|}{|D|}*log_2{\frac{|D_k|}{|D|}}}</script></p>
<p>​        其中 $A=[a_1,a_2,…,a_k] $，$K$个值。若使用$A$来对样本集$D$进行划分，则会产生$K$个分支节点，其中第$k$个节点包含$D$中所有属性$A$上取值为$ a_k $的样本，记为 $D_k $。<strong>通常，属性$A$的可能取值数越多（即$K$越大），则$IV(A)$的值通常会越大</strong>。</p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202303042246254.webp" alt="image.png"></p>
<p>​        <strong>针对ID3算法不能处理连续特征的问题，该算法使用二分法做离散化处理，先将连续特征从小到大排序，对N个连续数据进行N-1个二分划分，遍历N-1个划分点，分别计算这些子节点的信息增益，选择信息增益最大的二分结果作为该连续特征的最佳划分点。</strong></p>
<p>​        信息增益率准则对可取值数目较少的属性有所偏好。所以，<strong>C4.5算法不是直接选择信息增益率最大的候选划分属性，而是先从候选划分属性中找出<code>信息增益</code>高于平均水平的属性，再从中选择<code>信息增益率</code>最高的</strong>。</p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202303042228018.webp" alt="img"></p>
<p>​        总结一下，该方法使用信息增益率解决了ID3倾向于特征数量多的特征这一问题，并且实现了应用在连续特征中。并且<strong>可以使用剪枝来避免过拟合</strong>，剪枝由于是一个单独的知识体系，本文先不涉及。但是，可以看出，使用二分法对连续特征离散化的计算量很大。当连续特征数量比较多的时候，往往需要花费很长的时间去计算连续特征的信息增益率。并且，该算法没有考虑各个特征之间的相关性。</p>
<h3 id="CART3"><a href="#CART3" class="headerlink" title="CART3"></a>CART3</h3><p>​        CART3算法针对分类数，引入了<strong>基尼不纯度（又称基尼指数）</strong>这一概念，这一概念<strong>表示样本集合中在一个随机选中的样本被分错的概率</strong>。<strong>该指数越小表示该集合的纯度越高</strong>，所有样本为同一类时，基尼指数为0。其中pk表示选中的样本属于第k个类别的概率。</p>
<p>​                                                                                            <script type="math/tex">\operatorname{Gini}(\mathrm{p})=\sum_{k=1}^{K} p_{k}\left(1-p_{k}\right)=1-\sum_{k=1}^{K} p_{k}{ }^{2}</script></p>
<p>数据集合D在特征A的条件下分成了D1和D2，则集合D的基尼指数被定义为：</p>
<p>​                                                                                        <script type="math/tex">\operatorname{Gini}(D, A)=\frac{\left|D_{1}\right|}{|D|} \operatorname{Gini}\left(D_{1}\right)+\frac{\left|D_{2}\right|}{|D|} \operatorname{Gini}\left(D_{2}\right)</script></p>
<p>​        分类依据和前两种算法不同，其他都大体相似，在此不过多赘述。本文重点关注<strong>CART3回归树，回归树的构建是用平方误差最小化准则进行特征选择，去生成二叉树。</strong></p>
<p>目标准则可以用如下公式来表达，第j个特征选择s为切分点，使得label值和该划分区域的值c平方和最小。</p>
<p>​                                                                          <script type="math/tex">\min {j, s}\left[\min {c_{1}} \sum_{x_{i} \in R_{1}(j, s)}\left(y_{i}-c_{1}\right)^{2}+\min {c{2}} \sum_{x_{2} \in R_{2}(j, s)}\left(y_{i}-c_{2}\right)^{2}\right]</script></p>
<p>第j个特征选择s为切分点，则划分出了两个集合，其中x为特征值，y为label。</p>
<p>​                                                                                 <script type="math/tex">R_{1}(j , s)=\left\{x \mid x^{(j)} \leq s\right\}, \quad R_{2}(j, s)=\left\{x \mid x^{(j)}>s\right\}.</script></p>
<p>被s划分出的两个区域，使用这两个区域的均值代表这个两个区域的值，即</p>
<p>​                                                                                      <script type="math/tex">c_{1}=\frac{1}{N_{1}} \sum_{x_{i} \in R_{1}} y_{i}, \quad c_{2}=\frac{1}{N_{2}} \sum_{x_{i} \in R_{2}} y_{i}</script></p>
<p>这是c的一般形式，递归至整棵树构建完成。</p>
<p>​                                                                                      <script type="math/tex">\hat{c}_{m}=\frac{1}{N_{m}} \operatorname{\sum}_{x_{i} \in R_{m}(j, s)} y_{i}, x \in R_{m}, m=1,2</script></p>
<p>该回归树的数学表达式，可理解为将输入空间划分为M个区域$R1,R2,…Rm$所生成的决策树。 <script type="math/tex">f(x)=\sum_{m=1}^{M} \hat{c}_{m} I(x \in R)</script></p>
<p>相信第一次看到上述的公式很大可能一头雾水吧，数学表达式为了反应一般情况而变得十分抽象。下面给出一个例子，结合例子再回过去看上面的公式和符号，就会比较清晰。假如目标是对下面这一组x和y做回归。</p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202307011636261.png" alt="img"></p>
<p>​        该特征为连续特征，前文提到的<strong>C4.5算法采取的策略是对其进行二分法并逐个计算信息增益率，来寻找最优的切分点</strong>。而<strong>CART3算法则不然，该算法计算不同的切分点的平方误差</strong>。以切分点$s=1.5$为例，则该切分点划出了两个区域$R1={1}，R2={2,3,…,10}$。计算这两个区域中y的平均值，得$c1=5.56，c2=7.50$。现在需要计算使用c1和c2代表该区域的值是否准确，带入前文的目标准则函数来计算平方误差。</p>
<p>​                                       <script type="math/tex">m(s)=\min _{j, s}\left[\min _{c_{1}} \sum_{x_{i} \in R_{1}(j, s)}\left(y_{i}-c_{1}\right)^{2}+\min _{c_{2}} \sum_{x_{i} \in R_{2}(j, s)}\left(y_{i}-c_{2}\right)^{2}\right]=0+15.72=15.72</script></p>
<p>这表明了使用$s=1.5$作为切分点，平方误差为15.72。同理，算出切分点s在$1.5,2.5,3.5,4.5,5.5,6.5,7.5,8.5,9.5$时的m(s)如下表。</p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202307011637293.png" alt="img"></p>
<p>可以看出，<strong>$s=6.5$时，该误差最小。因此在6.5处设置切分点是最优选择</strong>。</p>
<p>此时，$c1=6.24，c2=8.91$。则该节点的表达式为</p>
<p>​                                                                                        <script type="math/tex">\begin{array}{c} T_{1}(x)=\left\{\begin{array}{ll} 6.24, & x<6.5 \\ 8.91, & x \geq 6.5 \end{array}\right. \\ f_{1}(x)=T_{1}(x) \end{array}</script></p>
<p>之后，在子集合中继续递归，直到最终将构建出该回归树模型。</p>
<p>​        至此，主要的决策树算法已经讲解的差不多了。为了进一步提高树模型的精度，将结合集成学习的思想。集成学习的两大思想分别为Boosting和Bagging，结合树模型，则分别对应着GBDT和Random Forest算法。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>经典算法</tag>
      </tags>
  </entry>
  <entry>
    <title>1.8tft彩屏测试代码（stm32f407ve）</title>
    <url>/link/8f66e916.html</url>
    <content><![CDATA[<h1 id="关于STM32f4与f1的代码（1-8寸SPI通信彩屏）差别的学习"><a href="#关于STM32f4与f1的代码（1-8寸SPI通信彩屏）差别的学习" class="headerlink" title="关于STM32f4与f1的代码（1.8寸SPI通信彩屏）差别的学习"></a>关于STM32f4与f1的代码（1.8寸SPI通信彩屏）差别的学习</h1><h1 id="前-言"><a href="#前-言" class="headerlink" title="前 言"></a>前 言</h1><p>前几天在某宝上买了一块stm32f407ve和一块1.8寸的彩屏，但彩屏的驱动程序给的是f103的驱动，修改过程中对于不同芯片之间的差异做出总结，欢迎大家指出错误。</p>
<h1 id="一、GPIO口的初始化"><a href="#一、GPIO口的初始化" class="headerlink" title="一、GPIO口的初始化"></a>一、GPIO口的初始化</h1><p>在stm32f103中GPIO口的初始化代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GPIO_InitTypeDef  GPIO_InitStructure;	      </span><br><span class="line">RCC_APB2PeriphClockCmd( RCC_APB2Periph_GPIOB ,ENABLE);</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0| GPIO_Pin_10| GPIO_Pin_1;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">GPIO_Init(GPIOB, &amp;GPIO_InitStructure);</span><br></pre></td></tr></table></figure>
<p>在stm32f407中GPIO口的初始化代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GPIO_InitTypeDef  GPIO_InitStructure;</span><br><span class="line">   RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB ,ENABLE);</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0| GPIO_Pin_10| GPIO_Pin_1;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;</span><br><span class="line">GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;</span><br><span class="line">GPIO_Init(GPIOB, &amp;GPIO_InitStructure);</span><br></pre></td></tr></table></figure>
<p>可以看到</p>
<ol>
<li>在初始化时钟时所调用函数以及代表io口的变量名称发生了变化。<br>RCC_APB2PeriphClockCmd    ——&gt;   RCC_AHB1PeriphClockCmd<br>RCC_APB2Periph_GPIOB   ——&gt;  RCC_AHB1Periph_GPIOB</li>
<li>在设置输出模式时，f407的PP和OD不再在GPIO_Mode中设置，而在GPIO_OType中设置， 输出模式的Out也变成了OUT。<br>GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;<br> ——&gt; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;<pre><code>   GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
</code></pre></li>
</ol>
<h1 id="二、BSRR寄存器表达方式"><a href="#二、BSRR寄存器表达方式" class="headerlink" title="二、BSRR寄存器表达方式"></a>二、BSRR寄存器表达方式</h1><p>在stm32f103中IO口高低电平控制代码<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//液晶管脚置1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LCD_LED_SET  	LCD_CTRLB-&gt;BSRR=LCD_LED   </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LCD_RS_SET  	LCD_CTRLB-&gt;BSRR=LCD_RS </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LCD_RST_SET  	LCD_CTRLB-&gt;BSRR=LCD_RST </span></span><br><span class="line"><span class="comment">//液晶管脚置0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LCD_LED_CLR  	LCD_CTRLB-&gt;BRR=LCD_LED </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LCD_RST_CLR  	LCD_CTRLB-&gt;BRR=LCD_RST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LCD_RS_CLR  	LCD_CTRLB-&gt;BRR=LCD_RS </span></span><br></pre></td></tr></table></figure><br>在stm32f407中IO口高低电平控制代码<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//液晶管脚置1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LCD_LED_SET  	LCD_CTRLB-&gt;BSRRL=LCD_LED   </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LCD_RS_SET  	LCD_CTRLB-&gt;BSRRL=LCD_RS </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LCD_RST_SET  	LCD_CTRLB-&gt;BSRRL=LCD_RST </span></span><br><span class="line"><span class="comment">//液晶管脚置0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LCD_LED_CLR  	LCD_CTRLB-&gt;BSRRH=LCD_LED </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LCD_RST_CLR  	LCD_CTRLB-&gt;BSRRH=LCD_RST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	LCD_RS_CLR  	LCD_CTRLB-&gt;BSRRH=LCD_RS </span></span><br></pre></td></tr></table></figure><br>对比可以看到BSRR变成了BSRRL，BRR变成了BSRRH，根本原因是在f407中只由BSRR寄存器就可以控制引脚的高低电平，去掉了BRR寄存器，在BSRR中高16位控制低电平，低16位控制高电平。</p>
<h1 id="总-结"><a href="#总-结" class="headerlink" title="总 结"></a>总 结</h1><p>因为同为stm32系列，只需要通过修改一点不同之处就能顺利运行，测试代码点击链接</p>
<blockquote>
<p>链接：<a href="https://pan.baidu.com/s/1JX360H5ETkCBeDzesjyJng">https://pan.baidu.com/s/1JX360H5ETkCBeDzesjyJng</a><br>提取码：uin6 </p>
</blockquote>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>stm32</tag>
      </tags>
  </entry>
  <entry>
    <title>RSNA乳腺癌分类总结</title>
    <url>/link/kaggle0228.html</url>
    <content><![CDATA[<h1 id="RSNA乳腺癌分类总结"><a href="#RSNA乳腺癌分类总结" class="headerlink" title="RSNA乳腺癌分类总结"></a><a href="https://www.kaggle.com/competitions/rsna-breast-cancer-detection/overview">RSNA乳腺癌分类总结</a></h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202302281412059.png" alt="image-20230228141232247"></p>
<p>​        第一次参加kaggle的比赛，比赛中学到了很多，kaggle的讨论区里有很多大佬交流想法，我几乎看了所有的帖子，对新手来说，很有意义。从2022/12/17开始发现了这个比赛，到2023/2/27结束，近三个月的时间，这是我参加的时间最长的比赛，从最开始的提交，到最后私榜银牌，因此，回忆从开始到结束的过程，记录一下比赛，也希望能有额外的收获。</p>
<p>​        在竞赛结束时，我的公榜成绩为190/1720，差一些才能拿到铜牌。</p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202302281414143.png" alt="image-20230228141452799"></p>
<p>​        但是当私榜放出时，居然到了51/1720，可能是运气，出乎了我的意料。</p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202302281414429.png" alt="image-20230228141408842"></p>
<p>​        下图是我记录了从开始到结束的105次提交的公榜(LB)和私榜(PL)分数，可以发现相关性也是比较高的。通过折线图也能发现分数的变化大概能分为几个阶段，接下来，将按阶段进行总结。</p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202302281411581.png" alt="sub"></p>
<h2 id="开始阶段"><a href="#开始阶段" class="headerlink" title="开始阶段"></a>开始阶段</h2><p>​        决定参加比赛后，首先查看了比赛的规则以及要求，其中重要的有指标，截止时间，以及代码要求，然后查看了数据集以及数据集的说明文档。</p>
<p>​        因为我参加时，比赛已经开始了半个月，讨论区已经有很多大佬进行过讨论，因此我去查看了所有的讨论内容，整理的其中的一些与赛题相关的内容。有之前RSNA比赛获胜者的笔记汇总，还有关于赛题的讨论，<strong>如何转换DICOM文件为PNG，额外可用的数据集，一些可用的backbone，可改进的一些方向</strong>，还有很多大佬做了<strong>EDA分析</strong>了数据集的构成，以及一些数据中不可用的空白图等。</p>
<ul>
<li>之前RSNA获奖者的笔记简单总结</li>
</ul>
<ol>
<li>公榜和私榜可能不成正相关</li>
<li>使用的网络大多为轻量化网络Efficientnet V2，Convnext nano/tiny，resnest50，seresnext50，inception_resnet_v2等</li>
<li>预处理不需要太复杂</li>
<li>当同时有文本数据和图片数据时，可以使用GRU网络连接两者</li>
</ol>
<ul>
<li>关于赛题的讨论</li>
</ul>
<ol>
<li>DICOM文件转PNG的方法</li>
<li>额外可用的数据集：INbreast，CMMD，CBIS-DDSM，VinDr-Mammo，KAUM</li>
<li>如何提取ROI区域，去除无用的黑色区域</li>
<li>一些放出的方案方法：多折交叉验证，efficientnet b3，input size 512/1024</li>
<li>可以改进的方向：更快的DICOM转PNG，损失函数的改进，对异常数据进行处理</li>
</ol>
<ul>
<li>关于数据集的讨论</li>
</ul>
<ol>
<li>一个病人单侧乳房的单个视图可能存在多张图片</li>
<li>一些图无法使用，822患者有空白图，27770患者全为灰图</li>
</ol>
<p>​        最后制定了一个短期计划：三天完成一次简单的提交，再过五天完成基本网络的训练，然后分析各个网络的优劣，对网络进行改进。</p>
<h2 id="网络训练"><a href="#网络训练" class="headerlink" title="网络训练"></a>网络训练</h2><p>​        确定了短期计划后，首先查看了Theo Viel大佬公开的代码，将代码copy一下后提交成功，然后分析代码结构，代码从开始的DICOM到PNG的转换，到后面的数据增强，模型训练，预测，以及提交，是一个很完整的流程，对我帮助很大，分析完代码结构后，将代码拆分为推理和训练两个部分，提交推理部分，没有报错，提交成功。训练时，使用大佬们转换好的PNG图片进行训练。这里我了解到了<strong>timm</strong>这个backbone的模型库，很好用，也便于替换。</p>
<p>​        通过查看别人的讨论以及源码，发现说到最多的损失函数是<strong>BCE loss和Focal loss</strong>，以及使用上下采样对数据进行<strong>样本平衡</strong>（sklearn做数据集划分很好用），于是将这些作为模块添加到代码中，方便调用。</p>
<p>​        事实证明，我还是太年轻了，三天完成一次简单的提交是个简单的任务，但是五天完成基本网络的训练，太难了，五天时间内，我只完成了单个网络的训练，但是网络测试集就是不收敛，这也是我第一次训练正负样本比例悬殊的数据集，并没有什么经验。当使用上下采样对数据进行均衡时，并没有得到好的效果，得分都在0.1以下。</p>
<p>​        后面经过了解，使用了<strong>warm up，最大梯度裁剪</strong>后使用预训练权重进行训练，模型开始收敛，开始使用的是二分类的模型，后面改成单分类模型+阈值处理后效果更好。在这个过程中也出现了忘记对模型输出进行softmax(二分类)，sigmoid(单分类)等问题。</p>
<p>​        训练代码没问题后，随之而来的是深度学习绕不开的设备差训练慢的问题，然后查找模型训练加速的方法，数据导入时，使用<strong>DataloaderX库或者data_prefectcher()函数</strong>进行导入，使用<strong>混合精度训练</strong>Nvidia_amp或者torch_amp，bitchsize太小时，使用<strong>梯度累加</strong>。</p>
<p>​        经过测试，发现DataloaderX库在numwork=0时加速效果更好，当numwork不为0时，DataloaderX库不能带来速度提升，但data_prefectcher()能够带来一点的速度提升。nVidia的amp配置较为复杂，采用torch自带的amp效果更好。当使用梯度累加和amp时，注意loss的反向传播和梯度的累加。</p>
<p>即使如此，512大小的图片在我3060显卡上依旧要跑10个小时。</p>
<h2 id="训练改进"><a href="#训练改进" class="headerlink" title="训练改进"></a>训练改进</h2><p>​        当训练代码能够正常运行时，查看大佬们的代码，查看可用的训练改进，总结有以下几种改进：</p>
<ul>
<li>更高的分辨率</li>
<li>多折交叉验证</li>
<li>opcv/yolo ROI提取</li>
<li>辅助分类训练</li>
<li>辅助loss训练</li>
</ul>
<p>​        前期使用的时seresenxt50进行训练，<strong>数据增强</strong>仅使用了简单的<strong>水平反转</strong>，5度内的<strong>小幅度旋转</strong>以及归一化处理，对于<strong>网络的drop rate设为0.3，drop path rate设为0.2</strong>，经过测试证明<strong>使用YOLO进行roi提取</strong>比使用opencv效果更好。使用辅助分类训练后，效果并没有变好，可能特征的引入方式有问题。</p>
<ul>
<li>在使用YOLO ROI提取后能够达到0.28的LB分数。</li>
<li>改变损失函数的权重，最终达到了0.36的LB分数，基本上都比CV分数高10个多点。</li>
<li>这段时间发现了使用平均在当地求最佳阈值时，顺序错误，修改后，模型表现有所改善。</li>
<li>制作了额外的公开数据集，对数据集进行处理，然后将模型在数据集上进行<strong>预训练</strong>后，LB分数达到0.39</li>
<li>在测试时使用<strong>镜像翻转测试</strong>两次取平均，LB分数到达0.4</li>
</ul>
<p>​        大佬们开源了更快的DICOM转PNG的方法，有了更多的时间用于网络的推理。顺便去了解了以下训练时可以使用的方法策略。</p>
<p>对于更快的网络训练和推理</p>
<ul>
<li>kornia库能够在gpu中进行数据增强加快模型训练推理速度 </li>
<li>pytorch lightning框架更好的进行训练速度优化    </li>
<li>tensorrt推理加速</li>
</ul>
<p>对于数据的优化</p>
<ul>
<li>使用deepsmote对数据进行处理</li>
</ul>
<p>对于超参数的优化</p>
<ul>
<li>使用ray库进行超参数搜索</li>
</ul>
<p>对于网络集成</p>
<ul>
<li>bagging和boosting训练方法</li>
<li>加权平均，blending等网络集成方法</li>
</ul>
<p>对于网络性能的提升</p>
<ul>
<li>SWA随机权重平均</li>
<li>tta测试时增强</li>
</ul>
<p>​        过年了，环境崩了，回学校用双2080ti跑。</p>
<h2 id="最终实验"><a href="#最终实验" class="headerlink" title="最终实验"></a>最终实验</h2><p>​        回到学校，发现两个新网络刷屏讨论区，一个是nextvit，号称最快的transformer，另一个是convnextv2，号称最强的CNN。我继续使用seresnext50，使用五折训练，LB分数0.43，扩大分辨率为(512,1024)，因为讨论区有大佬认为1:2的宽高比，是最佳的宽高比。使用五折训练，效果变差，后来发现是resize宽高搞错了，改正后，LB分数0.46。</p>
<p>​        <strong>注意：双卡跑保存模型权重时需保存的网络权重调用需要修改。</strong></p>
<p>​        后面使用convnext tiny，以及nextvit small，在(1024,512)尺寸上进行四折训练，得到的LB结果分别为0.44和0.46。convnext tiny继续加大分辨率到(1344,768)后只能使用3折进行训练，否则推理超时，得到的LB分数为0.5。nextvit small加大分辨率后损失下降有问题，训练transformer和CNN网络的超参数设置可能不同，时间接近deadline，不再尝试nextvit。即使在双2080ti上，跑三折依旧需要10小时以上。</p>
<p>​        对convnext使用直方图均衡化后，效果没有提升。这时才想起seresenxt50，在(1344,768)依旧能使用五折进行推理，重新训练后，LB达到0.52，微调阈值后，LB达到0.53，也就是最后的提交值。</p>
<p>​        这之后调整pos weight以及上采样率进行尝试，LB分数下降，但PL分数上看，是有效果的。</p>
<h2 id="未尝试的加强"><a href="#未尝试的加强" class="headerlink" title="未尝试的加强"></a>未尝试的加强</h2><ul>
<li>使用更大分辨率的输入，并使用tensorrt进行推理</li>
<li>多视图训练</li>
<li>数据集的优化，因为癌症的标注为乳房级的，而不是图片级的</li>
<li>超参数搜索，这个真的需要有资源和时间</li>
<li>SWA，据说可以无痛提点</li>
<li>背景拒绝，使用小模型先检测，将确信度低的交给大模型检测，增快检测速度。</li>
<li>多模型融合</li>
</ul>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>​        对于我来说，是一个很棒的经历，接下来大佬们会放出优胜方案，之后继续更新。</p>
]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>kaggle比赛</tag>
      </tags>
  </entry>
  <entry>
    <title>Python命令行小游戏—贪吃蛇</title>
    <url>/link/578dccdc.html</url>
    <content><![CDATA[<h1 id="Python命令行小游戏—贪吃蛇"><a href="#Python命令行小游戏—贪吃蛇" class="headerlink" title="Python命令行小游戏—贪吃蛇"></a>Python命令行小游戏—贪吃蛇</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为了初步学习Python更有兴趣，决定做个学编程大多都会做的小游戏—贪吃蛇，因为是刚刚开始学习，不足之处，希望大家多多指正。</p>
<h1 id="一、贪吃蛇游戏初始界面及地图"><a href="#一、贪吃蛇游戏初始界面及地图" class="headerlink" title="一、贪吃蛇游戏初始界面及地图"></a>一、贪吃蛇游戏初始界面及地图</h1><h2 id="1-游戏初始界面"><a href="#1-游戏初始界面" class="headerlink" title="1.游戏初始界面"></a>1.游戏初始界面</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mune</span>():</span><br><span class="line">    os.system(<span class="string">&quot;color 0a&quot;</span>)</span><br><span class="line">    dll.set_cmd(<span class="number">0</span>, <span class="number">2</span>);<span class="built_in">print</span>(<span class="string">&quot;□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□&quot;</span>)</span><br><span class="line">    dll.set_cmd(<span class="number">0</span>, <span class="number">3</span>);<span class="built_in">print</span>(<span class="string">&quot;□□□□□■■■■□□□□□□□贪吃蛇□□□□□□□□□■□□□    操作指南    □□□□&quot;</span>)<span class="comment">#7</span></span><br><span class="line">    dll.set_cmd(<span class="number">0</span>, <span class="number">4</span>);<span class="built_in">print</span>(<span class="string">&quot;□□□□■■□□■■□□□□□□□□□□□□□□□□□□■□□□方向键  改变方向□□□□&quot;</span>)<span class="comment">#5</span></span><br><span class="line">    dll.set_cmd(<span class="number">0</span>, <span class="number">5</span>);<span class="built_in">print</span>(<span class="string">&quot;□□□■■□□□□□□□□□□2021.05.06□□□□□□□□■□□□ESC     退出游戏□□□□□□&quot;</span>)</span><br><span class="line">    dll.set_cmd(<span class="number">0</span>, <span class="number">6</span>);<span class="built_in">print</span>(<span class="string">&quot;□□□□■■□□□□□□□□□□□□□□□□□□□□□□■□□□SPACE   暂停游戏□□□□□□□□□&quot;</span>)</span><br><span class="line">    dll.set_cmd(<span class="number">0</span>, <span class="number">7</span>);<span class="built_in">print</span>(<span class="string">&quot;□□□□□■■■■□□□□■■■■□□□□■■■□□□□■□□■■□□□□■■■■■□□&quot;</span>)</span><br><span class="line">    dll.set_cmd(<span class="number">0</span>, <span class="number">8</span>);<span class="built_in">print</span>(<span class="string">&quot;□■□□□□□■■■□□■□□□□■□□■□□□■□□□■■□□□□□□■□□□□□■□&quot;</span>)</span><br><span class="line">    dll.set_cmd(<span class="number">0</span>, <span class="number">9</span>);<span class="built_in">print</span>(<span class="string">&quot;□□■□□□□□■■■□■□□□□■□■□□□□■□□□■■□□□□□■□□■■■■□□&quot;</span>)</span><br><span class="line">    dll.set_cmd(<span class="number">0</span>,<span class="number">10</span>);<span class="built_in">print</span>(<span class="string">&quot;□□□■■□□■■■□□■□□□□■□□■□□■□■□□■□■□□□□□■□□□□□□□&quot;</span>)</span><br><span class="line">    dll.set_cmd(<span class="number">0</span>,<span class="number">11</span>);<span class="built_in">print</span>(<span class="string">&quot;□□□□■■■■□□□□■□□□□■□□□■■□□■■□■□□■■■□□□■■■■■□□&quot;</span>)<span class="comment">#24</span></span><br><span class="line">    dll.set_cmd(<span class="number">0</span>,<span class="number">12</span>);<span class="built_in">print</span>(<span class="string">&quot;□□□□□□□□□□□□□□□□□□按空格开始游戏□□□□□□□□□□□□□□□□□□□&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>这里使用了<strong>os库</strong>和<strong>ctypes库</strong>以及调用的.dll自建动态库，第二节会详细说明</p>
<h2 id="2-游戏地图"><a href="#2-游戏地图" class="headerlink" title="2.游戏地图"></a>2.游戏地图</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">wall</span>(<span class="params">x,y</span>):<span class="comment">#绘制围墙</span></span><br><span class="line">    i=<span class="number">0</span>;j=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i&lt;=x:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;■&#x27;</span>,end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(y):</span><br><span class="line">            <span class="keyword">if</span> i==<span class="number">0</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;■&#x27;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">            <span class="keyword">elif</span> i==<span class="number">20</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;■&#x27;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;  &quot;</span>,end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">            j+=<span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;■&#x27;</span>)</span><br><span class="line">        i+=<span class="number">1</span></span><br><span class="line">        j=<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>简单的使用Python的输出函数print（）做一个围墙，默认情况下函数内的   <strong>end=“/n”</strong></p>
<h1 id="二、命令符的设置、输出刷新和按键检测"><a href="#二、命令符的设置、输出刷新和按键检测" class="headerlink" title="二、命令符的设置、输出刷新和按键检测"></a>二、命令符的设置、输出刷新和按键检测</h1><h2 id="1-库支持"><a href="#1-库支持" class="headerlink" title="1.库支持"></a>1.库支持</h2><ul>
<li>os库中的<strong>os.system(“命令行指令”)</strong> 函数可执行命令行中的指令，具体指令可在命令行中输入help回车获得相关信息</li>
<li>c语言能够更好的对命令行的输出进行刷新，这里通过调用.dll的方式调用c语言，具体的使用可观看此视频<a href="https://www.bilibili.com/video/BV1kJ411a7AD/?spm_id_from=333.788.recommend_more_video.1">python和C语言混合编程</a><h2 id="2-c语言代码"><a href="#2-c语言代码" class="headerlink" title="2.c语言代码"></a>2.c语言代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;conio.h&gt;</span></span></span><br><span class="line"><span class="comment">//命令行光标显示（1）隐藏（0）</span></span><br><span class="line">_declspec(dllexport) <span class="type">void</span> _stdcall <span class="title function_">init_cmd</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">	HANDLE handle = GetStdHandle(STD_OUTPUT_HANDLE);</span><br><span class="line">	CONSOLE_CURSOR_INFO CursorInfo;</span><br><span class="line">	GetConsoleCursorInfo(handle, &amp;CursorInfo);<span class="comment">//获取控制台光标信息</span></span><br><span class="line">	CursorInfo.bVisible = x; <span class="comment">//控制台光标状态，x=1显示，x=0隐藏</span></span><br><span class="line">	SetConsoleCursorInfo(handle, &amp;CursorInfo);<span class="comment">//设置控制台光标状态</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//命令行光标移动函数</span></span><br><span class="line">_declspec(dllexport) <span class="type">void</span> _stdcall <span class="title function_">set_cmd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">	COORD pos;</span><br><span class="line">	pos.X = x;</span><br><span class="line">	pos.Y = y;</span><br><span class="line">	SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), pos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取键盘输入</span></span><br><span class="line">_declspec(dllexport) <span class="type">int</span> _stdcall <span class="title function_">c_getch</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line">	<span class="keyword">if</span> (_kbhit()) &#123;<span class="comment">//_kbhit()为按键检测，有按键输出1，没有输出0</span></span><br><span class="line">	key = _getch();</span><br><span class="line">	Sleep(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">return</span> key;</span><br><span class="line">      &#125;</span><br><span class="line">	<span class="keyword">else</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="3-Python代码（变量初始化及游戏初始化）"><a href="#3-Python代码（变量初始化及游戏初始化）" class="headerlink" title="3.Python代码（变量初始化及游戏初始化）"></a>3.Python代码（变量初始化及游戏初始化）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os,time,ctypes,random</span><br><span class="line"></span><br><span class="line">wall_x,wall_y ,eat_flag= <span class="number">20</span>,<span class="number">21</span>,<span class="number">1</span></span><br><span class="line">move_up,move_down,move_left,move_right,esc,space = <span class="number">72</span>,<span class="number">80</span>,<span class="number">75</span>,<span class="number">77</span>,<span class="number">27</span>,<span class="number">32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_game</span>():<span class="comment">#游戏界面初始化</span></span><br><span class="line">    <span class="keyword">global</span> getkey, key, snake_x, snake_y, snake_list<span class="comment">#全局变量声明</span></span><br><span class="line">    os.system(<span class="string">&quot;mode con cols=48 lines=22&quot;</span>)  <span class="comment"># 设置命令符窗口大小</span></span><br><span class="line">    os.system(<span class="string">&quot;cls&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;color 2b&quot;</span>)  <span class="comment"># 设置字体和背景颜色</span></span><br><span class="line">    wall(wall_x, wall_y)  <span class="comment"># 绘制围墙</span></span><br><span class="line">    dll.set_cmd(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;■□□□□○&quot;</span>)</span><br><span class="line">    snake_list = [[<span class="number">2</span>, <span class="number">1</span>], [<span class="number">4</span>, <span class="number">1</span>], [<span class="number">6</span>, <span class="number">1</span>], [<span class="number">8</span>, <span class="number">1</span>], [<span class="number">10</span>, <span class="number">1</span>]]</span><br><span class="line">    snake_x, snake_y ,getkey,key= <span class="number">10</span>, <span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init</span>():<span class="comment">#命令符及游戏初始化</span></span><br><span class="line">    ctypes.windll.kernel32.SetConsoleTitleW(<span class="string">&quot;贪吃蛇&quot;</span>)  <span class="comment"># 修改命令符标题</span></span><br><span class="line">    os.system(<span class="string">&quot;mode con cols=88 lines=15&quot;</span>)  <span class="comment"># 设置命令符窗口大小</span></span><br><span class="line">    dll.init_cmd(<span class="number">0</span>)  <span class="comment"># 设置光标状态</span></span><br></pre></td></tr></table></figure>
<p><font color=#999AAA >当定义函数内有全局变量的值发生变化时，需要进行全局变量声明</p>
<h1 id="三、蛇的移动"><a href="#三、蛇的移动" class="headerlink" title="三、蛇的移动"></a>三、蛇的移动</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">snake_move</span>(<span class="params">*lis</span>):<span class="comment">#蛇移动</span></span><br><span class="line">    dll.set_cmd(snake_list[<span class="number">0</span>][<span class="number">0</span>], snake_list[<span class="number">0</span>][<span class="number">1</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;  &quot;</span>)</span><br><span class="line">    snake_list.append(lis[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">if</span> eat_flag==<span class="number">0</span>:</span><br><span class="line">        snake_list.pop(<span class="number">0</span>)</span><br><span class="line">    dll.set_cmd(snake_list[-<span class="number">1</span>][<span class="number">0</span>], snake_list[-<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;○&quot;</span>)</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(snake_list)-<span class="number">2</span>):</span><br><span class="line">        dll.set_cmd(snake_list[-<span class="number">2</span>-n][<span class="number">0</span>], snake_list[-<span class="number">2</span>-n][<span class="number">1</span>])</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;□&quot;</span>)</span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">move</span>():<span class="comment">#蛇移动防倒走</span></span><br><span class="line">    <span class="keyword">global</span> snake_x, snake_y</span><br><span class="line">    <span class="keyword">if</span> [snake_x, snake_y] <span class="keyword">in</span> snake_list[-<span class="number">2</span>:]:</span><br><span class="line">        snake_x = snake_list[-<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">        snake_y = snake_list[-<span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        snake_move([snake_x, snake_y])</span><br></pre></td></tr></table></figure>
<ul>
<li>蛇的身体的每个小块对应列表内的一个坐标，<strong>头的位置处于列表最后一项</strong>。</li>
<li>当移动时消除第一个坐标所在的位置，使用<strong>pop(0)方法</strong>弹出第一项</li>
<li>将下一个头的位置（由 <em>snake_ctrl</em> 函数提供）使用<strong>append（）方法</strong>添加到列表最后</li>
<li>通过检测位置坐标（<strong>x  in  y</strong>）是否为靠近头的一段来防止蛇倒走。<h1 id="四、蛇的方向控制"><a href="#四、蛇的方向控制" class="headerlink" title="四、蛇的方向控制"></a>四、蛇的方向控制</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_key</span>():<span class="comment">#获得键盘输入</span></span><br><span class="line">    <span class="keyword">global</span> getkey,key</span><br><span class="line">    a = dll.c_getch()</span><br><span class="line">    <span class="keyword">if</span> a <span class="keyword">in</span> [esc,space]:</span><br><span class="line">        getkey = a</span><br><span class="line">    <span class="keyword">if</span> a <span class="keyword">in</span> [move_up,move_down,move_left,move_right]:</span><br><span class="line">        <span class="keyword">if</span> ((key == move_up) <span class="keyword">and</span> (a != move_down))<span class="keyword">or</span> ((key == move_down) <span class="keyword">and</span> (a != move_up)) \</span><br><span class="line">            <span class="keyword">or</span>(key == <span class="number">0</span>) <span class="keyword">or</span>((key == move_left) <span class="keyword">and</span> (a != move_right)) \</span><br><span class="line">                <span class="keyword">or</span> ((key == move_right) <span class="keyword">and</span> (a != move_left)):</span><br><span class="line">            key = a</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">snake_ctrl</span>():<span class="comment">#根据键盘输入判断方向已经功能操作</span></span><br><span class="line">    <span class="keyword">global</span> getkey, key, snake_x, snake_y</span><br><span class="line">    <span class="keyword">if</span> key == move_down:</span><br><span class="line">        snake_y += <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> key == move_up:</span><br><span class="line">        snake_y -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> key == move_right:</span><br><span class="line">        snake_x += <span class="number">2</span></span><br><span class="line">    <span class="keyword">elif</span> key == move_left:</span><br><span class="line">        snake_x -= <span class="number">2</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">if</span> getkey == space:</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        getkey = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            getkey = dll.c_getch()</span><br><span class="line">            <span class="keyword">if</span> getkey == space:</span><br><span class="line">                getkey = <span class="number">0</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> getkey == esc:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<font color=#999AAA >检测按键输入 <em>get_key()</em> 以及设置相应按键实现的功能 <em>snake_ctrl()</em>  <h1 id="五、食物的设置"><a href="#五、食物的设置" class="headerlink" title="五、食物的设置"></a>五、食物的设置</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">putfood</span>():<span class="comment">#放置食物</span></span><br><span class="line">    <span class="keyword">global</span> food_x,food_y,eat_flag</span><br><span class="line">    <span class="keyword">if</span> eat_flag==<span class="number">1</span>:</span><br><span class="line">        food_x = snake_x</span><br><span class="line">        food_y = snake_y</span><br><span class="line">        <span class="keyword">while</span> [food_x,food_y] <span class="keyword">in</span> snake_list:</span><br><span class="line">            food_x = random.randint(<span class="number">1</span>, <span class="number">20</span>) * <span class="number">2</span></span><br><span class="line">            food_y = random.randint(<span class="number">1</span>, <span class="number">19</span>)</span><br><span class="line">        eat_flag = <span class="number">0</span></span><br><span class="line">        dll.set_cmd(food_x,food_y)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;●&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span> :</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">eatfood</span>():<span class="comment">#吃掉食物判断</span></span><br><span class="line">    <span class="keyword">global</span> eat_flag,snake_list,snake_x, snake_y</span><br><span class="line">    <span class="keyword">if</span> ([food_x,food_y] <span class="keyword">in</span> snake_list)<span class="keyword">and</span>(eat_flag==<span class="number">0</span>) :</span><br><span class="line">        eat_flag = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<font color=#999AAA >不得不说Python中成员判断真的很好用。</li>
<li>通过食物坐标点点是否已经包含到蛇身体的列表中来判断是否吃到食物</li>
<li><strong>食物的产生</strong>通过随机函数（<em>random.randint（x，y）</em>）来提供坐标</li>
<li>是否<strong>放置食物</strong>由是否吃掉的标志（<em>eat_flag</em>）来判断<h1 id="六、游戏结束"><a href="#六、游戏结束" class="headerlink" title="六、游戏结束"></a>六、游戏结束</h1></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gameover</span>():<span class="comment">#游戏结束判断</span></span><br><span class="line">    <span class="keyword">if</span> (snake_x&gt;<span class="number">42</span>)|(snake_y&gt;<span class="number">19</span>)\</span><br><span class="line">        |(snake_x&lt;<span class="number">2</span>)|(snake_y==<span class="number">0</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> snake_list.count(snake_list[-<span class="number">1</span>])&gt;<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> :</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">over_next</span>():<span class="comment">#结束后的操作</span></span><br><span class="line">    <span class="keyword">global</span> getkey,eat_flag</span><br><span class="line">    <span class="keyword">if</span> gameover():</span><br><span class="line">        dll.set_cmd(<span class="number">16</span>, <span class="number">9</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;得分：&#123;&#125;分&quot;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(snake_list)-<span class="number">5</span>))</span><br><span class="line">        dll.set_cmd(<span class="number">6</span>, <span class="number">10</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;游戏结束，esc退出，space重新开始&quot;</span>)</span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            getkey = dll.c_getch()</span><br><span class="line">            <span class="keyword">if</span> getkey == esc:</span><br><span class="line">                os.system(<span class="string">&quot;cls&quot;</span>)</span><br><span class="line">                dll.init_cmd(<span class="number">1</span>)</span><br><span class="line">                os.system(<span class="string">&quot;exit&quot;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> getkey == space:</span><br><span class="line">                init_game()</span><br><span class="line">                eat_flag = <span class="number">1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<ul>
<li>贪吃蛇撞墙的判断就简单粗暴的坐标判断，如果地图复杂可能需要使用列表将每部分墙体的起始坐标录入进行判断，贪吃蛇只需要判断头的位置就能够判断是否撞到了墙。</li>
<li>使用<strong>列表的<em>count</em>方法</strong>能够很简单的判断序列中有没有两相同的元素，来检测蛇有没有吃到自己。<h1 id="七、主程序"><a href="#七、主程序" class="headerlink" title="七、主程序"></a>七、主程序</h1></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:<span class="comment">#主函数main</span></span><br><span class="line">  dll = ctypes.windll.LoadLibrary(<span class="string">&quot;set_cmd.dll&quot;</span>)  <span class="comment"># 调用c语言程序</span></span><br><span class="line">  init()</span><br><span class="line">  mune()</span><br><span class="line">  <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">      getkey = dll.c_getch()</span><br><span class="line">      <span class="keyword">if</span> getkey == space:</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">          <span class="keyword">pass</span></span><br><span class="line">  init_game()</span><br><span class="line">  <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">      get_key()</span><br><span class="line">      putfood()</span><br><span class="line">      eatfood()</span><br><span class="line">      snake_ctrl()</span><br><span class="line">      move()</span><br><span class="line">      over_next()</span><br><span class="line">      <span class="keyword">if</span> getkey == esc:</span><br><span class="line">          os.system(<span class="string">&quot;cls&quot;</span>)</span><br><span class="line">          dll.init_cmd(<span class="number">1</span>)</span><br><span class="line">          os.system(<span class="string">&quot;exit&quot;</span>)</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">          <span class="keyword">pass</span></span><br><span class="line">      get_key()</span><br><span class="line">      time.sleep(<span class="number">0.15</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>通过两次按键 <em>get_key()</em> 检测来减少按键的检测缺失</li>
<li>可以通过调整循环等待时间 <em>time.sleep(0.15)</em> 来调整游戏内蛇的速度</li>
</ul>
<h1 id="八、演示效果"><a href="#八、演示效果" class="headerlink" title="八、演示效果"></a>八、演示效果</h1><p><font color=#999AAA >生成.exe文件需要用到pyinstaller，没有的话需要进行以下步骤</p>
<ol>
<li>运行命令符输入 <strong><em>pip install pyinstaller</em></strong></li>
<li>等待安装完成，输入 <strong><em>pyinstaller -F xxx.py</em></strong> (文件位置)</li>
</ol>
<p><font color=#999AAA ><strong>以下是演示效果</strong><br><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202302281929350.png" alt="初始界面"><br><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202302281929292.png" alt="在这里插入图片描述"></p>
<p><font color=#999AAA ><del>评价：能玩</del> </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><font color=#999AAA >虽然最后成品比较简陋，但还是有些成就感的，比之前光看书感觉效率提高很多。<br>下面是所有文件的网盘链接<a href="https://pan.baidu.com/s/1ZA6F3FpzL-WBmw4tH2bsrg">点击下载</a><br>提取码：6v5o</p>
<p>&lt;hr style=” border:solid; width:100px; height:1px;” color=#000000 size=1”&gt;</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title>docker安装</title>
    <url>/link/docker0228.html</url>
    <content><![CDATA[<h1 id="docker安装-ubuntu20-04"><a href="#docker安装-ubuntu20-04" class="headerlink" title="docker安装(ubuntu20.04)"></a>docker安装<code>(ubuntu20.04)</code></h1><h2 id="1-安装docker"><a href="#1-安装docker" class="headerlink" title="1.安装docker"></a>1.安装docker</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">替换国内源</span></span><br><span class="line">apt-get install vim  # 安装vim编辑器</span><br><span class="line">vim /etc/apt/sources.list  # 编辑源文件</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删掉内容，换成以下的国内源</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">添加阿里源</span></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">添加清华源</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse multiverse</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">:wq 保存退出</span></span><br><span class="line"></span><br><span class="line">apt-get update  # 更新源</span><br><span class="line">apt-get install curl  # 安装curl</span><br><span class="line">sudo update-ca-certificates </span><br><span class="line">curl -sSL https://get.daocloud.io/docker | sh  # 国内daocloud一键安装docker</span><br><span class="line">vim  /etc/docker/daemon.json  # 新建或编辑文件，docker镜像加速</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加以下内容</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [</span><br><span class="line">    &quot;https://hub-mirror.c.163.com&quot;,</span><br><span class="line">    &quot;https://ustc-edu-cn.mirror.aliyuncs.com&quot;,</span><br><span class="line">    &quot;https://ghcr.io&quot;,</span><br><span class="line">    &quot;https://mirror.baidubce.com&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">:wq 保存退出</span></span><br><span class="line"></span><br><span class="line">systemctl restart docker.service  # 重启docker服务</span><br><span class="line">docker info  # 查看Registry Mirrors:的信息是否修改成功</span><br><span class="line">docker run hello-world  # 打印信息查看是否安装成功</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ps:有报错缺少命令，安装缺少命令后运行</span></span><br></pre></td></tr></table></figure>
<h2 id="2-安装显卡驱动以及cuda11-1"><a href="#2-安装显卡驱动以及cuda11-1" class="headerlink" title="2.安装显卡驱动以及cuda11.1"></a>2.安装显卡驱动以及cuda11.1</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">卸载旧的显卡驱动和cuda</span></span><br><span class="line">apt-get autoremove --purge nvidia*</span><br><span class="line">apt-get autoremove --purge cuda*</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看显卡信息，第一行会有NVIDIA Corporation Device</span></span><br><span class="line">lspci -k | grep -A 2 -i &quot;VGA&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加nvidia显卡驱动ppa源</span></span><br><span class="line">add-apt-repository ppa:graphics-drivers/ppa</span><br><span class="line">apt-get update </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行推荐显卡驱动设置</span></span><br><span class="line">ubuntu-drivers devices</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载推荐的版本</span></span><br><span class="line">apt-get install nvidia-***（recommended版本）</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">等待安装，显卡驱动安装完成</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">百度网盘链接: https://pan.baidu.com/s/14G49Btc13pSlPSUJxtfSdA 提取码: jbsl</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">cuda官网：https://developer.nvidia.com/cuda-toolkit-archive可下载其他版本</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">cudnn官网：https://developer.nvidia.com/rdp/cudnn-download可下载其他版本</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">百度网盘下载cuda11.1安装所需文件</span></span><br><span class="line">sh cuda_11.1.1_455.32.00_linux.run  # 安装cuda</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装过程中会首先会遇到提示显卡驱动已经安装，这时候选择<span class="built_in">continue</span>继续</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出accept继续</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新界面出现需要安装的内容，回车取消显卡驱动安装，选择install完成安装</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置环境变量</span></span><br><span class="line">vim ~/.bashrc  # 打开文件</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在末尾添加以下内容</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CUDA Soft Link</span></span><br><span class="line">export PATH=/usr/local/cuda-11.1/bin$&#123;PATH:+:$&#123;PATH&#125;&#125;</span><br><span class="line">export LD_LIBRARY_PATH=/usr/local/cuda-11.1/lib64$&#123;LD_LIBRARY_PATH:+:$&#123;LD_LIBRARY_PATH&#125;&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">:wq 添加完成</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">测试cuda是否安装成功</span></span><br><span class="line">nvcc -V  # 输出cuda版本信息，安装成功</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压cudnn-11.3-linux-x64-v8.2.1.32.tgz，并进入解压后的文件夹</span></span><br><span class="line">cp cuda/include/cudnn.h /usr/local/cuda/include</span><br><span class="line">cp cuda/lib64/libcudnn* /usr/local/cuda/lib64</span><br><span class="line">sudo chmod a+r /usr/local/cuda/include/cudnn.h /usr/local/cuda/lib64/libcudnn* </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装剩余的三个deb包</span></span><br><span class="line">dpkg -i libcudnn8_8.2.1.32-1+cuda11.3_amd64.deb</span><br><span class="line">dpkg -i libcudnn8-dev_8.2.1.32-1+cuda11.3_amd64.deb</span><br><span class="line">dpkg -i libcudnn8-samples_8.2.1.32-1+cuda11.3_amd64.deb</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启，测试是否安装成功</span></span><br><span class="line">cp -r /usr/src/cudnn_samples_v8/ ~</span><br><span class="line">cd ~/cudnn_samples_v8/mnistCUDNN/</span><br><span class="line">apt-get install libfreeimage3 libfreeimage-dev</span><br><span class="line">make clean &amp;&amp; make</span><br><span class="line">./mnistCUDNN </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示Test passed！安装成功</span></span><br></pre></td></tr></table></figure>
<h2 id="3-nvidia-docker安装"><a href="#3-nvidia-docker安装" class="headerlink" title="3.nvidia docker安装"></a>3.nvidia docker安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置stable存储库和密钥</span></span><br><span class="line">distribution=$(. /etc/os-release;echo $ID$VERSION_ID) \</span><br><span class="line">   &amp;&amp; curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | sudo apt-key add - \</span><br><span class="line">   &amp;&amp; curl -s -L https://nvidia.github.io/nvidia-docker/$distribution/nvidia-docker.list | sudo tee /etc/apt/sources.list.d/nvidia-docker.list</span><br><span class="line">   </span><br><span class="line">curl -s -L https://nvidia.github.io/nvidia-container-runtime/experimental/$distribution/nvidia-container-runtime.list | sudo tee /etc/apt/sources.list.d/nvidia-container-runtime.list</span><br><span class="line"></span><br><span class="line">apt-get update</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装nvidia-docker2安装包</span></span><br><span class="line">apt-get install -y nvidia-docker2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启docker</span></span><br><span class="line">systemctl restart docker</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">测试安装是否成功</span></span><br><span class="line">docker run --rm --gpus all nvidia/cuda:11.0-base nvidia-smi</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出显卡信息即安装成功</span></span><br></pre></td></tr></table></figure>
<h2 id="4-安装PyTorch-gpu-jupyter"><a href="#4-安装PyTorch-gpu-jupyter" class="headerlink" title="4.安装PyTorch_gpu+ jupyter"></a>4.安装PyTorch_gpu+ jupyter</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拉取一个要使用的镜像</span></span><br><span class="line">docker pull anibali/pytorch:1.7.0-cuda11.0  # 版本自己确定</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建容器，自己选择映射端口，1778可改为其他端口</span></span><br><span class="line">docker run -it --init   --gpus=all   --ipc=host  --name pytorch -p 1778:8888  --volume=&quot;$PWD:/app&quot;   anibali/pytorch python3</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看容器ID</span></span><br><span class="line">docker ps -a</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启容器</span></span><br><span class="line">docder start 容器ID</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以交互式进入容器</span></span><br><span class="line">docker exec -it 容器ID /bin/bash</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装jupyterlab</span></span><br><span class="line">conda install -c conda-forge jupyterlab</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动jupyterlab后远程浏览器登陆</span></span><br><span class="line">jupyter lab --ip=0.0.0.0 --no-browser --allow-root</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在浏览器打开给定的链接，端口8888改为设定的映射端口，即可登录jupyter</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>stm32f4串口烧录[flymcu]</title>
    <url>/link/a7ff1534.html</url>
    <content><![CDATA[<h1 id="stm32f4串口烧录-flymcu"><a href="#stm32f4串口烧录-flymcu" class="headerlink" title="stm32f4串口烧录[flymcu]"></a>stm32f4串口烧录[flymcu]</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  一段时间没有使用stm32,串口烧录方式有些遗忘,为了日后更快的上手,故记在此处。&lt;/font&gt;</p>
<h1 id="一、串口烧录软件的选择"><a href="#一、串口烧录软件的选择" class="headerlink" title="一、串口烧录软件的选择"></a>一、串口烧录软件的选择</h1><p>  目前能够找到的主要有三种烧录软件,flymcu，mcuisp,Flash Loader Demonstrator。<br>  经过实际的使用发现mcuisp会出现芯片保护无法读取的情况，Flash Loader Demonstrator操作较为复杂需要经常复位，所以<strong>最终选择的是flymcu</strong>。</p>
<h1 id="二、使用步骤"><a href="#二、使用步骤" class="headerlink" title="二、使用步骤"></a>二、使用步骤</h1><h2 id="1-软硬件准备"><a href="#1-软硬件准备" class="headerlink" title="1.软硬件准备"></a>1.软硬件准备</h2><p>  在烧录前，在软件上需要下载安装好==flymcu软件==，==串口驱动==（都可以轻松搜到）；在硬件上需要一个==usb转串口==以及==stm32的实验板==。（以下为连线顺序）<br> usb转串口———————————————stm32<br> tx—————————————————————rx<br>rx—————————————————————tx<br>vcc—————————————————————vcc<br>gnd—————————————————————gnd<br>stm32上的==boot0引脚接vcc，boot1引脚接gnd进入烧录模式==<br>boot0引脚接gnd，boot1引脚接gnd为正常启动模式</p>
<h2 id="2-烧录"><a href="#2-烧录" class="headerlink" title="2.烧录"></a>2.烧录</h2><p>  烧录时软件图如下图所示</p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202302281933592.png" alt="在这里插入图片描述"></p>
<p>1.首先搜索当前所用的串口usb ch340，如果搜查不到，重新插拔usb后再次尝试，如果依旧找不到，检查是否安装驱。<br>2.然后在下方设置时（图中左下角红圈位置）==设置好进入bootloader的方式==能够在烧录时一键烧录。<br>3.最后等待烧录完成，在右方会显示烧录结果。<br>4.修改stm32的boot0引脚为低电平，按下复位键，查看程序是否满足要求</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>设置之后能够使得串口烧录更加简单，烧录的时候也可通过设定选项字节来设置烧录完成的程序能否在片上读出。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>stm32</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Pytorch使用FFT,矩阵乘法,Conv2d计算卷积</title>
    <url>/link/e57798f6.html</url>
    <content><![CDATA[<h1 id="基于Pytorch使用FFT-矩阵乘法-Conv2d计算卷积"><a href="#基于Pytorch使用FFT-矩阵乘法-Conv2d计算卷积" class="headerlink" title="基于Pytorch使用FFT,矩阵乘法,Conv2d计算卷积"></a>基于Pytorch使用FFT,矩阵乘法,Conv2d计算卷积</h1><p><strong>目标：计算64*64矩阵X和3*3矩阵H的卷积Y=X*H</strong></p>
<h2 id="第一节：导入库"><a href="#第一节：导入库" class="headerlink" title="第一节：导入库"></a><strong>第一节：导入库</strong></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入所需模块</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">from</span> timeit <span class="keyword">import</span> Timer</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个四维随机张量，样本数为1，通道数为1，大小为64*64为图像</span></span><br><span class="line">x_n = torch.tensor(torch.randint(<span class="number">0</span>,<span class="number">128</span>,[<span class="number">1</span>,<span class="number">1</span>,<span class="number">64</span>,<span class="number">64</span>]),dtype=torch.float32) </span><br><span class="line"><span class="comment"># 创建一个四维随机张量，样本数为1，通道数为1，大小为3*3为卷积核</span></span><br><span class="line">h_n = torch.randn(<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>)  </span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; &lt;ipython-input-1-d7583688b6eb&gt;:6: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires_grad_(True), rather than torch.tensor(sourceTensor).</span><br><span class="line">      x_n = torch.tensor(torch.randint(0,128,[1,1,64,64]),dtype=torch.float32) # 创建一个四维随机张量，样本数为1，通道数为1，大小为64*64为图像</span><br></pre></td></tr></table></figure>
<h2 id="第二节：定义函数"><a href="#第二节：定义函数" class="headerlink" title="第二节：定义函数"></a>第二节：定义函数</h2><h3 id="2-1-使用fft计算卷积"><a href="#2-1-使用fft计算卷积" class="headerlink" title="2.1 使用fft计算卷积"></a><strong>2.1 使用fft计算卷积</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fft_test</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;用fft计算卷积&quot;&quot;&quot;</span></span><br><span class="line">    x_n_fft = torch.fft.fft2(x_n[<span class="number">0</span>,<span class="number">0</span>])  <span class="comment">#　对图像x_n进行fft  </span></span><br><span class="line">    h_trans = torch.flip(h_n[<span class="number">0</span>,<span class="number">0</span>], [<span class="number">1</span>])  <span class="comment"># 对卷积核h_n进行左右翻转</span></span><br><span class="line">    h_trans = torch.flipud(h_trans)  <span class="comment"># 对卷积核h_n进行上下翻转</span></span><br><span class="line">    pad = nn.ZeroPad2d(padding=(<span class="number">0</span>, <span class="number">61</span>, <span class="number">0</span>, <span class="number">61</span>))  <span class="comment"># 设置拓展矩阵填充0的维度(左，右，上，下)</span></span><br><span class="line">    h_n_pad = pad(h_trans)  <span class="comment"># 进行矩阵拓展为64*64</span></span><br><span class="line">    h_n_fft = torch.fft.fft2(h_n_pad)  <span class="comment"># 对拓展后的卷积核做fft</span></span><br><span class="line">    res = x_n_fft.mul(h_n_fft)  <span class="comment"># 两个矩阵点乘</span></span><br><span class="line">    <span class="comment">#  对矩阵进行ifft，转换为所需结果</span></span><br><span class="line">    res = torch.real(torch.fft.ifft2(res)[<span class="number">2</span>:,<span class="number">2</span>:]).view(<span class="number">1</span>,<span class="number">1</span>,<span class="number">62</span>,<span class="number">62</span>)  </span><br><span class="line">    <span class="keyword">return</span> res  <span class="comment"># 返回结果</span></span><br></pre></td></tr></table></figure>
<h3 id="2-2-使用矩阵乘法计算卷积"><a href="#2-2-使用矩阵乘法计算卷积" class="headerlink" title="2.2 使用矩阵乘法计算卷积"></a><strong>2.2 使用矩阵乘法计算卷积</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">multi_test</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;用矩阵乘法计算卷积&quot;&quot;&quot;</span></span><br><span class="line">    res = []  <span class="comment"># 定义一个列表，用来存储计算产生的结果</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">62</span>):  </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">62</span>):  <span class="comment"># 遍历图像矩阵</span></span><br><span class="line">            x_n_n = x_n[<span class="number">0</span>,<span class="number">0</span>,i:i+<span class="number">3</span>,j:j+<span class="number">3</span>]  <span class="comment"># 取图像矩阵对应的矩阵块</span></span><br><span class="line">            res0 = torch.<span class="built_in">sum</span>(x_n_n.mul(h_n))  <span class="comment"># 矩阵块和卷积核点乘求和得到一个卷积</span></span><br><span class="line">            res.append(res0)  <span class="comment"># 将卷积结果存入列表</span></span><br><span class="line">    res = torch.Tensor(res).view([<span class="number">1</span>,<span class="number">1</span>,<span class="number">62</span>,<span class="number">62</span>])  <span class="comment"># 转换列表为所需结果</span></span><br><span class="line">    <span class="keyword">return</span> res  <span class="comment"># 返回结果</span></span><br></pre></td></tr></table></figure>
<h3 id="2-3-使用内置函数计算卷积"><a href="#2-3-使用内置函数计算卷积" class="headerlink" title="2.3 使用内置函数计算卷积"></a><strong>2.3 使用内置函数计算卷积</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">conv2d_test</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;用内置函数nn.Conv2d计算卷积&quot;&quot;&quot;</span></span><br><span class="line">    conv = nn.Conv2d(<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>)  <span class="comment"># 定义conv2d的参数，(输入样本数，输出样本数，卷积核大小)</span></span><br><span class="line">    conv.weight.data = h_n  <span class="comment"># 传入自定义卷积核h_n</span></span><br><span class="line">    res = conv(x_n)  <span class="comment"># 计算x_n与h_n卷积</span></span><br><span class="line">    <span class="keyword">return</span> res  <span class="comment"># 返回结果</span></span><br></pre></td></tr></table></figure>
<h3 id="2-4-测试函数运行的时间"><a href="#2-4-测试函数运行的时间" class="headerlink" title="2.4 测试函数运行的时间"></a><strong>2.4 测试函数运行的时间</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test_time</span>(<span class="params">test_name=<span class="string">&quot;&quot;</span></span>): </span><br><span class="line">    <span class="string">&quot;&quot;&quot;测试函数的运行时间,输入：需测试的函数名&quot;&quot;&quot;</span></span><br><span class="line">    test_import = <span class="string">&quot;from __main__ import &quot;</span> + test_name </span><br><span class="line">    test_name = test_name + <span class="string">&quot;()&quot;</span>  <span class="comment"># 准备好timer函数所需参数</span></span><br><span class="line">    test = Timer(test_name,test_import)  <span class="comment"># 设定时间测试对象(测试函数名称，导入测试函数)</span></span><br><span class="line">    time = test.timeit(number=<span class="number">1000</span>)  <span class="comment"># 设定测试的次数1000次</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%s is run %.3f ms&quot;</span>%(test_name,time))  <span class="comment"># 测试时间为s，但测试1000次故为ms</span></span><br></pre></td></tr></table></figure>
<h2 id="第三节：测试"><a href="#第三节：测试" class="headerlink" title="第三节：测试"></a>第三节：测试</h2><h3 id="3-1运行时间测试"><a href="#3-1运行时间测试" class="headerlink" title="3.1运行时间测试"></a><strong>3.1运行时间测试</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">test_time(<span class="string">&quot;fft_test&quot;</span>)</span><br><span class="line">test_time(<span class="string">&quot;multi_test&quot;</span>)</span><br><span class="line">test_time(<span class="string">&quot;conv2d_test&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; fft_test() is run 0.262 ms</span><br><span class="line">    multi_test() is run 61.161 ms</span><br><span class="line">    conv2d_test() is run 0.187 ms</span><br></pre></td></tr></table></figure>
<p><strong>结论</strong>：<strong>矩阵乘法实现卷积最慢，使用FFT计算卷积稍慢于内置函数直接计算卷积。</strong></p>
<h3 id="3-2-每种方法的输出"><a href="#3-2-每种方法的输出" class="headerlink" title="3.2 每种方法的输出"></a><strong>3.2 每种方法的输出</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fft_test()</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; tensor([[[[ 186.7925,   64.8263, -217.0269,  ...,  -54.8264,  -16.5303,</span><br><span class="line">                -57.4855],</span><br><span class="line">              [ 105.5789,  103.1986,  -45.4856,  ...,  108.9532,  -11.3397,</span><br><span class="line">                -74.9136],</span><br><span class="line">              [  37.4062, -159.4092,  -82.7995,  ...,  -18.7437,  103.2889,</span><br><span class="line">                -56.7241],</span><br><span class="line">              ...,</span><br><span class="line">              [ -57.3688,  205.4553,  114.1560,  ...,   61.6281,  -30.6847,</span><br><span class="line">                123.7901],</span><br><span class="line">              [ 107.0706,  222.8759,  189.9121,  ...,  118.7491,   61.0583,</span><br><span class="line">                154.0859],</span><br><span class="line">              [ 157.7202,   55.5320,  -37.9096,  ...,  -37.6815,   39.8024,</span><br><span class="line">               -123.9654]]]])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">multi_test()</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; tensor([[[[ 186.7925,   64.8263, -217.0269,  ...,  -54.8264,  -16.5303,</span><br><span class="line">                -57.4854],</span><br><span class="line">              [ 105.5789,  103.1987,  -45.4857,  ...,  108.9533,  -11.3397,</span><br><span class="line">                -74.9136],</span><br><span class="line">              [  37.4062, -159.4092,  -82.7995,  ...,  -18.7437,  103.2889,</span><br><span class="line">                -56.7241],</span><br><span class="line">              ...,</span><br><span class="line">              [ -57.3689,  205.4553,  114.1560,  ...,   61.6282,  -30.6847,</span><br><span class="line">                123.7902],</span><br><span class="line">              [ 107.0706,  222.8759,  189.9121,  ...,  118.7491,   61.0583,</span><br><span class="line">                154.0859],</span><br><span class="line">              [ 157.7202,   55.5320,  -37.9096,  ...,  -37.6815,   39.8024,</span><br><span class="line">               -123.9654]]]])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conv2d_test()</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; tensor([[[[ 187.0928,   65.1265, -216.7267,  ...,  -54.5261,  -16.2301,</span><br><span class="line">                -57.1852],</span><br><span class="line">              [ 105.8792,  103.4989,  -45.1854,  ...,  109.2535,  -11.0395,</span><br><span class="line">                -74.6133],</span><br><span class="line">              [  37.7064, -159.1090,  -82.4993,  ...,  -18.4435,  103.5891,</span><br><span class="line">                -56.4239],</span><br><span class="line">              ...,</span><br><span class="line">              [ -57.0686,  205.7555,  114.4562,  ...,   61.9284,  -30.3845,</span><br><span class="line">                124.0904],</span><br><span class="line">              [ 107.3709,  223.1761,  190.2123,  ...,  119.0493,   61.3585,</span><br><span class="line">                154.3862],</span><br><span class="line">              [ 158.0205,   55.8323,  -37.6093,  ...,  -37.3813,   40.1026,</span><br><span class="line">               -123.6652]]]], grad_fn=&lt;ThnnConv2DBackward&gt;)</span><br></pre></td></tr></table></figure>
<p> <strong>结论</strong>: <strong>FFT计算卷积与矩阵乘法结果一致，内置函数计算卷积结果不稳定，但基本可以认为结果一致。</strong></p>
<hr>
<h3 id="3-3-运算复杂度分析"><a href="#3-3-运算复杂度分析" class="headerlink" title="3.3 运算复杂度分析"></a>3.3 运算复杂度分析</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入所需模块</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">from</span> timeit <span class="keyword">import</span> Timer</span><br><span class="line"><span class="keyword">import</span> big_o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个四维随机张量，样本数为1，通道数为1，大小为64*64为图像</span></span><br><span class="line"><span class="comment"># x_n = torch.tensor(torch.randint(0,128,[1,1,n,n]),dtype=torch.float32) </span></span><br><span class="line"><span class="comment"># 创建一个四维随机张量，样本数为1，通道数为1，大小为3*3为卷积核</span></span><br><span class="line">h_n = torch.randn(<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>)  </span><br></pre></td></tr></table></figure>
<h4 id="3-3-1-估计fft时间复杂度"><a href="#3-3-1-估计fft时间复杂度" class="headerlink" title="3.3.1 估计fft时间复杂度"></a><strong>3.3.1 估计fft时间复杂度</strong></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fft_test</span>(<span class="params">x_n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;用fft计算卷积&quot;&quot;&quot;</span></span><br><span class="line">    x_n_fft = torch.fft.fft2(x_n[<span class="number">0</span>,<span class="number">0</span>])  <span class="comment">#　对图像x_n进行fft  </span></span><br><span class="line">    h_trans = torch.flip(h_n[<span class="number">0</span>,<span class="number">0</span>], [<span class="number">1</span>])  <span class="comment"># 对卷积核h_n进行左右翻转</span></span><br><span class="line">    h_trans = torch.flipud(h_trans)  <span class="comment"># 对卷积核h_n进行上下翻转</span></span><br><span class="line">    pad = nn.ZeroPad2d(padding=(<span class="number">0</span>,<span class="number">57</span>, <span class="number">0</span>, <span class="number">57</span>))  <span class="comment"># 设置拓展矩阵填充0的维度(左，右，上，下)</span></span><br><span class="line">    h_n_pad = pad(h_trans)  <span class="comment"># 进行矩阵拓展为64*64</span></span><br><span class="line">    h_n_fft = torch.fft.fft2(h_n_pad)  <span class="comment"># 对拓展后的卷积核做fft</span></span><br><span class="line">    res = x_n_fft.mul(h_n_fft)  <span class="comment"># 两个矩阵点乘</span></span><br><span class="line">    <span class="comment">#  对矩阵进行ifft，转换为所需结果</span></span><br><span class="line">    res = torch.real(torch.fft.ifft2(res)[<span class="number">2</span>:,<span class="number">2</span>:]).view(<span class="number">1</span>,<span class="number">1</span>,<span class="number">58</span>,<span class="number">58</span>)  </span><br><span class="line">    <span class="keyword">return</span> res  <span class="comment"># 返回结果</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>估计时间复杂度(图像的大小n*n作为参数)</strong></li>
</ul>
<p>根据程序可以发现影响运算复杂度的主要为<strong>两次FFT和一次IFFT</strong>，设图像矩阵为n*n，卷积核矩阵为3*3；<br><br>取<strong>最高复杂度为FFT变换的复杂度</strong>$n^2logn$，故运算复杂度估计为$O(n^2logn)。$</p>
<ul>
<li><p><strong>程序计算时间复杂度(图像作为参数)</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">positive_int_generator = <span class="keyword">lambda</span> n : torch.tensor(torch.randint(<span class="number">0</span>,<span class="number">128</span>,[<span class="number">1</span>,<span class="number">1</span>,<span class="number">64</span>,<span class="number">64</span>]),dtype=torch.float32) </span><br><span class="line"><span class="comment">#将图像矩阵当成参数传入</span></span><br></pre></td></tr></table></figure>
<p>使用<strong>big_o模块</strong>进行复杂度估计，通过修改矩阵的大小分别得到以下几组结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">best,other = big_o.big_o(fft_test,positive_int_generator,n_repeats=<span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(best)</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p><ipython-input-87-b8f03f88cb0c>:1: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires<em>grad</em>(True), rather than torch.tensor(sourceTensor).</p>
<pre><code>positive_int_generator = lambda n : torch.tensor(torch.randint(0,128,[1,1,520,520]),dtype=torch.float32)
</code></pre><p>Logarithmic: time = 0.089 + -0.0031*log(n) (sec)</p>
</blockquote>
</blockquote>
</blockquote>
<pre><code>positive_int_generator = lambda n : torch.tensor(torch.randint(0,128,[1,1,220,220]),dtype=torch.float32)
</code></pre><blockquote>
<blockquote>
<blockquote>
<p>Logarithmic: time = 0.11 + -0.0043*log(n) (sec)</p>
</blockquote>
</blockquote>
</blockquote>
<pre><code>positive_int_generator = lambda n : torch.tensor(torch.randint(0,128,[1,1,120,120]),dtype=torch.float32)
</code></pre><blockquote>
<blockquote>
<blockquote>
<p>Logarithmic: time = 0.59 + -0.019*log(n) (sec)</p>
</blockquote>
</blockquote>
</blockquote>
<pre><code>positive_int_generator = lambda n : torch.tensor(torch.randint(0,128,[1,1,60,60]),dtype=torch.float32)
</code></pre><blockquote>
<blockquote>
<blockquote>
<p>Logarithmic: time = 0.089 + -0.0054<em>log(n) (sec)<br><em>*通过几组不同大小的图像分析，运算复杂度更接近$O(logn)$。</em></em></p>
<h4 id="3-3-2-估计矩阵乘法时间复杂度"><a href="#3-3-2-估计矩阵乘法时间复杂度" class="headerlink" title="3.3.2 估计矩阵乘法时间复杂度"></a><strong>3.3.2 估计矩阵乘法时间复杂度</strong></h4></blockquote>
</blockquote>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">multi_test</span>(<span class="params">x_n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;用矩阵乘法计算卷积&quot;&quot;&quot;</span></span><br><span class="line">    res = []  <span class="comment"># 定义一个列表，用来存储计算产生的结果</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">62</span>):  </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">62</span>):  <span class="comment"># 遍历图像矩阵</span></span><br><span class="line">            x_n_n = x_n[<span class="number">0</span>,<span class="number">0</span>,i:i+<span class="number">3</span>,j:j+<span class="number">3</span>]  <span class="comment"># 取图像矩阵对应的矩阵块</span></span><br><span class="line">            res0 = torch.<span class="built_in">sum</span>(x_n_n.mul(h_n))  <span class="comment"># 矩阵块和卷积核点乘求和得到一个卷积</span></span><br><span class="line">            res.append(res0)  <span class="comment"># 将卷积结果存入列表</span></span><br><span class="line">    res = torch.Tensor(res).view([<span class="number">1</span>,<span class="number">1</span>,<span class="number">62</span>,<span class="number">62</span>])  <span class="comment"># 转换列表为所需结果</span></span><br><span class="line">    <span class="keyword">return</span> res  <span class="comment"># 返回结果</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>估计时间复杂度(图像的大小n*n作为参数)</strong><br>根据程序可以发现影响时间复杂度的为一个<strong>双重嵌套循环</strong>，设图像矩阵为n*n，卷积核矩阵为3*3；<br><br>最外层for循环有$(n-3)$，故可估计复杂度为$n$；<br><br>内部循环<strong>复杂度最高的为一个取矩阵块的操作</strong>，可认为是二维的切片操作，从$0$到$n-3$，有$((n-3)/2)^2$，故可取复杂度为$n^2$；<br><br>忽略其他因素，可认为运算复杂度为$O(n^3)$。</li>
<li><p><strong>程序计算时间复杂度(图像作为参数)</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">best,other = big_o.big_o(multi_test,positive_int_generator,n_repeats=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(best)</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p><ipython-input-9-ae97cb9d6fcc>:1: UserWarning: To copy construct from a tensor, it is recommended to use sourceTensor.clone().detach() or sourceTensor.clone().detach().requires<em>grad</em>(True), rather than torch.tensor(sourceTensor).</p>
<pre><code>positive_int_generator = lambda n : torch.tensor(torch.randint(0,128,[1,1,160,160]),dtype=torch.float32)
</code></pre><p>Cubic: time = 0.43 + -2.4E-17*n^3 (sec)</p>
</blockquote>
</blockquote>
</blockquote>
<pre><code>positive_int_generator = lambda n : torch.tensor(torch.randint(0,128,[1,1,100,100]),dtype=torch.float32)
</code></pre><blockquote>
<blockquote>
<blockquote>
<p>Cubic: time = 0.2 + -2.4E-17*n^3 (sec)</p>
</blockquote>
</blockquote>
</blockquote>
<pre><code>positive_int_generator = lambda n : torch.tensor(torch.randint(0,128,[1,1,64,64]),dtype=torch.float32)
</code></pre><blockquote>
<blockquote>
<blockquote>
<p>Cubic: time = 0.062 + 1.9E-17<em>n^3 (sec)<br><em>*通过几组不同大小的图像分析，运算复杂度更接近$O(n^3)$。</em></em></p>
</blockquote>
</blockquote>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Ray进行超参数搜索</title>
    <url>/link/80f8ebc6.html</url>
    <content><![CDATA[<h1 id="使用Ray进行超参数搜索"><a href="#使用Ray进行超参数搜索" class="headerlink" title="使用Ray进行超参数搜索"></a>使用Ray进行超参数搜索</h1><p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202302181634100.png" alt="image-20230218163414849"></p>
<h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><blockquote>
<p>在该板块里主要使用Ray的超参数搜索相关的功能。使用 Ray 进行超参数搜索非常方便，Ray 提供了一个名为 Tune 的模块，它专门用于超参数搜索和自动化调参。</p>
<p>下面是一个使用 Ray Tune 进行超参数搜索的示例：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ray</span><br><span class="line"><span class="keyword">from</span> ray <span class="keyword">import</span> tune</span><br><span class="line"><span class="keyword">from</span> ray.tune.examples.mnist_pytorch <span class="keyword">import</span> get_data_loaders, ConvNet, train, test</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train_mnist</span>(<span class="params">config</span>):</span><br><span class="line">    train_loader, test_loader = get_data_loaders()</span><br><span class="line">    model = ConvNet()</span><br><span class="line">    optimizer = optim.SGD(model.parameters(), lr=config[<span class="string">&quot;lr&quot;</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        train(model, optimizer, train_loader)</span><br><span class="line">        acc = test(model, test_loader)</span><br><span class="line">        tune.report(mean_accuracy=acc)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    ray.init()</span><br><span class="line">    config = &#123;</span><br><span class="line">        <span class="string">&quot;lr&quot;</span>: tune.loguniform(<span class="number">1e-4</span>, <span class="number">1e-1</span>),</span><br><span class="line">        <span class="string">&quot;batch_size&quot;</span>: tune.choice([<span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    analysis = tune.run(</span><br><span class="line">        train_mnist,</span><br><span class="line">        config=config,</span><br><span class="line">        num_samples=<span class="number">10</span>,</span><br><span class="line">        progress_reporter=tune.CLIReporter()</span><br><span class="line">    )</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>​        在上面的示例中，我们定义了一个 <code>train_mnist</code> 函数，它根据传入的配置超参数训练一个 MNIST 分类器。然后，我们使用 <code>ray.tune.run()</code> 函数运行了一个超参数搜索，指定了需要搜索的超参数和搜索的次数。</p>
<p>​        在搜索过程中，Tune 会并行地运行多个训练任务，并收集它们的性能指标（这里使用的是准确率）。Tune 会不断更新当前最优的超参数组合，并在搜索完成后输出搜索结果。</p>
<p>​        使用 Ray Tune 进行超参数搜索非常方便，并且具有良好的可扩展性和并行化能力。同时，Tune 还支持多种搜索算法和调参策略，可以帮助用户更快地找到最优的超参数组合。</p>
<p>​        在 Ray Tune 中，可以使用 <code>analysis</code> 对象来获取超参数搜索的结果。<code>analysis</code> 包含了搜索过程中的所有结果，包括每组超参数的性能指标和其他统计信息。</p>
<p>​        为了输出最佳的超参数组合，可以使用 <code>analysis.get_best_config()</code> 函数，它会返回一个字典，包含了当前搜索中最优的超参数组合。</p>
<p>下面是一个示例代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">codebest_config = analysis.get_best_config(metric=<span class="string">&quot;mean_accuracy&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Best config: &quot;</span>, best_config)</span><br></pre></td></tr></table></figure>
<p>​        在上面的代码中，我们使用 <code>get_best_config()</code> 函数获取当前搜索中最优的超参数组合，其中 <code>metric</code> 参数指定了评估超参数性能的指标名称（在本例中是准确率）。</p>
<p>输出的结果将包含当前最优的超参数组合，例如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">Best config: &#123;&#x27;lr&#x27;: <span class="number">0.0029386762963524755</span>, <span class="string">&#x27;batch_size&#x27;</span>: <span class="number">16</span>&#125;</span><br></pre></td></tr></table></figure>
<p>​        使用 <code>analysis</code> 对象还可以获取更多的统计信息，例如训练任务的性能指标分布、超参数的搜索空间、不同超参数组合的性能指标等。这些信息可以帮助用户更好地理解搜索过程和超参数的性能，从而进行更好的调参和优化。</p>
<h2 id="config"><a href="#config" class="headerlink" title="config"></a>config</h2><p>​        在 Ray Tune 中，config 字典可以包含各种类型的参数，包括：</p>
<ul>
<li>float：浮点型参数。</li>
<li>int：整型参数。</li>
<li>bool：布尔型参数。</li>
<li>string：字符串型参数。</li>
<li>choice：离散型参数，可以是一个列表，从中随机选择一个元素作为参数值。</li>
<li>quniform：均匀分布型参数，需要指定参数的下限、上限和间隔。</li>
<li>qloguniform：对数均匀分布型参数，需要指定参数的下限、上限和间隔。</li>
<li>qnormal：正态分布型参数，需要指定参数的均值、标准差和间隔。</li>
<li>loguniform：对数均匀分布型参数，需要指定参数的下限和上限。</li>
</ul>
<p>​        除了上述类型之外，用户还可以自定义其他类型的参数。在定义参数类型时，需要使用相应的函数或类来指定参数的类型和范围。</p>
<p>​        需要注意的是，在使用 Ray Tune 进行超参数搜索时，不同参数类型的定义方式可能有所不同，具体要根据不同的搜索算法和调参策略来决定。例如，在网格搜索中，只能使用离散型参数和枚举参数，而在贝叶斯优化中，可以使用更多的参数类型和分布。</p>
<p>​        在实际应用中，需要根据具体问题和搜索目标来选择合适的参数类型和范围，以及相应的搜索算法和调参策略，以获得最优的超参数组合。</p>
<h2 id="turn-run"><a href="#turn-run" class="headerlink" title="turn.run()"></a>turn.run()</h2><p>​        在 Ray Tune 中，<code>tune.run()</code> 函数是执行超参数搜索的入口函数，它有许多可配置的参数，用于控制搜索过程和评估结果的统计方法。下面是 <code>tune.run()</code> 函数中常用的一些参数：</p>
<ul>
<li><code>run_or_experiment</code>：必选参数，指定要执行的训练任务或实验。可以是一个训练函数，也可以是一个 Ray Tune 可识别的实验配置（如一个 JSON 或 YAML 文件）。</li>
<li><code>config</code>：必选参数，定义了超参数搜索的空间和范围。它应该是一个字典，包含要搜索的超参数及其可能的取值范围。</li>
<li><code>stop</code>：必选参数，指定了停止搜索的条件，可以是一个训练轮数、时间限制或达到一定的性能阈值。</li>
<li><code>num_samples</code>：可选参数，指定搜索过程中尝试的不同超参数组合的数量。默认值为1。</li>
<li><code>resources_per_trial</code>：可选参数，指定每个试验使用的资源，如 CPU、GPU、内存等。</li>
<li><code>num_gpus</code>：可选参数，指定每个试验使用的 GPU 数量。</li>
<li><code>num_cpus</code>：可选参数，指定每个试验使用的 CPU 数量。</li>
<li><code>local_dir</code>：可选参数，指定本地存储超参数搜索结果的目录。</li>
<li><code>checkpoint_freq</code>：可选参数，指定在训练过程中保存检查点的频率。</li>
<li><code>keep_checkpoints_num</code>：可选参数，指定保留的检查点数。</li>
<li><code>checkpoint_score_attr</code>：可选参数，指定评估训练任务性能的指标名称，用于选择最优的检查点。</li>
<li><code>max_failures</code>：可选参数，指定超参数搜索过程中允许的最大失败次数。</li>
</ul>
<p>​        除了上述参数之外，<code>tune.run()</code> 函数还有许多其他可选参数，例如中断处理、调试模式、并行度控制等。用户可以根据自己的需求和搜索目标选择合适的参数，并进行适当的调参和优化，以获得最佳的超参数组合。</p>
<p>除了上面提到的常用参数，Ray Tune 的 <code>tune.run()</code> 函数还提供了一些其他可选参数，下面我们逐一介绍：</p>
<ul>
<li><code>scheduler</code>: 调度器。默认使用ASHAScheduler, 也可以设置为其他调度器，如 AsyncHyperBandScheduler、MedianStoppingRule等。</li>
<li><code>name</code>: 针对该试验的名称，用于标识该试验的实例。如果不指定，则 Ray Tune 将自动生成一个唯一名称。</li>
<li><code>trial_name_creator</code>: 用于创建每个试验名称的回调函数。如果未设置，则会使用 Ray Tune 提供的默认方法来生成名称。</li>
<li><code>log_to_file</code>: 是否将结果日志输出到文件中，默认为True。</li>
<li><code>loggers</code>: 一个或多个logger，用于记录结果日志。支持TensorBoardLogger、JSONLogger、CSVLogger、MLFlowLogger等不同类型的logger。</li>
<li><code>resume</code>: 是否从之前的 checkpoint 继续运行搜索。</li>
<li><code>queue_trials</code>: 是否将试验排队，默认为 False。如果为True，则试验将按顺序运行，而不是并发运行。</li>
<li><code>reuse_actors</code>: 是否复用已有的 actors 来启动新的试验。</li>
<li><code>trial_executor</code>: 用于执行训练任务的执行器，默认为 RayTrialExecutor。也可以设置为其他的执行器。</li>
<li><code>raise_on_failed_trial</code>: 是否在试验失败时引发异常。默认为 True。</li>
<li><code>search_alg</code>: 搜索算法。默认为 HyperOptSearch，支持其他搜索算法如 RandomSearch、GridSearch等。</li>
<li><code>scheduler</code>: 调度器。默认为 ASHAScheduler，支持其他调度器如 AsyncHyperBandScheduler、MedianStoppingRule等。</li>
<li><code>search_space</code>: 搜索空间。用于指定搜索算法的参数空间。</li>
</ul>
<p>​        以上就是 Ray Tune 中 <code>tune.run()</code> 函数的所有可选参数，根据具体需求和搜索目标，用户可以选择不同的参数组合和配置方式，以获得最佳的超参数组合。</p>
<p>​        在 Ray Tune 中，调度器（scheduler）是一种可以根据试验结果调整超参数搜索策略的工具。调度器可以根据不同的策略动态地调整试验的超参数、分配计算资源等，从而加速试验的收敛速度或提高试验结果的质量。Ray Tune 支持多种调度器，例如 HyperBand、ASHA 等。</p>
<p>​        HyperBand 是一种基于倍增策略的调度器，它会按照指数级别的规模扩展并行的试验，然后通过不断淘汰较差的试验和继续放大优秀试验的规模，来提高试验的效率。HyperBand 的主要优点是快速收敛、高效利用资源，但也有一定的缺点，比如可能会忽略一些潜在的好结果、试验结果具有一定的随机性等。</p>
<p>​        ASHA（Asynchronous Successive Halving Algorithm）是一种异步的连续二分调度器，它会按照指数级别的规模扩展并行的试验，并在每个规模下使用连续二分法（Successive Halving Algorithm）来剪枝较差的试验，从而提高试验的效率。ASHA 的主要优点是能够在较短的时间内找到接近最优的结果、具有较好的鲁棒性、支持动态分配资源等。</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">codetune.run(</span><br><span class="line">    train_mnist,</span><br><span class="line">    config=config,</span><br><span class="line">    num_samples=<span class="number">10</span>,</span><br><span class="line">    scheduler=HyperBandScheduler(),</span><br><span class="line">    metric=<span class="string">&quot;mean_accuracy&quot;</span>,</span><br><span class="line">    mode=<span class="string">&quot;max&quot;</span>,</span><br><span class="line">    resources_per_trial=&#123;<span class="string">&quot;cpu&quot;</span>: <span class="number">1</span>&#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>​        在上面的例子中，我们使用HyperBand 调度器来优化超参数搜索。通过设置 <code>scheduler=HyperBandScheduler()</code> 参数来指定使用 HyperBand 调度器，同时指定 <code>metric</code> 和 <code>mode</code> 参数来指定需要最大化的评估指标和最大化或最小化的方向。另外，还可以通过设置 <code>resources_per_trial</code> 参数来指定每个试验的资源占用情况。</p>
<h2 id="analysis"><a href="#analysis" class="headerlink" title="analysis"></a>analysis</h2><p>​        Ray Tune 的 <code>Analysis</code> 对象提供了丰富的 API，可以获取更多的统计信息，帮助用户深入了解超参数搜索的过程和结果。下面列举一些常用的 API：</p>
<ul>
<li><code>dataframe()</code>: 将结果转换为 pandas DataFrame 格式。</li>
<li><code>trials_dataframes()</code>: 将每个试验结果转换为 pandas DataFrame 格式，并返回一个字典，字典的 key 为试验 ID，value 为 pandas DataFrame 格式的结果数据。</li>
<li><code>get_best_config(metric, mode=&#39;max&#39;)</code>: 获取最佳超参数配置。<code>metric</code> 表示评估指标的名称，<code>mode</code> 表示评估模式，有两种可选值：<code>max</code> 和 <code>min</code>，分别表示评估指标的最大值和最小值。</li>
<li><code>get_best_trial(metric, mode=&#39;max&#39;)</code>: 获取性能最佳的试验。与 <code>get_best_config</code> 类似，不过返回的是最优试验的结果数据。</li>
<li><code>get_trial(trial_id)</code>: 获取指定试验 ID 的结果数据。</li>
<li><code>get_best_logdir(metric, mode=&#39;max&#39;)</code>: 获取性能最佳的试验的日志目录。</li>
<li><code>get_trainable_stats(trial_id, include_ray=False)</code>: 获取指定试验的统计信息，包括训练时长、训练进度、资源占用情况等。</li>
<li><code>get_all_stats(metric, mode=&#39;max&#39;)</code>: 获取所有试验的统计信息，包括训练时长、训练进度、资源占用情况等。</li>
<li><code>last_result(trial)</code>: 获取最后一次试验结果的数据，包括评估指标、参数配置等。</li>
</ul>
<p>​        除了上面列举的 API，<code>Analysis</code> 对象还提供了其他一些方法，例如获取调度器状态、打印试验结果摘要等。通过这些 API，用户可以更加全面地了解超参数搜索的情况，并进行进一步的分析和优化。</p>
<h2 id="tune-report"><a href="#tune-report" class="headerlink" title="tune.report"></a>tune.report</h2><p>​        <code>tune.report()</code> 是 Ray Tune 中的一个函数，用于报告试验的结果指标。在使用 Ray Tune 进行超参数搜索时，用户需要在可训练函数（trainable function）中调用 <code>tune.report()</code> 函数来汇报试验结果，以便 Ray Tune 能够记录结果并据此进行超参数搜索。<code>tune.report()</code> 函数的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tune.report(result=None, **kwargs)</span><br></pre></td></tr></table></figure>
<p>​        其中，<code>result</code> 参数用于报告试验结果，可以是一个数字或一个字典，代表试验的评估指标。<code>**kwargs</code> 参数用于指定其他元数据，例如训练时长、日志目录、资源占用情况等。</p>
<p>​        例如，下面是一个简单的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import torch</span><br><span class="line">import torch.nn as nn</span><br><span class="line">import torch.optim as optim</span><br><span class="line">import numpy as np</span><br><span class="line">import ray</span><br><span class="line">from ray import tune</span><br><span class="line"></span><br><span class="line">def train_mnist(config):</span><br><span class="line">    # 加载数据</span><br><span class="line">    train_loader, test_loader = get_data_loaders()</span><br><span class="line">    </span><br><span class="line">    # 定义模型</span><br><span class="line">    model = SimpleConvNet(config[&quot;hidden_size&quot;], config[&quot;dropout&quot;])</span><br><span class="line">    criterion = nn.CrossEntropyLoss()</span><br><span class="line">    optimizer = optim.SGD(model.parameters(), lr=config[&quot;lr&quot;], momentum=0.9)</span><br><span class="line">    </span><br><span class="line">    # 训练模型</span><br><span class="line">    for epoch in range(config[&quot;epochs&quot;]):</span><br><span class="line">        for i, (inputs, labels) in enumerate(train_loader):</span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            outputs = model(inputs)</span><br><span class="line">            loss = criterion(outputs, labels)</span><br><span class="line">            loss.backward()</span><br><span class="line">            optimizer.step()</span><br><span class="line">            </span><br><span class="line">        # 汇报结果</span><br><span class="line">        acc = test_model(model, test_loader)</span><br><span class="line">        tune.report(mean_accuracy=acc, done=True, training_iteration=epoch)</span><br></pre></td></tr></table></figure>
<p>​        在上面的例子中，<code>train_mnist()</code> 函数是一个可训练函数，用于训练 MNIST 数据集上的简单卷积神经网络。在训练过程中，我们使用 <code>tune.report()</code> 函数来汇报每个 epoch 的平均精度 <code>mean_accuracy</code>，并通过 <code>done=True</code> 参数表示本次试验已经完成。这样 Ray Tune 就可以记录并分析试验结果，从而进行超参数搜索。</p>
]]></content>
      <categories>
        <category>网络优化</category>
      </categories>
      <tags>
        <tag>超参数搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>超参数搜索简略</title>
    <url>/link/30fbbb4f.html</url>
    <content><![CDATA[<h1 id="超参数搜索简略"><a href="#超参数搜索简略" class="headerlink" title="超参数搜索简略"></a>超参数搜索简略</h1><h2 id="超参数自动搜索的方法有哪些？"><a href="#超参数自动搜索的方法有哪些？" class="headerlink" title="超参数自动搜索的方法有哪些？"></a>超参数自动搜索的方法有哪些？</h2><ol>
<li>网格搜索：在预定义的超参数空间中穷举所有可能的超参数组合，并选择效果最好的一组作为最终超参数。</li>
<li>随机搜索：在预定义的超参数空间中随机选择一组超参数，并训练模型并评估效果。重复这个过程多次，直到找到最佳超参数。</li>
<li>贝叶斯优化：使用贝叶斯方法来选择下一个超参数组合，以尽可能地减少目标函数（例如验证集误差）的不确定性。</li>
<li>进化算法：模拟生物进化过程，使用选择、交叉和变异等操作对超参数组合进行优化。</li>
<li>梯度下降：将超参数优化问题看作是一个函数的最小化问题，使用梯度下降或其变种算法来寻找最小值。</li>
<li>Hyperband：基于并行随机搜索的算法，通过动态调整超参数组合的搜索空间和评估时间，尽可能快地找到最优超参数组合。</li>
</ol>
<p>以上是一些常见的超参数自动搜索方法，每种方法都有其优缺点和适用场景，需要根据具体情况选择合适的方法。</p>
<h2 id="各个算法的优缺点"><a href="#各个算法的优缺点" class="headerlink" title="各个算法的优缺点"></a>各个算法的优缺点</h2><p>1.网格搜索</p>
<p>优点：网格搜索是一种简单直观的方法，易于理解和实现。在超参数空间比较小的情况下，可以保证找到最优解。</p>
<p>缺点：当超参数空间比较大时，网格搜索需要搜索大量的超参数组合，计算量非常大，耗时长。</p>
<p>2.随机搜索</p>
<p>优点：随机搜索可以避免网格搜索中计算量的问题，同时也能够找到比较优秀的超参数组合。</p>
<p>缺点：由于随机搜索是随机选择超参数组合的，因此可能会出现一些不够优秀的组合，导致需要进行更多的搜索，耗费更多时间和计算资源。</p>
<p>3.贝叶斯优化</p>
<p>优点：贝叶斯优化可以通过不断选择下一个最有可能是最优超参数组合的点来尽可能快地找到最优解。在超参数空间比较大时，贝叶斯优化的效果通常比网格搜索和随机搜索更好。</p>
<p>缺点：贝叶斯优化需要使用高斯过程等较为复杂的模型，对算法的实现和调参都有一定要求。同时，贝叶斯优化的计算复杂度较高，需要更多的时间和计算资源。</p>
<p>4.进化算法</p>
<p>优点：进化算法类似于贝叶斯优化，可以通过选择、交叉和变异等操作来寻找最优超参数组合。进化算法比较适合用于离散的超参数空间，可以处理多个超参数之间的交互影响。</p>
<p>缺点：与贝叶斯优化一样，进化算法的计算复杂度较高，需要更多的时间和计算资源。</p>
<p>5.梯度下降</p>
<p>优点：梯度下降等优化算法是非常通用的方法，可以用于优化任何连续可微的函数，包括超参数搜索问题。</p>
<p>缺点：超参数搜索问题通常不是凸优化问题，因此使用梯度下降等优化算法很容易陷入局部最优解。</p>
<p>6.Hyperband</p>
<p>优点：Hyperband是一种基于随机搜索和并行计算的算法，可以在较短时间内快速找到最优解。Hyperband使用动态调整搜索空间和评估时间的方法，可以有效平衡搜索效率和搜索质量。</p>
<p>缺点：Hyperband需要对搜索算法进行并行化处理，需要更多的计算资源。同时，Hyperband的随机性可能导致无法保证每次搜索的结果都是最优解。</p>
<p>7.遗传算法</p>
<p>优点：遗传算法是一种经典的进化算法，通过选择、交叉和变异等操作来优化超参数组合。与进化算法类似，遗传算法适合处理离散的超参数空间，可以处理多个超参数之间的交互影响。</p>
<p>缺点：与进化算法一样，遗传算法的计算复杂度较高，需要更多的时间和计算资源。</p>
<p>​        总体而言，超参数自动搜索方法各有优缺点，需要根据具体情况选择。如果超参数空间比较小，网格搜索是一种不错的选择。如果超参数空间较大，可以考虑使用随机搜索或贝叶斯优化。如果需要处理离散的超参数空间，可以考虑使用进化算法或遗传算法。如果需要快速搜索最优解，可以考虑使用Hyperband。同时，也可以考虑将不同的搜索方法结合使用，以获得更好的搜索效果。</p>
]]></content>
      <categories>
        <category>网络优化</category>
      </categories>
      <tags>
        <tag>超参数搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>seaborn作图目录</title>
    <url>/link/a9bf9964.html</url>
    <content><![CDATA[<h1 id="seaborn作图参考"><a href="#seaborn作图参考" class="headerlink" title="seaborn作图参考"></a>seaborn作图参考</h1><blockquote>
<p>可视化是数据分析中重要的一环，通过不同类型的图表，能够直观的看出数据的分布，总体的趋势等内容。</p>
<p>主要参考：</p>
<p><a href="https://handsome-man.blog.csdn.net/article/details/127657253">Python数据可视化：如何选择合适的图表可视化？</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/427784435">AI | 我用Python的Seaborn库，绘制了17个超好看图表</a></p>
<p><a href="https://blog.csdn.net/weixin_44322234/article/details/115129289">只需要掌握这3个function, 就能快速画出任何(80%)想要画的图</a></p>
<p><a href="https://blog.csdn.net/weixin_43848469/article/details/112100860">学习sns过程中的一些使图更好看的小技巧</a></p>
</blockquote>
]]></content>
      <categories>
        <category>可视化</category>
      </categories>
      <tags>
        <tag>seaborn</tag>
      </tags>
  </entry>
  <entry>
    <title>图像处理目录</title>
    <url>/link/822eccaa.html</url>
    <content><![CDATA[<h1 id="图像处理目录"><a href="#图像处理目录" class="headerlink" title="图像处理目录"></a>图像处理目录</h1><blockquote>
<p>本文大概介绍基本的学习路径，以及每个部分的大致内容。</p>
<p>这个主题主要介绍一下常用的图像处理有哪些，以及简要的介绍其功能，具体的原理以及代码，将在后续一个一个实现。使用的代码主要为python代码，实现的环境主要是pytorch和opencv。</p>
</blockquote>
<ul>
<li><p>基础知识：了解图像处理的基本概念，例如图像矩阵、图像分类、图像尺寸等。</p>
</li>
<li><p>图像读取和存储：学习如何读取和存储图像，了解常用的图像格式，如BMP、JPEG、PNG等。</p>
</li>
<li><p>图像基本操作：学习图像的剪切、旋转、缩放等基本操作。</p>
</li>
<li><p>灰度变换：学习灰度变换，包括灰度转换、二值化等。</p>
</li>
<li><p>图像增强：学习图像增强技术，例如直方图均衡、对比度增强等。</p>
</li>
<li><p>滤波技术：学习滤波技术，包括线性滤波和非线性滤波。</p>
</li>
<li><p>图像特征：学习如何提取图像特征，例如边缘检测、角点检测等。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>github actions自动部署博客</title>
    <url>/link/e7801076.html</url>
    <content><![CDATA[<h1 id="github-actions自动部署博客"><a href="#github-actions自动部署博客" class="headerlink" title="github actions自动部署博客"></a>github actions自动部署博客</h1><blockquote>
<p>图文来源：</p>
<p><a href="https://blog.csdn.net/qq_51661411/article/details/117458995">https://blog.csdn.net/qq_51661411/article/details/117458995</a></p>
<p><a href="https://qidaink.github.io/post/2ee2604b.html">https://qidaink.github.io/post/2ee2604b.html</a></p>
<p><a href="https://akilar.top/posts/f752c86d/">https://akilar.top/posts/f752c86d/</a></p>
</blockquote>
<h2 id="Github-Actions介绍"><a href="#Github-Actions介绍" class="headerlink" title="Github Actions介绍"></a><code>Github Actions</code>介绍</h2><p>  <code>Github Actions</code>是<code>GitHub</code>于 2018 年 10 月推出的一个<code>CI/CD</code>服务。那什么是<code>CI/CD</code>呢？<code>CI/CD</code>其实说的是三件事情：</p>
<ul>
<li>持续集成（Continuous Integration）</li>
<li>持续交付（Continuous Delivery）</li>
<li>持续部署（Continuous Deployment）</li>
</ul>
<p>  按照自己的理解，就是一个可以在<code>Github</code>仓库中自动执行一些命令的工具，它的配置文件为<code>yaml</code>格式。本文不是主要详细介绍它的语法，而是介绍如何使用这个工具来完成自动部署，所以这里就不写更多关于语法的啦（主要原因还是自己也不是特别了解😭），更多详细介绍可以查看官方介绍文档：<a href="https://docs.github.com/en/actions">Github Actions</a></p>
<h2 id="获取token"><a href="#获取token" class="headerlink" title="获取token"></a>获取token</h2><p>​        获取token是为了保证上传到GitHub公开的网站仓库（编译后的静态页面存放的仓库）有足够的权限可以上传，如果你只是要部署到服务器不同步到GitHub page可以忽略这一步。</p>
<p>​        访问<a href="https://github.com/settings/tokens">Github-&gt;头像（右上角）-&gt;Settings-&gt;Developer Settings-&gt;Personal access tokens</a>-&gt;generate new token,创建的<code>Token</code>名称随意，但必须勾选repo项和workflows项。</p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202302112126064.png" alt="img"></p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202302112126128.png" alt="img"></p>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202302112126896.png" alt="img"></p>
<p>​        生成token后请复制保存到安全的地方确保已经正确记录token因为token只会显示这一次，如果忘记了只能重新生成，这样做也是为了保护账号安全防止被人盗取token为所欲为。</p>
<h2 id="创建存放hexo源码的私有仓库"><a href="#创建存放hexo源码的私有仓库" class="headerlink" title="创建存放hexo源码的私有仓库"></a>创建存放hexo源码的私有仓库</h2><p>​        创建一个用来存放<code>Hexo</code>博客源码的私有仓库<code>[SourceRepo]</code><br><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202302112122984.png" alt="img"></p>
<p>​        使用私有仓库是因为涉及到自己文章如果开源仓库可能会导致别人盗取文章的风险同时开源也会暴露站点yml里的token可能会被别有用心获取肆意操作你的github仓库。所以必须闭源。</p>
<h2 id="修改站点-config-yml-deploy"><a href="#修改站点-config-yml-deploy" class="headerlink" title="修改站点_config.yml deploy"></a>修改站点_config.yml deploy</h2><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  - type: git</span><br><span class="line">    repo: https://GitHub用户名:上一步获取的token@github.com/GitHub用户名/GitHubpages对应的仓库.git</span><br><span class="line">    branch: master #GitHubpages对应的仓库存放的分支2020年十二月以后默认分支为main注意修改</span><br></pre></td></tr></table></figure>
<h2 id="上传本地bolg目录"><a href="#上传本地bolg目录" class="headerlink" title="上传本地bolg目录"></a>上传本地bolg目录</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将 blog 目录变成 git 可以管理的仓库</span></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把文件添加到版本库中</span></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把文件提交到仓库。引号内为提交注释</span></span><br><span class="line">git commit -m <span class="string">&#x27;第一次提交&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关联到远程库</span></span><br><span class="line">git remote add origin https://github.com/用户名/新建仓库名.git</span><br><span class="line"><span class="comment"># 或者 git remote add origin git@github.com:用户名/新建仓库名.git</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把本地库的内容推送到远程</span></span><br><span class="line"><span class="comment">## 第一次使用加上了-u参数，是推送内容并关联分支。</span></span><br><span class="line"><span class="comment"># 分支名为main，根据自己情况修改</span></span><br><span class="line">git push -u origin main</span><br><span class="line"><span class="comment"># 下次直接提交 git push origin main</span></span><br></pre></td></tr></table></figure>
<h2 id="actions自动部署"><a href="#actions自动部署" class="headerlink" title="actions自动部署"></a>actions自动部署</h2><ul>
<li>新建的仓库中找到actions，点击进入，点击set up a workflow yourself，如下图所示</li>
</ul>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202302112133084.png" alt="image-20230211213310748"></p>
<ul>
<li>进入下图所示的页面。</li>
</ul>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202302112145476.png" alt="image-20230211214522119"></p>
<ul>
<li>在左边文本栏复制以下内容，注意最后根据自己的情况进行修改。</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line"># 当有改动推送到master分支时，启动Action</span><br><span class="line">name: 自动部署</span><br><span class="line"></span><br><span class="line">on:</span><br><span class="line">  push:             # 有推送时就触发</span><br><span class="line">    branches:</span><br><span class="line">      - master</span><br><span class="line"></span><br><span class="line">  release:</span><br><span class="line">    types:</span><br><span class="line">      - published</span><br><span class="line"></span><br><span class="line">jobs:</span><br><span class="line">  deploy:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    steps:</span><br><span class="line">    - name: 检查分支</span><br><span class="line">      uses: actions/checkout@v2</span><br><span class="line">      with:</span><br><span class="line">        ref: master</span><br><span class="line"></span><br><span class="line">    - name: 安装 Node</span><br><span class="line">      uses: actions/setup-node@v1</span><br><span class="line">      with:</span><br><span class="line">        node-version: &quot;12.x&quot;</span><br><span class="line"></span><br><span class="line">    - name: 安装 Hexo</span><br><span class="line">      run: |</span><br><span class="line">        export TZ=&#x27;Asia/Shanghai&#x27;</span><br><span class="line">        npm install hexo-cli -g</span><br><span class="line">    - name: 缓存 Hexo</span><br><span class="line">      uses: actions/cache@v1</span><br><span class="line">      id: cache</span><br><span class="line">      with:</span><br><span class="line">        path: node_modules</span><br><span class="line">        key: $&#123;&#123;runner.OS&#125;&#125;-$&#123;&#123;hashFiles(&#x27;**/package-lock.json&#x27;)&#125;&#125;</span><br><span class="line"></span><br><span class="line">    - name: 安装依赖</span><br><span class="line">      if: steps.cache.outputs.cache-hit != &#x27;true&#x27;</span><br><span class="line">      run: |</span><br><span class="line">        npm install --save</span><br><span class="line">        </span><br><span class="line">    - name: 生成静态文件</span><br><span class="line">      run: |</span><br><span class="line">        hexo clean</span><br><span class="line">        hexo generate</span><br><span class="line">  </span><br><span class="line">    - name: 部署</span><br><span class="line">      run: |</span><br><span class="line">        git config --global user.name &quot;用户名&quot;</span><br><span class="line">        git config --global user.email &quot;用户邮箱&quot;</span><br><span class="line">        git clone https://用户名:ghp_*私钥*@github.com/用户名/用户名.github.io.git .deploy_git</span><br><span class="line">        #修改为你的GitHub用户名邮箱</span><br><span class="line">        # 此处务必用HTTPS链接。SSH链接可能有权限报错的隐患,模仿</span><br><span class="line">        # =====注意.deploy_git前面有个空格=====</span><br><span class="line">        # 这行指令的目的是clone博客静态文件仓库，防止Hexo推送时覆盖整个静态文件仓库，而是只推送有更改的文件</span><br><span class="line">        hexo deploy</span><br></pre></td></tr></table></figure>
<ul>
<li>点击右上角<code>start commit</code>  &gt;  <code>commit new file</code></li>
</ul>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202302112149138.png" alt="image-20230211214945021"></p>
<ul>
<li>自动跳转到生成的文件下，点击上方actions，可查看部署情况</li>
</ul>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202302112151412.png" alt="image-20230211215151254"></p>
<ul>
<li>部署完成</li>
</ul>
<h2 id="bolg提交"><a href="#bolg提交" class="headerlink" title="bolg提交"></a>bolg提交</h2><blockquote>
<p>设置好自动提交后，无需<code>hexo clean; hexo g; hexo d</code>，只需要git提交blog文件到新建的仓库即可自动部署。</p>
</blockquote>
<ul>
<li>添加屏蔽项</li>
</ul>
<p>​        因为能够使用指令进行安装的内容不包括在需要提交的源码内，所有我们需要将这些内容添加到屏蔽项，表示不上传到github上。这样可以显著减少需要提交的文件量和加快提交速度。</p>
<p>​        打开<code>[Blogroot]/.gitignore</code>,输入以下内容：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules/</span><br><span class="line">public/</span><br><span class="line">.deploy*/</span><br><span class="line">.deploy_git*/</span><br><span class="line">.idea</span><br><span class="line">themes/butterfly/.git</span><br></pre></td></tr></table></figure>
<p>​        如果不是<code>butterfly</code>主题，记得替换最后一行内容为你自己当前使用的主题。</p>
<ul>
<li>提交源码到私有仓库<code>[SourceRepo]</code></li>
</ul>
<p>​        在博客根目录[Blogroot]下启动终端，使用git指令重设仓库地址。这样在新建仓库，我们仍旧可以保留珍贵的commit history，便于版本回滚。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/用户名/仓库名.git</span><br><span class="line">git remote <span class="built_in">rm</span> origin <span class="comment"># 删除原有仓库链接</span></span><br><span class="line">git remote add origin git@github.com:[GithubUsername]/[SourceRepo].git <span class="comment">#[SourceRepo]为新的存放源码的github私有仓库</span></span><br><span class="line">git checkout -b master <span class="comment"># 切换到master分支，</span></span><br><span class="line"><span class="comment">#2020年10月后github新建仓库默认分支改为main，注意更改</span></span><br><span class="line"><span class="comment"># 如果不是，后面的所有设置的分支记得保持一致</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;github action update&quot;</span></span><br><span class="line">git push origin master</span><br><span class="line"><span class="comment">#2020年10月后github新建仓库默认分支改为main，注意更改</span></span><br><span class="line"><span class="comment"># 强制更新</span></span><br><span class="line"><span class="comment"># git push -f origin main</span></span><br><span class="line"><span class="comment"># 同步下拉代码</span></span><br><span class="line"><span class="comment"># git pull origin main</span></span><br></pre></td></tr></table></figure>
<ul>
<li>可能遇到的bug</li>
</ul>
<p>​        因为<code>butterfly</code>主题文件夹下的<code>.git</code>文件夹的存在，那么主题文件夹会被识别子项目。从而无法被上传到源码仓库。若是遇到添加屏蔽项，但是还是无法正常上传主题文件夹的情况。请先将本地源码中的<code>themes</code>文件夹移动到别的目录下。然后<code>commit</code>一次。接着将<code>themes</code>文件夹移动回来，再<code>commit</code>一次。</p>
<p>​        要是还不行，那就删了<code>butterfly</code>主题文件夹下的<code>.git</code>文件夹，然后再重复上述的<code>commit</code>操作。</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>typora博客书写</title>
    <url>/link/a7d413aa.html</url>
    <content><![CDATA[<h1 id="typora博客书写"><a href="#typora博客书写" class="headerlink" title="typora博客书写"></a>typora博客书写</h1><blockquote>
<p>typora书写要想在blog中正常显示流程图等需要在主题的config文件中进行设置，或者需要自定义主题，本文主要记录书写过程中遇到的需要用到的模块，持续更新。</p>
</blockquote>
<h2 id="pdf"><a href="#pdf" class="headerlink" title="pdf"></a>pdf</h2><blockquote>
<p> <strong>全平台查看PDF解决方案</strong> ，来源<a href="https://cloud.tencent.com/developer/article/2065822">https://cloud.tencent.com/developer/article/2065822</a></p>
</blockquote>
<p>使用方法</p>
<ul>
<li>下载 pdf.js </li>
<li>官网地址：<a href="https://mozilla.github.io/pdf.js/">https://mozilla.github.io/pdf.js/</a> </li>
<li>新版本不支持部分浏览器，为了更好的兼容性，下载旧版本浏览器的文件包，点击 <code>Download</code> 按钮 </li>
</ul>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202302102245979.png" alt="img"></p>
<ul>
<li>下载并解压相关内容，使用 viewer.html 配合 iframe 插件查看pdf文件：</li>
<li>将pdfjs文件夹放到hexo中，使用相对路径使用</li>
</ul>
<blockquote>
<p> 建议放在hexo source文件夹并skip-render掉，这样可以主题无关地使用pdf阅读功能 </p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;iframe src=<span class="string">&#x27;/vvd_js/pdfjs/web/viewer.html?file=&lt;src-to-pdf&gt;&#x27;</span> style=<span class="string">&#x27;width:100%;height:100%&#x27;</span>&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用时会报错：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Error</span>: file origin does not match viewer<span class="string">&#x27;s</span></span><br></pre></td></tr></table></figure>
<ul>
<li>需要注释掉 <code>web/viewer.js</code> 文件中的相应内容：</li>
</ul>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202302102245810.png" alt="img"></p>
<h2 id="mermaid"><a href="#mermaid" class="headerlink" title="mermaid"></a>mermaid</h2><ul>
<li>butterfly主题中有mermaid设置，打开设置。</li>
<li>在md文件中，引用流图前加入以下代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% mermaid %&#125;</span><br><span class="line">&#123;% endmermaid %&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果有问题可使用安装命令<code>npm install --save hexo-filter-mermaid-diagrams</code></li>
</ul>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>pytorch nn.Module</title>
    <url>/link/ad092d40.html</url>
    <content><![CDATA[<h1 id="pytorch-nn-Module"><a href="#pytorch-nn-Module" class="headerlink" title="pytorch nn.Module"></a>pytorch nn.Module</h1><p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202302101913815.png" alt="PyTorch Releases Version 1.7 With New Features Like CUDA 11, New APIs ..."></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 前面有&gt;&gt;&gt; 为代码，没有&gt;&gt;&gt; 为运行结果</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> torch</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bn = nn.BatchNorm2d(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<h2 id="一-数据类型转换及数据转移方法"><a href="#一-数据类型转换及数据转移方法" class="headerlink" title="一. 数据类型转换及数据转移方法"></a>一. 数据类型转换及数据转移方法</h2><h3 id="1-数据转移cpu-gpu"><a href="#1-数据转移cpu-gpu" class="headerlink" title="1.数据转移cpu/gpu"></a>1.数据转移cpu/gpu</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将模型转移到指定的设备中运行，返回值为self</span></span><br><span class="line"><span class="comment"># cpu -- 数据转移到cpu中</span></span><br><span class="line"><span class="comment"># cuda -- 数据转移到gpu中，可通过device指定gpu</span></span><br><span class="line"><span class="comment"># xpu -- 数据转移到xpu中，可通过device指定xpu</span></span><br><span class="line"><span class="comment"># to_empty -- torch后续版本功能，将参数和缓冲区移动到指定设备而不复制存储</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bn.cpu()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bn.cuda()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bn.xpu()</span><br><span class="line">BatchNorm2d(<span class="number">3</span>, eps=<span class="number">1e-05</span>, momentum=<span class="number">0.1</span>, affine=<span class="literal">True</span>, track_running_stats=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<h3 id="2-数据类型转换"><a href="#2-数据类型转换" class="headerlink" title="2.数据类型转换"></a>2.数据类型转换</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将模型的参数转换为指定的类型，均为浮点数的转换，不能转换int类型的数据,返回值为self</span></span><br><span class="line"><span class="comment"># bfloat16 -- 占用更少的空间，但相应的精度下降，更详细的解释https://mp.weixin.qq.com/s/eHeewCAO0noD2d-dXWidMA</span></span><br><span class="line"><span class="comment"># half -- 浮点数类型float16，对比bfloat16占用空间更多，但精度更高</span></span><br><span class="line"><span class="comment"># float -- 浮点数类型float32</span></span><br><span class="line"><span class="comment"># double -- 浮点数类型float64</span></span><br><span class="line"><span class="comment"># type -- 传入参数为数据类型，可进行int和float类型的转换</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bn.bfloat16()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bn.half()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bn.<span class="built_in">float</span>()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bn.double()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bn.<span class="built_in">type</span>(torch.<span class="built_in">float</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bn.<span class="built_in">type</span>(torch.<span class="built_in">int</span>)</span><br><span class="line">BatchNorm2d(<span class="number">3</span>, eps=<span class="number">1e-05</span>, momentum=<span class="number">0.1</span>, affine=<span class="literal">True</span>, track_running_stats=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 上面是整个模型的方法，下面是数据的方法</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bn.weight.bfloat16()</span><br><span class="line">tensor([<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>], device=<span class="string">&#x27;cuda:0&#x27;</span>, dtype=torch.bfloat16,</span><br><span class="line">       grad_fn=&lt;CopyBackwards&gt;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bn.weight.half()</span><br><span class="line">tensor([<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>], device=<span class="string">&#x27;cuda:0&#x27;</span>, dtype=torch.float16,</span><br><span class="line">       grad_fn=&lt;CopyBackwards&gt;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bn.weight.<span class="built_in">float</span>()</span><br><span class="line">Parameter containing:</span><br><span class="line">tensor([<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>], device=<span class="string">&#x27;cuda:0&#x27;</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bn.weight.double()</span><br><span class="line">tensor([<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>], device=<span class="string">&#x27;cuda:0&#x27;</span>, dtype=torch.float64,</span><br><span class="line">       grad_fn=&lt;CopyBackwards&gt;)</span><br></pre></td></tr></table></figure>
<h3 id="3-通用方法to-args-kwargs"><a href="#3-通用方法to-args-kwargs" class="headerlink" title="3.通用方法to(*args, **kwargs)"></a>3.通用方法to(<em>*args</em>, **kwargs)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 能够修改数据类型以及进行数据转移</span></span><br><span class="line"><span class="comment"># 修改数据类型 to(`数据类型`)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>linear = nn.Linear(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>linear.weight</span><br><span class="line">Parameter containing:</span><br><span class="line">tensor([[ <span class="number">0.1913</span>, -<span class="number">0.3420</span>],</span><br><span class="line">        [-<span class="number">0.5113</span>, -<span class="number">0.2325</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>linear.to(torch.double)</span><br><span class="line">Linear(in_features=<span class="number">2</span>, out_features=<span class="number">2</span>, bias=<span class="literal">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>linear.weight</span><br><span class="line">Parameter containing:</span><br><span class="line">tensor([[ <span class="number">0.1913</span>, -<span class="number">0.3420</span>],</span><br><span class="line">        [-<span class="number">0.5113</span>, -<span class="number">0.2325</span>]], dtype=torch.float64)</span><br><span class="line"><span class="comment"># 数据转移 to(`gpu/cpu/xpu`,dtype=`数据类型`,non_blocking=True)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gpu1 = torch.device(<span class="string">&quot;cuda:1&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>linear.to(gpu1, dtype=torch.half, non_blocking=<span class="literal">True</span>)</span><br><span class="line">Linear(in_features=<span class="number">2</span>, out_features=<span class="number">2</span>, bias=<span class="literal">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>linear.weight</span><br><span class="line">Parameter containing:</span><br><span class="line">tensor([[ <span class="number">0.1914</span>, -<span class="number">0.3420</span>],</span><br><span class="line">        [-<span class="number">0.5112</span>, -<span class="number">0.2324</span>]], dtype=torch.float16, device=<span class="string">&#x27;cuda:1&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="二-模型以及网络参数的查看及调整"><a href="#二-模型以及网络参数的查看及调整" class="headerlink" title="二.模型以及网络参数的查看及调整"></a>二.模型以及网络参数的查看及调整</h2><h3 id="1-children和module"><a href="#1-children和module" class="headerlink" title="1.children和module"></a>1.children和module</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 涉及方法有children(),module(),named_children(),named_module()</span></span><br><span class="line"><span class="comment"># 两者都是返回模型的网络结构，但childrens返回的是表层的结构，而modules返回的是一层一层分解的结构</span></span><br><span class="line"><span class="comment"># 例如：有一数组 [1,2,[3,3,4]]</span></span><br><span class="line"><span class="comment"># childerns返回值为：1,2,[3,3,4]</span></span><br><span class="line"><span class="comment"># modules返回值为：[1,2,[3,3,4]],1,2,[3,3,4],3,3,4 若两个3为同一实例则只显示一次</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>conv1 = nn.Conv2d(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mod1 = nn.Sequential(conv1,nn.ReLU(),nn.Sequential(conv1,nn.ReLU()))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> idx,mod <span class="keyword">in</span> <span class="built_in">enumerate</span>(mod1.children()):</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    <span class="built_in">print</span>(idx,<span class="string">&#x27;--&gt;&#x27;</span>,mod)</span><br><span class="line"><span class="number">0</span> --&gt; Conv2d(<span class="number">2</span>, <span class="number">2</span>, kernel_size=(<span class="number">2</span>, <span class="number">2</span>), stride=(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line"><span class="number">1</span> --&gt; ReLU()</span><br><span class="line"><span class="number">2</span> --&gt; Sequential(</span><br><span class="line">  (<span class="number">0</span>): Conv2d(<span class="number">2</span>, <span class="number">2</span>, kernel_size=(<span class="number">2</span>, <span class="number">2</span>), stride=(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">  (<span class="number">1</span>): ReLU()</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 只展示了最外层的结构</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> idx,mod <span class="keyword">in</span> <span class="built_in">enumerate</span>(mod1.modules()):</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    <span class="built_in">print</span>(idx,<span class="string">&#x27;--&gt;&#x27;</span>,mod)</span><br><span class="line"><span class="number">0</span> --&gt; Sequential(</span><br><span class="line">  (<span class="number">0</span>): Conv2d(<span class="number">2</span>, <span class="number">2</span>, kernel_size=(<span class="number">2</span>, <span class="number">2</span>), stride=(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">  (<span class="number">1</span>): ReLU()</span><br><span class="line">  (<span class="number">2</span>): Sequential(</span><br><span class="line">    (<span class="number">0</span>): Conv2d(<span class="number">2</span>, <span class="number">2</span>, kernel_size=(<span class="number">2</span>, <span class="number">2</span>), stride=(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">    (<span class="number">1</span>): ReLU()</span><br><span class="line">  )</span><br><span class="line">)</span><br><span class="line"><span class="number">1</span> --&gt; Conv2d(<span class="number">2</span>, <span class="number">2</span>, kernel_size=(<span class="number">2</span>, <span class="number">2</span>), stride=(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line"><span class="number">2</span> --&gt; ReLU()</span><br><span class="line"><span class="number">3</span> --&gt; Sequential(</span><br><span class="line">  (<span class="number">0</span>): Conv2d(<span class="number">2</span>, <span class="number">2</span>, kernel_size=(<span class="number">2</span>, <span class="number">2</span>), stride=(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">  (<span class="number">1</span>): ReLU()</span><br><span class="line">)</span><br><span class="line"><span class="number">4</span> --&gt; ReLU()</span><br><span class="line"><span class="comment"># 展示每一层的结构</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> idx,mod <span class="keyword">in</span> <span class="built_in">enumerate</span>(mod1.named_children()):</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    <span class="built_in">print</span>(idx,<span class="string">&#x27;--&gt;&#x27;</span>,mod)</span><br><span class="line"><span class="number">0</span> --&gt; (<span class="string">&#x27;0&#x27;</span>, Conv2d(<span class="number">2</span>, <span class="number">2</span>, kernel_size=(<span class="number">2</span>, <span class="number">2</span>), stride=(<span class="number">1</span>, <span class="number">1</span>)))</span><br><span class="line"><span class="number">1</span> --&gt; (<span class="string">&#x27;1&#x27;</span>, ReLU())</span><br><span class="line"><span class="number">2</span> --&gt; (<span class="string">&#x27;2&#x27;</span>, Sequential(</span><br><span class="line">  (<span class="number">0</span>): Conv2d(<span class="number">2</span>, <span class="number">2</span>, kernel_size=(<span class="number">2</span>, <span class="number">2</span>), stride=(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">  (<span class="number">1</span>): ReLU()</span><br><span class="line">))</span><br><span class="line"><span class="comment"># 展示最外层的名称及结构</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> idx,mod <span class="keyword">in</span> <span class="built_in">enumerate</span>(mod1.named_modules()):</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    <span class="built_in">print</span>(idx,<span class="string">&#x27;--&gt;&#x27;</span>,mod)</span><br><span class="line"><span class="number">0</span> --&gt; (<span class="string">&#x27;&#x27;</span>, Sequential(</span><br><span class="line">  (<span class="number">0</span>): Conv2d(<span class="number">2</span>, <span class="number">2</span>, kernel_size=(<span class="number">2</span>, <span class="number">2</span>), stride=(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">  (<span class="number">1</span>): ReLU()</span><br><span class="line">  (<span class="number">2</span>): Sequential(</span><br><span class="line">    (<span class="number">0</span>): Conv2d(<span class="number">2</span>, <span class="number">2</span>, kernel_size=(<span class="number">2</span>, <span class="number">2</span>), stride=(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">    (<span class="number">1</span>): ReLU()</span><br><span class="line">  )</span><br><span class="line">))</span><br><span class="line"><span class="number">1</span> --&gt; (<span class="string">&#x27;0&#x27;</span>, Conv2d(<span class="number">2</span>, <span class="number">2</span>, kernel_size=(<span class="number">2</span>, <span class="number">2</span>), stride=(<span class="number">1</span>, <span class="number">1</span>)))</span><br><span class="line"><span class="number">2</span> --&gt; (<span class="string">&#x27;1&#x27;</span>, ReLU())</span><br><span class="line"><span class="number">3</span> --&gt; (<span class="string">&#x27;2&#x27;</span>, Sequential(</span><br><span class="line">  (<span class="number">0</span>): Conv2d(<span class="number">2</span>, <span class="number">2</span>, kernel_size=(<span class="number">2</span>, <span class="number">2</span>), stride=(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">  (<span class="number">1</span>): ReLU()</span><br><span class="line">))</span><br><span class="line"><span class="number">4</span> --&gt; (<span class="string">&#x27;2.1&#x27;</span>, ReLU())</span><br><span class="line"><span class="comment"># 展示每一层的名称及结构</span></span><br></pre></td></tr></table></figure>
<h3 id="2-buffers和parameters"><a href="#2-buffers和parameters" class="headerlink" title="2.buffers和parameters"></a>2.buffers和parameters</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 涉及方法有buffers(),parameters(),named_buffers(),named_parameters()</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> bn.buffers():</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    <span class="built_in">print</span>(i)</span><br><span class="line">tensor([<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>])</span><br><span class="line">tensor([<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>])</span><br><span class="line">tensor(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 不输出buffers的名称</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> bn.parameters():</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    <span class="built_in">print</span>(i)</span><br><span class="line">Parameter containing:</span><br><span class="line">tensor([<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>], requires_grad=<span class="literal">True</span>)</span><br><span class="line">Parameter containing:</span><br><span class="line">tensor([<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>], requires_grad=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 不输出parameters的名称</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(bn.named_buffers())</span><br><span class="line">[(<span class="string">&#x27;running_mean&#x27;</span>, tensor([<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>])),</span><br><span class="line"> (<span class="string">&#x27;running_var&#x27;</span>, tensor([<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>])),</span><br><span class="line"> (<span class="string">&#x27;num_batches_tracked&#x27;</span>, tensor(<span class="number">0</span>))]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(bn.named_parameters())</span><br><span class="line">[(<span class="string">&#x27;weight&#x27;</span>,</span><br><span class="line">  Parameter containing:</span><br><span class="line">  tensor([<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>], requires_grad=<span class="literal">True</span>)),</span><br><span class="line"> (<span class="string">&#x27;bias&#x27;</span>,</span><br><span class="line">  Parameter containing:</span><br><span class="line">  tensor([<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>], requires_grad=<span class="literal">True</span>))]</span><br><span class="line"><span class="comment"># 输出名称需要使用named_buffers(),named_parameters()</span></span><br><span class="line"><span class="comment"># 两者唯一的区别是，buffer不需要梯度不被优化，parameter需要梯度可以被优化</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bn.running_mean.requiers_grad</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bn.weight.requiers_grad</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="comment"># 上面用batchnorm层来展示区别，但两者都能够看做是attribute</span></span><br><span class="line"><span class="comment"># 导出state_dict</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(bn.state_dict())</span><br><span class="line">[<span class="string">&#x27;weight&#x27;</span>, <span class="string">&#x27;bias&#x27;</span>, <span class="string">&#x27;running_mean&#x27;</span>, <span class="string">&#x27;running_var&#x27;</span>, <span class="string">&#x27;num_batches_tracked&#x27;</span>]</span><br></pre></td></tr></table></figure>
<h3 id="3-模型结构和数据的增删改"><a href="#3-模型结构和数据的增删改" class="headerlink" title="3.模型结构和数据的增删改"></a>3.模型结构和数据的增删改</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 涉及的方法有add_module(),register_buffers(),register_parameter()</span></span><br><span class="line"><span class="comment"># 添加模型的module</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>model = nn.Sequential()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>model.add_module(<span class="string">&#x27;1&#x27;</span>, nn.Conv2d(<span class="number">12</span>,<span class="number">12</span>,<span class="number">12</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(model)</span><br><span class="line">Sequential(</span><br><span class="line">  (<span class="number">1</span>): Conv2d(<span class="number">12</span>, <span class="number">12</span>, kernel_size=(<span class="number">12</span>, <span class="number">12</span>), stride=(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 添加模型的buffer</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(bn.named_buffers())</span><br><span class="line">[(<span class="string">&#x27;running_mean&#x27;</span>, tensor([<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>])),</span><br><span class="line"> (<span class="string">&#x27;running_var&#x27;</span>, tensor([<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>])),</span><br><span class="line"> (<span class="string">&#x27;num_batches_tracked&#x27;</span>, tensor(<span class="number">0</span>))]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bn.register_buffer(<span class="string">&#x27;1&#x27;</span>, torch.tensor([<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>]))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(bn.named_buffers())</span><br><span class="line">[(<span class="string">&#x27;running_mean&#x27;</span>, tensor([<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>])),</span><br><span class="line"> (<span class="string">&#x27;running_var&#x27;</span>, tensor([<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>])),</span><br><span class="line"> (<span class="string">&#x27;num_batches_tracked&#x27;</span>, tensor(<span class="number">0</span>)),</span><br><span class="line"> (<span class="string">&#x27;1&#x27;</span>, tensor([<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>]))]</span><br><span class="line"><span class="comment"># 添加模型的parameter</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(bn.named_parameters())</span><br><span class="line">[(<span class="string">&#x27;weight&#x27;</span>,</span><br><span class="line">  Parameter containing:</span><br><span class="line">  tensor([<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>], requires_grad=<span class="literal">True</span>)),</span><br><span class="line"> (<span class="string">&#x27;bias&#x27;</span>,</span><br><span class="line">  Parameter containing:</span><br><span class="line">  tensor([<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>], requires_grad=<span class="literal">True</span>))]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bn.register_parameter(<span class="string">&#x27;2&#x27;</span>,torch.nn.Parameter(torch.tensor([<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>])))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(bn.named_parameters())</span><br><span class="line">[(<span class="string">&#x27;weight&#x27;</span>,</span><br><span class="line">  Parameter containing:</span><br><span class="line">  tensor([<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>], requires_grad=<span class="literal">True</span>)),</span><br><span class="line"> (<span class="string">&#x27;bias&#x27;</span>,</span><br><span class="line">  Parameter containing:</span><br><span class="line">  tensor([<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>], requires_grad=<span class="literal">True</span>)),</span><br><span class="line"> (<span class="string">&#x27;2&#x27;</span>,</span><br><span class="line">  Parameter containing:</span><br><span class="line">  tensor([<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>], requires_grad=<span class="literal">True</span>))]</span><br><span class="line"><span class="comment"># register_parameter()的参数为torch.nn.Parameter类型</span></span><br><span class="line"><span class="comment"># 在日常的代码开发过程中，更常见的用法是直接通过 self.xxx = xxx 的方式来增加或修改子神经网络模块、parameters、buffers 以及其他一般的 attribute。这种方式本质上会调用 nn.Module 重载的函数 __setattr__ </span></span><br><span class="line"><span class="comment"># 修改bn的weight的数值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bn.weight.data = torch.zeros(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bn.weight</span><br><span class="line">Parameter containing:</span><br><span class="line">tensor([<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>], requires_grad=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 删除某个buffer或parameter,当做attribute删除</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">delattr</span>(bn, <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(bn.named_parameters())</span><br><span class="line">[(<span class="string">&#x27;weight&#x27;</span>,</span><br><span class="line">  Parameter containing:</span><br><span class="line">  tensor([<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>])),</span><br><span class="line"> (<span class="string">&#x27;bias&#x27;</span>,</span><br><span class="line">  Parameter containing:</span><br><span class="line">  tensor([<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>]))]</span><br></pre></td></tr></table></figure>
<h3 id="4-模型与梯度初始化"><a href="#4-模型与梯度初始化" class="headerlink" title="4.模型与梯度初始化"></a>4.模型与梯度初始化</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 涉及方法有apply(),zero_grad(),requires_grad_()</span></span><br><span class="line"><span class="comment"># apply -- 一般用于初始化模型</span></span><br><span class="line"><span class="comment"># zero_grad -- 将模型所有参数的梯度设置为零</span></span><br><span class="line"><span class="comment"># requires_grad_ -- 梯度启动，梯度禁用，用于冻结某个层</span></span><br><span class="line"><span class="comment"># 将linear层权重全部设为1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">init_weight</span>(<span class="params">m</span>):</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    <span class="built_in">print</span>(m)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    <span class="keyword">if</span> <span class="built_in">type</span>(m) == nn.Linear:</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>        m.weight.fill_(<span class="number">1.0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>        <span class="built_in">print</span>(m.weight)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>net = nn.Sequential(nn.Linear(<span class="number">2</span>, <span class="number">2</span>), nn.Linear(<span class="number">2</span>, <span class="number">2</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>net.apply(init_weights)</span><br><span class="line">Linear(in_features=<span class="number">2</span>, out_features=<span class="number">2</span>, bias=<span class="literal">True</span>)</span><br><span class="line">Parameter containing:</span><br><span class="line">tensor([[<span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">1.</span>]], requires_grad=<span class="literal">True</span>)</span><br><span class="line">Linear(in_features=<span class="number">2</span>, out_features=<span class="number">2</span>, bias=<span class="literal">True</span>)</span><br><span class="line">Parameter containing:</span><br><span class="line">tensor([[<span class="number">1.</span>, <span class="number">1</span></span><br><span class="line">        [<span class="number">1.</span>, <span class="number">1.</span>]], requires_grad=<span class="literal">True</span>)   </span><br><span class="line">Sequential(</span><br><span class="line">  (<span class="number">0</span>): Linear(in_features=<span class="number">2</span>, out_features=<span class="number">2</span>, bias=<span class="literal">True</span>)</span><br><span class="line">  (<span class="number">1</span>): Linear(in_features=<span class="number">2</span>, out_features=<span class="number">2</span>, bias=<span class="literal">True</span>)</span><br><span class="line">)</span><br><span class="line">Sequential(</span><br><span class="line">  (<span class="number">0</span>): Linear(in_features=<span class="number">2</span>, out_features=<span class="number">2</span>, bias=<span class="literal">True</span>)</span><br><span class="line">  (<span class="number">1</span>): Linear(in_features=<span class="number">2</span>, out_features=<span class="number">2</span>, bias=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 根据结果可以看出该方法，首先将网络结构每一层传入分析层的内容，然后将整个网络传入，最后返回整个网络的信息</span></span><br><span class="line"><span class="comment"># 将模型的参数梯度设为0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bn.zero_grad()    </span><br><span class="line"><span class="comment"># 当在定义一个tensor的时候并且将requires_grad设置为True,这个tensor就拥有自动求梯度    </span></span><br><span class="line"><span class="comment"># 梯度的禁用与启用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bn.weight</span><br><span class="line">Parameter containing:</span><br><span class="line">tensor([<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>], requires_grad=<span class="literal">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bn.requires_grad_(requires_grad = <span class="literal">False</span>)</span><br><span class="line">BatchNorm2d(<span class="number">3</span>, eps=<span class="number">1e-05</span>, momentum=<span class="number">0.1</span>, affine=<span class="literal">True</span>, track_running_stats=<span class="literal">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bn.weight</span><br><span class="line">Parameter containing:</span><br><span class="line">tensor([<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>])</span><br><span class="line"><span class="comment"># 梯度已禁用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bn.requires_grad_(requires_grad = <span class="literal">True</span>)</span><br><span class="line">BatchNorm2d(<span class="number">3</span>, eps=<span class="number">1e-05</span>, momentum=<span class="number">0.1</span>, affine=<span class="literal">True</span>, track_running_stats=<span class="literal">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bn.weight</span><br><span class="line">Parameter containing:</span><br><span class="line">tensor([<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>], requires_grad=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 梯度已启用    </span></span><br></pre></td></tr></table></figure>
<h3 id="5-获取指定模型参数的值"><a href="#5-获取指定模型参数的值" class="headerlink" title="5.获取指定模型参数的值"></a>5.获取指定模型参数的值</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 涉及的主要方法有 get_buffer(),get_parameter(),get_submodule()</span></span><br><span class="line"><span class="comment"># 旧版本可能无法使用</span></span><br><span class="line"><span class="comment"># 获取指定buffer的值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bn.get_buffer(<span class="string">&quot;running_mean&quot;</span>)</span><br><span class="line">tensor([<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>])</span><br><span class="line"><span class="comment"># 获取指定parameter的值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bn.get_parameter(<span class="string">&quot;weight&quot;</span>)</span><br><span class="line">tensor([<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>], requires_grad=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 获取指定子模块的值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mod = nn.Sequential()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mod1 = nn.Sequential(nn.Conv2d(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>),nn.Conv2d(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mod.add_module(<span class="string">&quot;1&quot;</span>,mod1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mod.get_submodule(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">Sequential(</span><br><span class="line">  (<span class="number">0</span>): Conv2d(<span class="number">2</span>, <span class="number">2</span>, kernel_size=(<span class="number">2</span>, <span class="number">2</span>), stride=(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">  (<span class="number">1</span>): Conv2d(<span class="number">2</span>, <span class="number">2</span>, kernel_size=(<span class="number">2</span>, <span class="number">2</span>), stride=(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="三-模型的训练"><a href="#三-模型的训练" class="headerlink" title="三.模型的训练"></a>三.模型的训练</h2><h3 id="1-前向和反向传播"><a href="#1-前向和反向传播" class="headerlink" title="1.前向和反向传播"></a>1.前向和反向传播</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 虽然模型有forward()方法，但一般forward是定义自己的子类时，必须重写的，是实现各个层之间的连接关系的核心</span></span><br><span class="line"><span class="comment"># 只要在nn.Module的子类中定义了forward函数，backward函数就会利用autograd自动实现</span></span><br><span class="line"><span class="comment"># forward方法，不需要单独调用，直接传入参数后即可自动调用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LeNet</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(LeNet,self).__init__()</span><br><span class="line">        layer1 = nn.Sequential()</span><br><span class="line">        layer1.add_module(<span class="string">&#x27;conv1&#x27;</span>, nn.Conv2d(<span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>, padding=<span class="number">1</span>))</span><br><span class="line">        layer1.add_module(<span class="string">&#x27;pool1&#x27;</span>, nn.MaxPool2d(<span class="number">2</span>, <span class="number">2</span>))</span><br><span class="line">        self.layer1 = layer1</span><br><span class="line"></span><br><span class="line">        layer2 = nn.Sequential()</span><br><span class="line">        layer2.add_module(<span class="string">&#x27;conv2&#x27;</span>, nn.Conv2d(<span class="number">6</span>, <span class="number">16</span>, <span class="number">5</span>))</span><br><span class="line">        layer2.add_module(<span class="string">&#x27;pool2&#x27;</span>, nn.MaxPool2d(<span class="number">2</span>, <span class="number">2</span>))</span><br><span class="line">        self.layer2 = layer2</span><br><span class="line"></span><br><span class="line">        layer3 = nn.Sequential()</span><br><span class="line">        layer3.add_module(<span class="string">&#x27;fc1&#x27;</span>, nn.Linear(<span class="number">400</span>, <span class="number">120</span>))</span><br><span class="line">        layer3.add_module(<span class="string">&#x27;fc2&#x27;</span>, nn.Linear(<span class="number">120</span>, <span class="number">84</span>))</span><br><span class="line">        layer3.add_module(<span class="string">&#x27;fc3&#x27;</span>, nn.Linear(<span class="number">84</span>, <span class="number">10</span>))</span><br><span class="line">        self.layer3 = layer3</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,x</span>):</span><br><span class="line">        x = self.layer1(x)</span><br><span class="line">        x = self.layer2(x)</span><br><span class="line">        x = x.view(x.size(<span class="number">0</span>), -<span class="number">1</span>)</span><br><span class="line">        x = self.layer3(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">module = LeNet()</span><br><span class="line">module(x)  </span><br><span class="line"><span class="comment"># 向模型中传入数据即可自动调用forward方法，以及使用自动梯度进行backward </span></span><br></pre></td></tr></table></figure>
<h3 id="2-模型训练和评估"><a href="#2-模型训练和评估" class="headerlink" title="2.模型训练和评估"></a>2.模型训练和评估</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># train(),eval()和torch.no_gard()</span></span><br><span class="line"><span class="comment"># model.train()和model.eval()的区别主要在于Batch Normalization和Dropout两层</span></span><br><span class="line"><span class="comment"># 训练前需要调用train(),测试前需要调用eval()来锁定</span></span><br><span class="line"><span class="comment"># 在train模式下，dropout网络层会按照设定的参数p，设置保留激活单元的概率（保留概率=p)。BN层会继续计算数据的mean和var等参数并更新。</span></span><br><span class="line"><span class="comment"># 在eval模式下，dropout层会让所有的激活单元都通过，而BN层会停止计算和更新mean和var，直接使用在训练阶段已经学出的mean和var值。</span></span><br><span class="line"><span class="comment"># eval模式不会影响各层的gradient计算行为，即gradient计算和存储与training模式一样，只是不进行反向传播（back probagation)。</span></span><br><span class="line"><span class="comment"># with torch.no_grad()则主要是用于停止autograd模块的工作，以起到加速和节省显存的作用。它的作用是将该with语句包裹起来的部分停止梯度的更新，从而节省了GPU算力和显存，但是并不会影响dropout和BN层的行为。</span></span><br><span class="line"><span class="comment"># ps：参考连接：https://blog.csdn.net/qq_38410428/article/details/101102075</span></span><br></pre></td></tr></table></figure>
<h3 id="3-HOOK——获取神经网络特征和梯度的有效工具"><a href="#3-HOOK——获取神经网络特征和梯度的有效工具" class="headerlink" title="3.HOOK——获取神经网络特征和梯度的有效工具"></a>3.HOOK——获取神经网络特征和梯度的有效工具</h3><blockquote>
<p>参考链接：<a href="https://www.jianshu.com/p/69e57e3526b3，https://www.jb51.net/article/240198.htm">https://www.jianshu.com/p/69e57e3526b3，https://www.jb51.net/article/240198.htm</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 涉及的方法有register_forward_hook(),register_forward_pre_hook(),register_backward_hook(),register_full_backward_hook()</span></span><br><span class="line"><span class="comment"># 在模型训练过程中，对于模型的中间模块，可以看做为中间节点，输出为特征图或者激活值，反向传播的梯度值会被自动释放，想要获取他们，需要用到hook功能</span></span><br><span class="line"><span class="comment"># register_forward_hook是获取前向传播的输出的，即特征图或激活值；register_backward_hook是获取反向传播的输出的，即梯度值。</span></span><br><span class="line"><span class="comment"># hook的内部原理比较复杂，但使用简单</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="四-模型的保存读取"><a href="#四-模型的保存读取" class="headerlink" title="四.模型的保存读取"></a>四.模型的保存读取</h2><h3 id="1-模型保存"><a href="#1-模型保存" class="headerlink" title="1.模型保存"></a>1.模型保存</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># state_dict()能够返回模型的参数到一个字典</span></span><br><span class="line"><span class="comment"># 模型的参数保存</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bn.state_dict()</span><br><span class="line">OrderedDict([(<span class="string">&#x27;weight&#x27;</span>, tensor([<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>])),</span><br><span class="line">             (<span class="string">&#x27;bias&#x27;</span>, tensor([<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>])),</span><br><span class="line">             (<span class="string">&#x27;running_mean&#x27;</span>, tensor([<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>])),</span><br><span class="line">             (<span class="string">&#x27;running_var&#x27;</span>, tensor([<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>])),</span><br><span class="line">             (<span class="string">&#x27;num_batches_tracked&#x27;</span>, tensor(<span class="number">0</span>))])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.save(bn.state_dict(), <span class="string">&quot;mod&quot;</span>)</span><br><span class="line"><span class="comment"># PATH为字符串类型，模型保存在指定路径下</span></span><br><span class="line"><span class="comment"># PS：可以直接保存模型到PATH</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.save(bn, <span class="string">&quot;mod1&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="2-模型加载"><a href="#2-模型加载" class="headerlink" title="2.模型加载"></a>2.模型加载</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># load_state_dict()能够读取状态字典的数据并载入模型</span></span><br><span class="line"><span class="comment"># 修改模型中weight的数值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bn.weight.data = torch.zeros(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bn.weight</span><br><span class="line">Parameter containing:</span><br><span class="line">tensor([<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>], requires_grad=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 导入保存好的模型参数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bn.load_state_dict(torch.load(<span class="string">&quot;mod&quot;</span>))</span><br><span class="line">&lt;All keys matched successfully&gt;</span><br><span class="line"><span class="comment"># 查看导入参数后的weight的数值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bn.weight</span><br><span class="line">Parameter containing:</span><br><span class="line">tensor([<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>], requires_grad=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># PS：可以直接读取保存好的模型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bn1 = torch.load(<span class="string">&quot;mod1&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bn1</span><br><span class="line">BatchNorm2d(<span class="number">3</span>, eps=<span class="number">1e-05</span>, momentum=<span class="number">0.1</span>, affine=<span class="literal">True</span>, track_running_stats=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<h3 id="3-旧版本兼容"><a href="#3-旧版本兼容" class="headerlink" title="3.旧版本兼容"></a>3.旧版本兼容</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.nn.Module.dump_patches = <span class="literal">True</span> </span><br><span class="line"><span class="comment"># 使用时直接设定值，主要用于再导入之前版本的参数数据时，有更好的兼容性</span></span><br></pre></td></tr></table></figure>
<h3 id="4-额外状态的保存读取"><a href="#4-额外状态的保存读取" class="headerlink" title="4.额外状态的保存读取"></a>4.额外状态的保存读取</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 新版本功能,待使用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>set_extra_state(state)</span><br><span class="line"><span class="comment"># 调用此函数load_state_dict()以处理在state_dict中找到的任何额外状态。如果您需要在其 state_dictget_extra_state()中存储额外的状态，请为您的模块实现此功能和对应的功能。参数：state ( dict ) -- 来自state_dict的额外状态</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>get_extra_state()</span><br><span class="line"><span class="comment"># 返回要包含在模块state_dict 中的任何额外状态。 如果您需要存储额外的状态set_extra_state()，请为您的模块实现此功能和相应功能。构建模块的state_dict()时调用此函数。</span></span><br></pre></td></tr></table></figure>
<h2 id="五-其他方法"><a href="#五-其他方法" class="headerlink" title="五.其他方法"></a>五.其他方法</h2><h3 id="1-extra-repr"><a href="#1-extra-repr" class="headerlink" title="1.extra_repr()"></a>1.extra_repr()</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 该方法需要在类中自己定义,用来添加信息</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">create_net</span>(nn.Module):</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>        <span class="built_in">super</span>().__init__()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>        self.net_model = nn.BatchNorm2d(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>        out = self.net_model(x)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>        <span class="keyword">return</span> out</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    <span class="keyword">def</span> <span class="title function_">extra_repr</span>(<span class="params">self</span>):</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>        <span class="comment"># print(&#x27;extra_repr方法正在被调用...&#x27;)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>        <span class="keyword">return</span> <span class="string">&#x27;我是用户自定义的神经网络模块...&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>model = create_net()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>model</span><br><span class="line">create_net(</span><br><span class="line">  我是用户自定义的神经网络模块...</span><br><span class="line">  (net_model): BatchNorm2d(<span class="number">3</span>, eps=<span class="number">1e-05</span>, momentum=<span class="number">0.1</span>, affine=<span class="literal">True</span>, track_running_stats=<span class="literal">True</span>)</span><br><span class="line">)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>model.extra_repr()</span><br><span class="line"><span class="string">&#x27;我是用户自定义的神经网络模块...&#x27;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>jetson nano b01使用准备</title>
    <url>/link/52986632.html</url>
    <content><![CDATA[<h1 id="jetson-nano-b01使用准备"><a href="#jetson-nano-b01使用准备" class="headerlink" title="jetson nano b01使用准备"></a>jetson nano b01使用准备</h1><h2 id="镜像烧录"><a href="#镜像烧录" class="headerlink" title="镜像烧录"></a>镜像烧录</h2><blockquote>
<p>不同的第三方载板有不同的烧录方案，使用的为米文动力的载板，安装的为jetpac4.6版本系统，按照官方文档进行烧录。</p>
</blockquote>
<p><a href="http://doc.miivii.com/6717496.html#LiteNanoMini%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C-%E9%99%842.FlashTools%EF%BC%88%E5%88%B7%E6%9C%BA%E5%B7%A5%E5%85%B7%EF%BC%89ReleaseNote">http://doc.miivii.com/6717496.html#LiteNanoMini%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C-%E9%99%842.FlashTools%EF%BC%88%E5%88%B7%E6%9C%BA%E5%B7%A5%E5%85%B7%EF%BC%89ReleaseNote</a></p>
<h2 id="迁移系统到SSD"><a href="#迁移系统到SSD" class="headerlink" title="迁移系统到SSD"></a>迁移系统到SSD</h2><blockquote>
<p>开发板自带的16GB的内存比较小，在安装SSD后可将系统迁移至SSD中，参考<a href="https://blog.csdn.net/m0_53408051/article/details/127655853">https://blog.csdn.net/m0_53408051/article/details/127655853</a></p>
</blockquote>
<ul>
<li>先把nvme硬盘分区为Ext4，使用disks程序，找到安装好的SSD盘，右上角点击格式化硬盘为GPT格式，格式化后点击容量显示的左下角的加号，新加一个分区，结束后分区名显示应为p1结尾。</li>
<li>再下载压缩包: <code>git clone https://github.com/jetsonhacks/rootOnNVMe.git</code></li>
<li>解压后， <code>cd rootOnNVMe</code>  进入目录，<code>./copy-rootfs-ssd.sh</code>   执行复制脚本</li>
<li>安装启动脚本：<code>./setup-service.sh</code>  将rootfs设置为NVME，<code>sudo reboot</code>  重启</li>
</ul>
<p>重启之后，则可看到你的新的机子的空间变为SD卡或者SSD的空间大小，原有的空间变成了一个盘（不要删除它，否则会出事）</p>
<p>PS：<strong>git clone出现 fatal: unable to access解决方案</strong></p>
<p>终端执行  <code>git config --global http.proxy</code>  以及  <code>git config --global http.proxy</code></p>
<h2 id="安装常用模块"><a href="#安装常用模块" class="headerlink" title="安装常用模块"></a>安装常用模块</h2><blockquote>
<p>一些模块的安装可以帮助后续更好的使用，参考<a href="https://blog.csdn.net/IamYZD/article/details/119618950">https://blog.csdn.net/IamYZD/article/details/119618950</a></p>
</blockquote>
<h3 id="apt换源"><a href="#apt换源" class="headerlink" title="apt换源"></a>apt换源</h3><ul>
<li>备份</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class="line">sudo gedit /etc/apt/sources.list</span><br></pre></td></tr></table></figure>
<ul>
<li>删除所有内容，下面提供了国内几个支持arm64架构的Ubuntu镜像源，任选其一，写入文档：</li>
</ul>
<p>清华大学镜像源：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-updates main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-updates main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-backports main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-backports main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-security main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-security main restricted universe multiverse</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 预发布软件源，不建议启用</span></span><br><span class="line"><span class="comment"># deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-proposed main restricted universe multiverse</span></span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ bionic-proposed main restricted universe multiverse</span></span><br></pre></td></tr></table></figure>
<p>中国科学技术大学镜像源：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span></span><br><span class="line">deb http://mirrors.ustc.edu.cn/ubuntu-ports bionic main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src http://mirrors.ustc.edu.cn/ubuntu-ports bionic main restricted universe multiverse</span></span><br><span class="line">deb http://mirrors.ustc.edu.cn/ubuntu-ports bionic-updates main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src http://mirrors.ustc.edu.cn/ubuntu-ports bionic-updates main restricted universe multiverse</span></span><br><span class="line">deb http://mirrors.ustc.edu.cn/ubuntu-ports bionic-backports main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src http://mirrors.ustc.edu.cn/ubuntu-ports bionic-backports main restricted universe multiverse</span></span><br><span class="line">deb http://mirrors.ustc.edu.cn/ubuntu-ports bionic-security main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src http://mirrors.ustc.edu.cn/ubuntu-ports bionic-security main restricted universe multiverse</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 预发布软件源，不建议启用</span></span><br><span class="line"><span class="comment"># deb http://mirrors.ustc.edu.cn/ubuntu-ports bionic-proposed main restricted universe multiverse</span></span><br><span class="line"><span class="comment"># deb-src http://mirrors.ustc.edu.cn/ubuntu-ports bionic-proposed main restricted universe multiverse</span></span><br></pre></td></tr></table></figure>
<p>阿里巴巴镜像站：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span></span><br><span class="line">deb https://mirrors.aliyun.com/ubuntu-ports/ bionic main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.aliyun.com/ubuntu-ports/ bionic main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.aliyun.com/ubuntu-ports/ bionic-updates main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.aliyun.com/ubuntu-ports/ bionic-updates main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.aliyun.com/ubuntu-ports/ bionic-backports main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.aliyun.com/ubuntu-ports/s bionic-backports main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.aliyun.com/ubuntu-ports/ bionic-security main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.aliyun.com/ubuntu-ports/ bionic-security main restricted universe multiverse</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 预发布软件源，不建议启用</span></span><br><span class="line"><span class="comment"># deb https://mirrors.aliyun.com/ubuntu-ports/ bionic-proposed main restricted universe multiverse</span></span><br><span class="line"><span class="comment"># deb-src https://mirrors.aliyun.com/ubuntu-ports/ bionic-proposed main restricted universe multiverse</span></span><br></pre></td></tr></table></figure>
<ul>
<li>更新</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade -y</span><br></pre></td></tr></table></figure>
<h3 id="pip安装换源"><a href="#pip安装换源" class="headerlink" title="pip安装换源"></a>pip安装换源</h3><blockquote>
<p>Ubuntu18.04自带python2和python3两个版本，但没有预安装pip，参考<a href="https://blog.csdn.net/wenwst/article/details/106982806">https://blog.csdn.net/wenwst/article/details/106982806</a></p>
<p>pip安装好后添加国内源，方便快速下载，参考<a href="https://blog.csdn.net/carrymingteng/article/details/120978053。">https://blog.csdn.net/carrymingteng/article/details/120978053。</a></p>
</blockquote>
<ul>
<li>python2安装pip</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install python-pip # 安装</span><br><span class="line">pip --version # 输出版本号，安装成功</span><br><span class="line">pip install --upgrade pip # 保证版本最新</span><br></pre></td></tr></table></figure>
<ul>
<li>python3安装pip</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install python3-pip # 安装</span><br><span class="line">pip3 --version # 输出版本号，安装成功</span><br><span class="line">pip3 install --upgrade pip # 保证版本最新</span><br></pre></td></tr></table></figure>
<ul>
<li>pip换源</li>
</ul>
<p>打开终端输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir ~/.pip</span><br><span class="line">sudo gedit ~/.pip/pip.conf</span><br></pre></td></tr></table></figure>
<p>在空白文件中输入如下内容保存并退出,以下国内源可以任选其一：<br>以下为豆瓣源:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">timeout=6000</span><br><span class="line">index-url=https://pypi.doubanio.com/simple</span><br><span class="line">trusted-host=pypi.doubanio.com</span><br></pre></td></tr></table></figure>
<p>以下为阿里源:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url=http://mirrors.aliyun.com/pypi/simple/</span><br><span class="line">[install]</span><br><span class="line">trusted-host=mirrors.aliyun.com</span><br></pre></td></tr></table></figure>
<p>以下为清华源:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url=https://pypi.tuna.tsinghua.edu.cn/simple/</span><br><span class="line">[install]</span><br><span class="line">trusted-host=https://pypi.tuna.tsinghua.edu.cn</span><br></pre></td></tr></table></figure>
<h3 id="jtop安装"><a href="#jtop安装" class="headerlink" title="jtop安装"></a>jtop安装</h3><blockquote>
<p>jetpack系统不能使用nvidia-smi来查看显卡使用情况，需要安装jtop来查看机器状态</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo pip3 install jetson-stats  # 安装jtop</span><br><span class="line">sudo jtop  # 运行jtop</span><br><span class="line"># 可以查看cpu，gpu，内存，以及硬盘的使用情况，还能够调整jetson nano的运行模式</span><br><span class="line"># 以及查看系统的cuda，cudnn，tensorRT的版本等情况</span><br></pre></td></tr></table></figure>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202302102100237.png" alt="image-20221113145739058"></p>
<h3 id="pytorch安装"><a href="#pytorch安装" class="headerlink" title="pytorch安装"></a><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202302102101789.png" alt="image-20221113145801346">pytorch安装</h3><blockquote>
<p>jetson 预装了cuda版本，想要使用gup算力需要安装pytorch等模块</p>
</blockquote>
<ul>
<li>添加cuda到环境</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># jetson nano内置好了cuda,但需要配置环境变量才能使用，打开命令行添加环境变量即可</span><br><span class="line">gedit ~/.bashrc</span><br><span class="line"># 在最后添加这些</span><br><span class="line">export PATH=/usr/local/cuda-10.2/bin$&#123;PATH:+:$&#123;PATH&#125;&#125;</span><br><span class="line">export LD_LIBRARY_PATH=/usr/local/cuda-10.2/lib64$&#123;LD_LIBRARY_PATH:+:$&#123;LD_LIBRARY_PATH&#125;&#125;</span><br><span class="line">export CUDA_ROOT=/usr/local/cuda</span><br><span class="line"></span><br><span class="line">source ~/.bashrc  # 应用当前配置</span><br><span class="line"></span><br><span class="line">nvcc -V  # 查看是否配置成功</span><br></pre></td></tr></table></figure>
<ul>
<li><p>安装torch依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libopenblas-base libopenmpi-dev </span><br></pre></td></tr></table></figure>
</li>
<li><p>官网下载torch1.7及torchvision0.8.0，外网速度慢，已上传<a href="https://download.csdn.net/download/qq_37527608/86991829，0积分下载，下载完成后解压。">https://download.csdn.net/download/qq_37527608/86991829，0积分下载，下载完成后解压。</a></p>
</li>
<li>安装torch和torchvision</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 install Cython</span><br><span class="line">pip3 install numpy torch-1.7.0-cp36-cp36m-linux_aarch64.whl</span><br><span class="line">pip3 install torchvision-0.8.0a0+291f7e2-cp36-cp36m-linux_aarch64.whl</span><br></pre></td></tr></table></figure>
<ul>
<li>验证安装是否成功</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在终端输入运行python3，进入python环境</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">torch.__version__</span><br><span class="line">torch.cuda.is_available()</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line">torchvision.__version__</span><br><span class="line"><span class="comment"># 输出如下图所示则安装成功</span></span><br></pre></td></tr></table></figure>
<p><img src="https://liumeng-blog.oss-cn-hangzhou.aliyuncs.com/markdown/202302102101729.png" alt="image-20221113151316867"></p>
<p>PS：<strong>torchvision报错：UserWarning: Failed to load image Python extension解决方案</strong></p>
<p>如果torch版本与torchvision版本不对应，更换为对应版本，如果版本对应可卸载当前版本，更换更低版本的torch和torchvision。</p>
<p>PS：<strong>pip安装警告： which is not on PATH解决方案</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 配置路径</span><br><span class="line">gedit ~/.bashrc</span><br><span class="line"># 在文件最后添加路径，该路径来源于第一步中安装 pip 时发出的警告</span><br><span class="line">export PATH=/home/xxxx/.local/bin:$PATH</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>
<h3 id="U盘兼容安装"><a href="#U盘兼容安装" class="headerlink" title="U盘兼容安装"></a>U盘兼容安装</h3><blockquote>
<p>之后的步骤可能需要使用U盘把文件拷入开发板，但是对于大容量设备可能会出现无法挂载，一条安装命令解决</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install exfat-utils</span><br></pre></td></tr></table></figure>
<h3 id="各种环境依赖安装"><a href="#各种环境依赖安装" class="headerlink" title="各种环境依赖安装"></a>各种环境依赖安装</h3><blockquote>
<p>来自参考博客<a href="https://blog.csdn.net/IamYZD/article/details/119618950，不安装可能没问题，但还是安了，万一呢">https://blog.csdn.net/IamYZD/article/details/119618950，不安装可能没问题，但还是安了，万一呢</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置需要用到的库</span></span><br><span class="line">sudo apt-get install build-essential make cmake cmake-curses-gui -y</span><br><span class="line">sudo apt-get install git g++ pkg-config curl -y</span><br><span class="line">sudo apt-get install libatlas-base-dev gfortran libcanberra-gtk-module libcanberra-gtk3-module -y</span><br><span class="line">sudo apt-get install libhdf5-serial-dev hdf5-tools -y</span><br><span class="line">sudo apt-get install nano locate screen -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装所需要的依赖环境</span></span><br><span class="line">sudo apt-get install libfreetype6-dev -y</span><br><span class="line">sudo apt-get install protobuf-compiler libprotobuf-dev openssl -y</span><br><span class="line">sudo apt-get install libssl-dev libcurl4-openssl-dev -y</span><br><span class="line">sudo apt-get install cython3 -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装opencv的系统级依赖,一些编解码的库</span></span><br><span class="line">sudo apt-get install build-essential -y</span><br><span class="line">sudo apt-get install cmake git libgtk2<span class="number">.0</span>-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev -y</span><br><span class="line">sudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff5-dev libdc1394-<span class="number">22</span>-dev -y</span><br><span class="line">sudo apt-get install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev liblapacke-dev -y</span><br><span class="line">sudo apt-get install libxvidcore-dev libx264-dev -y</span><br><span class="line">sudo apt-get install libatlas-base-dev gfortran -y</span><br><span class="line">sudo apt-get install ffmpeg -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新cmake</span></span><br><span class="line">wget http://www.cmake.org/files/v3<span class="number">.13</span>/cmake-<span class="number">3.13</span><span class="number">.0</span>.tar.gz</span><br><span class="line">tar xpvf cmake-<span class="number">3.13</span><span class="number">.0</span>.tar.gz cmake-<span class="number">3.13</span><span class="number">.0</span>/  <span class="comment">#解压</span></span><br><span class="line">cd cmake-<span class="number">3.13</span><span class="number">.0</span>/</span><br><span class="line">./bootstrap --system-curl	<span class="comment"># 漫长的等待,做一套眼保健操...</span></span><br><span class="line">make -j4 <span class="comment">#编译  同样是漫长的等待...</span></span><br><span class="line">echo <span class="string">&#x27;export PATH=~/cmake-3.13.0/bin/:$PATH&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line">source ~/.bashrc <span class="comment">#更新.bashrc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># torchvision 0.9.0版本需要的依赖</span></span><br><span class="line">sudo apt-get install libopenmpi2</span><br><span class="line">sudo apt-get install libopenblas-dev</span><br><span class="line">sudo apt-get install libjpeg-dev zlib1g-dev</span><br></pre></td></tr></table></figure>
<h2 id="ssh连接"><a href="#ssh连接" class="headerlink" title="ssh连接"></a>ssh连接</h2><blockquote>
<p>使用ssh能够在同一网络下的另一台设备上登录jetson终端，更方便的进行操作和文件传输</p>
</blockquote>
<ul>
<li>查看jetson的ip</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ifconfig -a</span><br></pre></td></tr></table></figure>
<ul>
<li>在另一台设备打开终端，进行连接</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ssh nvidia@<span class="number">192.168</span><span class="number">.0</span><span class="number">.101</span>   <span class="comment"># 用户名@ip地址</span></span><br><span class="line"><span class="comment"># 输入登录密码，即可登录</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用ssh传输文件</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从服务器上下载文件</span></span><br><span class="line">scp nvidia@<span class="number">192.168</span><span class="number">.0</span><span class="number">.101</span>:/xxx/test.txt  ./test</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传本地文件到服务器</span></span><br><span class="line">scp ./test.txt  nvidia@<span class="number">192.168</span><span class="number">.0</span><span class="number">.101</span>:/xxx/test/ </span><br><span class="line"></span><br><span class="line"><span class="comment"># 从服务器下载整个目录</span></span><br><span class="line">scp -r nvidia@<span class="number">192.168</span><span class="number">.0</span><span class="number">.101</span>:/xxx/test  ./test/  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传目录到服务器</span></span><br><span class="line">scp -r ./test  nvidia@<span class="number">192.168</span><span class="number">.0</span><span class="number">.101</span>:/xxx/test/ </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>模型部署</category>
      </categories>
      <tags>
        <tag>jetson</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu 科学上网</title>
    <url>/link/5ce0b93b.html</url>
    <content><![CDATA[<h1 id="Ubuntu科学上网-clash"><a href="#Ubuntu科学上网-clash" class="headerlink" title="Ubuntu科学上网-clash"></a>Ubuntu科学上网-clash</h1><p>文章除最后一部分其余来自<a href="https://zhuanlan.zhihu.com/p/430035973，链接已挂，此处用于备份">https://zhuanlan.zhihu.com/p/430035973，链接已挂，此处用于备份</a></p>
<h2 id="一、下载clash并解压（已完成此操作的可直接看第二步）"><a href="#一、下载clash并解压（已完成此操作的可直接看第二步）" class="headerlink" title="一、下载clash并解压（已完成此操作的可直接看第二步）"></a><strong>一、下载clash并解压（已完成此操作的可直接看第二步）</strong></h2><ul>
<li><strong>官方网站 <a href="https://link.zhihu.com/?target=https%3A//github.com/Dreamacro/clash/releases">clash</a> 下载clash-linux-amd64-v1.11.8.gz</strong>（也可以下载最新的版本，前缀是clash-linux-amd64即可）</li>
<li>外网访问慢，使用到的下载资源可在<a href="https://pan.baidu.com/s/1rTNW4dBMRVkIKnE46CXohw?pwd=kadc">baidu网盘</a>下载</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-0664deb37fc0699cf7e2a3560fb3bfe8_720w.webp" alt="img"></p>
<ul>
<li><strong>进入下载的文件夹</strong>（我的在此文件夹，username为用户文件夹） ，在页面空白处右键，<strong>在终端打开</strong></li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-a7470d06d42faeef10aaf66f186f1c7b_720w.webp" alt="img"></p>
<ul>
<li><strong>解压</strong></li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># 解压</span><br><span class="line">gunzip clash-linux-amd64-v1.11.8.gz</span><br><span class="line"># 将clash-linux-amd64-v1.11.8改名为clash</span><br><span class="line">mv clash-linux-amd64-v1.11.8 clash</span><br><span class="line"># 在此目录下创建文件夹（这里用大写Clash只是为了和clash区别开来）</span><br><span class="line">mkdir Clash</span><br><span class="line"># 移动clash 到文件夹Clash</span><br><span class="line">mv clash ./Clash</span><br></pre></td></tr></table></figure>
<h2 id="二、进入新建的这个Clash文件夹，下载config-yaml和Country-mmdb-注意，【订阅链接】是写自己在代理那里获取的）"><a href="#二、进入新建的这个Clash文件夹，下载config-yaml和Country-mmdb-注意，【订阅链接】是写自己在代理那里获取的）" class="headerlink" title="二、进入新建的这个Clash文件夹，下载config.yaml和Country.mmdb (注意，【订阅链接】是写自己在代理那里获取的）"></a><strong>二、进入新建的这个Clash文件夹，下载config.yaml和Country.mmdb (注意，【订阅链接】是写自己在代理那里获取的）</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 进入新建的这个Clash文件夹</span><br><span class="line">cd Clash</span><br><span class="line">#下载clash 配置文件config.yaml （注意：在代理商那里复制订阅链接，替代 [订阅链接]</span><br><span class="line">wget -O config.yaml [订阅链接]</span><br><span class="line">#出现如下表示成功</span><br></pre></td></tr></table></figure>
<p><img src="https://pic4.zhimg.com/80/v2-77c46d6553f8a8fcf71eb731b0fdc04b_720w.webp" alt="img"></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">#下载Country.mmdb </span><br><span class="line">wget -O Country.mmdb https://www.sub-speeder.com/client-download/Country.mmdb</span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/80/v2-38687ff367335cd8605b7fb55f96f238_720w.webp" alt="img"></p>
<h2 id="三、启动clash（使用当前目录下的配置件）"><a href="#三、启动clash（使用当前目录下的配置件）" class="headerlink" title="三、启动clash（使用当前目录下的配置件）"></a><strong>三、启动clash（使用当前目录下的配置件）</strong></h2><p>（1）执行 <code>./clash -d .</code> 即可启动 Clash，如提示权限不足，先执行 <code>chmod +x clash</code> ，再执行<code>./clash -d .</code> <strong>出现如下，并保持此终端打开</strong></p>
<p><img src="https://pic4.zhimg.com/80/v2-b9ae0c610f7779e1d0a3a4ce1a1e641b_720w.webp" alt="img"></p>
<p>（2）打开配置文件config.yaml ，给它设置一个密码： # RESTful API 的口令 secret: ‘123456’</p>
<p><img src="https://pic4.zhimg.com/80/v2-537c9d36b6d6395382043f2b88a6fc13_720w.webp" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-cd584b99e194ff6ddd99749d86649445_720w.webp" alt="img"></p>
<p>（3）打开系统设置，选择网络，点击网络代理右边的 ⚙ 按钮，选择手动，填写 HTTP 和 HTTPS 代理为 127.0.0.1:7890，填写 Socks 主机为 127.0.0.1:7891，即可启用系统代理。</p>
<p><img src="https://pic1.zhimg.com/80/v2-cffc8428c54c7abd1f772613322b1a64_720w.webp" alt="img"></p>
<p>（4）访问 <a href="https://link.zhihu.com/?target=http%3A//clash.razord.top/">Clash Dashboard</a> 可以切换节点、测延迟等操作。（这里的代理模式选<strong>规则</strong>）</p>
<p><img src="https://pic1.zhimg.com/80/v2-ffdbfd232e5263063345e854877a2c94_720w.webp" alt="img"></p>
<ul>
<li>这个页面要求提供，Host,Port,Secret 三个输入：</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Host: 127.0.0.1  </span><br><span class="line">Port: 9090  </span><br><span class="line">Secret: 123456</span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/80/v2-7039cecea861b9ff5da7708b431b1299_720w.webp" alt="img"></p>
<ul>
<li>如下界面可以切换节点并测速 （点蓝色表示选中此节点）</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-94576ae58b0887c0dad6dd4455f5d123_720w.webp" alt="img"></p>
<p>注意：要访问谷歌，就要时刻打开那个终端</p>
<h2 id="四、快捷命令启动"><a href="#四、快捷命令启动" class="headerlink" title="四、快捷命令启动"></a>四、快捷命令启动</h2><ul>
<li>运行命令</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#创建service文件</span><br><span class="line">sudo touch /etc/systemd/system/clash.service</span><br><span class="line">#编辑service文件 </span><br><span class="line">sudo vi /etc/systemd/system/clash.service </span><br></pre></td></tr></table></figure>
<p>编辑文本,保存退出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit] </span><br><span class="line">Description=clash daemon  </span><br><span class="line">[Service] </span><br><span class="line">Type=simple </span><br><span class="line">User=root </span><br><span class="line">ExecStart=/home/username/下载/Clash/clash -d /home/username/下载/Clash/ </span><br><span class="line">Restart=on-failure  </span><br><span class="line">[Install] </span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<ul>
<li>运行命令</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl daemon-reload  </span><br><span class="line">sudo systemctl start clash </span><br><span class="line">sudo systemctl status clash</span><br></pre></td></tr></table></figure>
<ul>
<li>成功为如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clash.service - clash daemon      </span><br><span class="line">  Loaded: loaded (/etc/systemd/system/clash.service; enabled; vendor preset: enabled)      </span><br><span class="line">  Active: active (running) since Sat 2021-11-06 00:16:45 CST; 5s ago    </span><br><span class="line"> Main PID: 6848 (clash)       </span><br><span class="line">  Tasks: 8 (limit: 14171)      </span><br><span class="line">  Memory: 3.2M      </span><br><span class="line">  CGroup: /system.slice/clash.service              </span><br><span class="line">      └─6848 /home/username/下载/Clash/clash -d /home/username/下载/Clash/  </span><br><span class="line">11月 06 00:16:45 ym-X550JX systemd[1]: Started clash daemon. </span><br><span class="line">11月 06 00:16:45 ym-X550JX clash[6848]: time=&quot;2021-11-06T00:16:45+08:00&quot; level=info msg=&quot;Start &gt; 11月 06 00:16:45 ym-X550JX clash[6848]: time=&quot;2021-11-06T00:16:45+08:00&quot; level=info msg=&quot;Start &gt; </span><br><span class="line">11月 06 00:16:45 ym-X550JX clash[6848]: time=&quot;2021-11-06T00:16:45+08:00&quot; level=info msg=&quot;Start &gt; </span><br><span class="line">11月 06 00:16:45 ym-X550JX clash[6848]: time=&quot;2021-11-06T00:16:45+08:00&quot; level=info msg=&quot;Start &gt; </span><br><span class="line">11月 06 00:16:45 ym-X550JX clash[6848]: time=&quot;2021-11-06T00:16:45+08:00&quot; level=info msg=&quot;Start &gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>在clash文件夹下新建两个脚本文件</li>
</ul>
<p><code>vpns.sh</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># Clash Start</span><br><span class="line"># 我用的是非root用户，root用户可以直接使用systemctl start clash，password替换为自己管理员的密码</span><br><span class="line">echo &quot;lm&quot; | sudo -S systemctl start clash</span><br><span class="line"># 通过命令行更改系统代理设置为手动</span><br><span class="line">dconf write /system/proxy/mode &#x27;&quot;manual&quot;&#x27;</span><br></pre></td></tr></table></figure>
<p><code>vpnx.sh</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># Clash Stop</span><br><span class="line"># 我用的是非root用户，root用户可以直接使用systemctl start clash，password替换为自己管理员的密码</span><br><span class="line">echo &quot;lm&quot; | sudo -S systemctl stop clash</span><br><span class="line"># 通过命令行禁用系统代理</span><br><span class="line">dconf write /system/proxy/mode &#x27;&quot;none&quot;&#x27;</span><br></pre></td></tr></table></figure>
<ul>
<li>创建快捷方式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vi ~/.bashrc</span><br></pre></td></tr></table></figure>
<p>在文档最后添加下面的语句后保存退出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alias vpns=&#x27;sh /home/username/下载/Clash/clash/vpns.sh&#x27;</span><br><span class="line">alias vpnx=&#x27;sh /home/username/下载/Clash/clash/vpnx.sh&#x27;</span><br></pre></td></tr></table></figure>
<p>执行命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source ~/.bashrc</span><br><span class="line"># 配置完成</span><br><span class="line"># 终端使用vpns和vpnx命令即可开启关闭代理</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>系统安装</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu系统软件安装</title>
    <url>/link/1684a447.html</url>
    <content><![CDATA[<h2 id="ubuntu系统软件安装"><a href="#ubuntu系统软件安装" class="headerlink" title="ubuntu系统软件安装"></a>ubuntu系统软件安装</h2><h3 id="第一小节：安装ubuntu系统"><a href="#第一小节：安装ubuntu系统" class="headerlink" title="第一小节：安装ubuntu系统"></a>第一小节：安装ubuntu系统</h3><ul>
<li>网页搜索ubuntu，下载iso镜像文件</li>
<li>下载Rufus制作U盘启动盘</li>
<li>磁盘分区，为ubuntu系统分配空间，单系统忽略</li>
<li>进入bios后，选择U盘启动，根据提示安装</li>
<li>当出现pcie报错时，在grup界面选中ubuntu，按e进行编译，在quiet salash后空格添加pcie_aspm=off</li>
<li>安装完成后，重启时仍需要重复上一步骤，重启后在终端输入<code>sudo gedit /etc/default/grub</code></li>
<li>在文件中找到GRUB_CMDLINE_LINUX_DEFAULT，修改关键字在quiet salash后空格添加pcie_aspm=off</li>
<li>保存退出，更新grub<code>sudo update-grub</code></li>
</ul>
<h3 id="第二小节：安装pycharm"><a href="#第二小节：安装pycharm" class="headerlink" title="第二小节：安装pycharm"></a>第二小节：安装pycharm</h3><ul>
<li><p>在pycharm官网下载社区版</p>
</li>
<li><p>解压文件，打开终端</p>
</li>
<li><p>进入到pycharm对应文件的bin文件夹下</p>
</li>
<li><p>执行  <code>sh  ./pycharm.sh</code>  命令</p>
</li>
<li><p>根据指引按步骤安装</p>
</li>
<li><p>输入命令 <code>sudo gedit ~/.bashrc</code> 更改ubuntu配置文件</p>
</li>
<li><p>最后加上<code>alias pycharm=&quot;pycharm-community-2021.3/bin/pycharm.sh 路径&quot;</code>保存</p>
</li>
<li><p><code>source ~/.bashrc</code>更新配置文件</p>
</li>
<li><p><code>crtl + alt + t</code> 打开终端，输入pycharm打开软件</p>
<p>PS：没有新建项目可能是窗口太小显示不全</p>
</li>
</ul>
<h3 id="第三小节：安装anaconda"><a href="#第三小节：安装anaconda" class="headerlink" title="第三小节：安装anaconda"></a>第三小节：安装anaconda</h3><ul>
<li><p>通过清华镜像源下载anaconda的发行版本Anaconda3-2019.10-Linux-x86_64.sh</p>
</li>
<li><p>执行命令<code>sh Anaconda3-2019.10-Linux-x86_64.sh</code> </p>
</li>
<li><p>根据指引完成安装</p>
</li>
<li><p>终端中输入conda，如果没找到指令则进行下一步，</p>
</li>
<li><p>执行<code>echo &#39;export PATH=&quot;/home/用户名/anaconda3/bin:$PATH&quot;&#39; &gt;&gt; ~/.bashrc</code></p>
</li>
<li><p><code>source ~/.bashrc</code>更新配置文件</p>
</li>
<li><p>终端中输入conda，安装完成</p>
</li>
<li><p>配置国内源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/menpo/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/</span><br><span class="line">conda config --set show_channel_urls yes</span><br><span class="line">conda config --show   # 显示配置的源</span><br><span class="line">    </span><br><span class="line">conda config --remove-key channels  # 恢复默认源</span><br></pre></td></tr></table></figure>
</li>
<li><p>pip换源：<code>pip config set global.index-url https://mirrors.aliyun.com/pypi/simple/</code></p>
</li>
</ul>
<h3 id="第四小节：安装labelme"><a href="#第四小节：安装labelme" class="headerlink" title="第四小节：安装labelme"></a>第四小节：安装labelme</h3><ul>
<li><code>pip install --upgrade setuptools</code></li>
<li><code>sudo pip install labelme -i https://pypi.tuna.tsinghua.edu.cn/simple some-package</code></li>
<li>终端输入labelme，打开软件</li>
</ul>
<h3 id="第五小节：安装docker"><a href="#第五小节：安装docker" class="headerlink" title="第五小节：安装docker"></a>第五小节：安装docker</h3><h4 id="方法一：curl下载"><a href="#方法一：curl下载" class="headerlink" title="方法一：curl下载"></a>方法一：curl下载</h4><ul>
<li><pre><code>curl -sSL https://get.daocloud.io/docker | sh
</code></pre></li>
</ul>
<h4 id="方法二：yum下载"><a href="#方法二：yum下载" class="headerlink" title="方法二：yum下载"></a>方法二：yum下载</h4><ul>
<li>配置yum源</li>
</ul>
<p># vim /etc/yum.repos.d/docker.repo</p>
<p>[dockerrepo]</p>
<p>name=Docker Repository</p>
<p>baseurl=<a href="https://yum.dockerproject.org/repo/main/centos/$releasever/">https://yum.dockerproject.org/repo/main/centos/$releasever/</a></p>
<p>enabled=1</p>
<p>gpgcheck=1</p>
<p>gpgkey=<a href="https://yum.dockerproject.org/gpg">https://yum.dockerproject.org/gpg</a></p>
<ul>
<li>通过yum安装</li>
</ul>
<p># yum install docker-engine</p>
<p># service docker start</p>
<p># service docker status</p>
<ul>
<li>日志</li>
</ul>
<p># vim /var/log/docker</p>
<h3 id="第六小节：安装typora"><a href="#第六小节：安装typora" class="headerlink" title="第六小节：安装typora"></a>第六小节：安装typora</h3><p>直接应用商店下载即可</p>
<h3 id="第七小节：ubuntu使用"><a href="#第七小节：ubuntu使用" class="headerlink" title="第七小节：ubuntu使用"></a>第七小节：ubuntu使用</h3><h4 id="1-解压rar文件"><a href="#1-解压rar文件" class="headerlink" title="1.解压rar文件"></a>1.解压rar文件</h4><p>比如你有一个nam.rar的文件，</p>
<blockquote>
<p>sudo unrar name.rar  </p>
</blockquote>
<p>但是一般会显示unrar命令不存在，那么你需要安装rar</p>
<blockquote>
<p>sudo apt-get install rar</p>
</blockquote>
<p>然后你在执行第一个命令，提示还是这一句：unrar命令不存在</p>
<p>那么你需要</p>
<blockquote>
<p>sudo apt-get install unrar</p>
</blockquote>
<p>那么你再用第一个，命令，需要带上参数：</p>
<blockquote>
<p>sudo unrar x name.rar</p>
<p>sudo unrar e name.rar</p>
</blockquote>
<p>其中x参数是解压到一个文件夹，e参数是把里面的文件都解压到当前路径下。</p>
<h4 id="2-添加新用户"><a href="#2-添加新用户" class="headerlink" title="2.添加新用户"></a>2.添加新用户</h4><ul>
<li><p>Ctrl+Alt+T打开终端，输入sudo adduser ubuntu<em>(ubuntu是我创建的新用户名)，</em>回车之后输入密码，根据提示输入新用户的密码，直接回车即可。</p>
</li>
<li><p>输入sudo adduser ubuntt(新创建的用户名) sudo,给新用户赋予管理员的权限。</p>
</li>
<li><p>切换到新用户，Ctrl+Alt+T打开终端，输入sudo su查看添加管理员权限是否成功。</p>
</li>
</ul>
<h4 id="3-监控gpu"><a href="#3-监控gpu" class="headerlink" title="3.监控gpu"></a>3.监控gpu</h4><ul>
<li>先使用<code>sudo apt install nvidia-340</code>命令安装</li>
<li>然后<code>nvidia-smi</code>命令单次查看GPU使用率</li>
<li>实时显示，可以使用<code>nvidia-smi -l 1</code> 命令每秒刷新一次。</li>
</ul>
<h3 id="第八小节：显卡驱动及cuda安装"><a href="#第八小节：显卡驱动及cuda安装" class="headerlink" title="第八小节：显卡驱动及cuda安装"></a>第八小节：显卡驱动及cuda安装</h3><ul>
<li><p>换国内源<br><a href="https://blog.csdn.net/luoganttcc/article/details/122619962">https://blog.csdn.net/luoganttcc/article/details/122619962</a></p>
</li>
<li><p>确保nvidia跟cuda卸载干净<br><a href="https://blog.csdn.net/XYKenny/article/details/96891116">https://blog.csdn.net/XYKenny/article/details/96891116</a></p>
</li>
<li><p>Ubuntu 20.04安装CUDA 11.0、cuDNN 8.0.5、PyTorch 1.7.0<br><a href="https://www.tqwba.com/x_d/jishu/253775.html">https://www.tqwba.com/x_d/jishu/253775.html</a><br><a href="https://www.cnblogs.com/booturbo/p/13960935.html">https://www.cnblogs.com/booturbo/p/13960935.html</a></p>
</li>
</ul>
<ul>
<li><p>安装显卡驱动<br><a href="https://blog.csdn.net/buluxianfeng/article/details/117395319">https://blog.csdn.net/buluxianfeng/article/details/117395319</a></p>
</li>
<li><p>freeimg.h找不到<br><a href="https://blog.csdn.net/xhw205/article/details/116297555">https://blog.csdn.net/xhw205/article/details/116297555</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>系统安装</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客搭建</title>
    <url>/link/f3fb008f.html</url>
    <content><![CDATA[<h1 id="hexo博客搭建"><a href="#hexo博客搭建" class="headerlink" title="hexo博客搭建"></a>hexo博客搭建</h1><blockquote>
<p>hexo+github是一个常用的blog搭建方式，与很多的搭建教程和魔改教程可供参考，不需要太多前端的知识。</p>
</blockquote>
<h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><ul>
<li><p>nodejs安装，然后通过npm安装hexo，教程都是一搜就搜到，根据自己系统进行安装。下载自己喜欢的hexo主题，我选择的是butterfly，在本地可以生成查看网页，教程很多。</p>
</li>
<li><p>下载git并登录，去github建立一个github.io的仓库，去hexo配置github提交，有域名可在github.io中设置，域名可在阿里云购买。</p>
</li>
<li><p>文章书写使用typora+图床进行书写，这里图床我选择的是阿里云oss储存，也可以将网站的图标放在oss存储里。</p>
</li>
<li><p>评论使用valine，绑定自己的域名。</p>
</li>
</ul>
<p>PS：有很多大佬对主题进行修改，我主要是为了写blog，参考了<a href="https://moonshuo.cn/posts/43310.html">偷掉月亮</a>，很多功能没有去进行添加，更多主题修改可参考<a href="https://butterfly.zhheo.com/">Butterfly主题美化教程</a>。</p>
<h2 id="搭建中碰到的问题"><a href="#搭建中碰到的问题" class="headerlink" title="搭建中碰到的问题"></a>搭建中碰到的问题</h2><ul>
<li>github.io的仓库中需要另建一个分支接受hexo提交，不能直接提交到master，可能会出问题。</li>
<li>域名绑定后，可将CNAME文件放到本地hexo的source文件夹下，避免多次配置。</li>
<li>valine评论国际版默认分配的服务器，国内无法访问，需要绑定自己的域名。</li>
<li>在vpn开启时git提交超时失败，需要设置git代理到vpn使用的端口。</li>
</ul>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>关于</title>
    <url>/about/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>分类</title>
    <url>/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>标签</title>
    <url>/tags/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/Valine.min.js</url>
    <content><![CDATA[/*!
 * Valine v1.5.1
 * (c) 2017-2022 xCss
 * Released under the GPL-2.0 License.
 * Last Update: 2022-7-21 3:43:59 ├F10: PM┤
 * Modify by HCLonely
 */
!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.Valine=t():e.Valine=t()}(this,function(){return n=[function(e,t,n){"use strict";var f=SyntaxError,r=Function,d=TypeError,o=function(e){try{return r('"use strict"; return ('+e+").constructor;")()}catch(e){}},h=Object.getOwnPropertyDescriptor;if(h)try{h({},"")}catch(e){h=null}function i(){throw new d}function g(e){var t,n;return"%AsyncFunction%"===e?t=o("async function () {}"):"%GeneratorFunction%"===e?t=o("function* () {}"):"%AsyncGeneratorFunction%"===e?t=o("async function* () {}"):"%AsyncGenerator%"===e?(n=g("%AsyncGeneratorFunction%"))&&(t=n.prototype):"%AsyncIteratorPrototype%"===e&&(n=g("%AsyncGenerator%"))&&(t=s(n.prototype)),m[e]=t}var a=h?function(){try{return i}catch(e){try{return h(arguments,"callee").get}catch(e){return i}}}():i,u=n(22)(),s=Object.getPrototypeOf||function(e){return e.__proto__},v={},l="undefined"==typeof Uint8Array?void 0:s(Uint8Array),m={"%AggregateError%":"undefined"==typeof AggregateError?void 0:AggregateError,"%Array%":Array,"%ArrayBuffer%":"undefined"==typeof ArrayBuffer?void 0:ArrayBuffer,"%ArrayIteratorPrototype%":u?s([][Symbol.iterator]()):void 0,"%AsyncFromSyncIteratorPrototype%":void 0,"%AsyncFunction%":v,"%AsyncGenerator%":v,"%AsyncGeneratorFunction%":v,"%AsyncIteratorPrototype%":v,"%Atomics%":"undefined"==typeof Atomics?void 0:Atomics,"%BigInt%":"undefined"==typeof BigInt?void 0:BigInt,"%Boolean%":Boolean,"%DataView%":"undefined"==typeof DataView?void 0:DataView,"%Date%":Date,"%decodeURI%":decodeURI,"%decodeURIComponent%":decodeURIComponent,"%encodeURI%":encodeURI,"%encodeURIComponent%":encodeURIComponent,"%Error%":Error,"%eval%":eval,"%EvalError%":EvalError,"%Float32Array%":"undefined"==typeof Float32Array?void 0:Float32Array,"%Float64Array%":"undefined"==typeof Float64Array?void 0:Float64Array,"%FinalizationRegistry%":"undefined"==typeof FinalizationRegistry?void 0:FinalizationRegistry,"%Function%":r,"%GeneratorFunction%":v,"%Int8Array%":"undefined"==typeof Int8Array?void 0:Int8Array,"%Int16Array%":"undefined"==typeof Int16Array?void 0:Int16Array,"%Int32Array%":"undefined"==typeof Int32Array?void 0:Int32Array,"%isFinite%":isFinite,"%isNaN%":isNaN,"%IteratorPrototype%":u?s(s([][Symbol.iterator]())):void 0,"%JSON%":"object"==typeof JSON?JSON:void 0,"%Map%":"undefined"==typeof Map?void 0:Map,"%MapIteratorPrototype%":"undefined"!=typeof Map&&u?s((new Map)[Symbol.iterator]()):void 0,"%Math%":Math,"%Number%":Number,"%Object%":Object,"%parseFloat%":parseFloat,"%parseInt%":parseInt,"%Promise%":"undefined"==typeof Promise?void 0:Promise,"%Proxy%":"undefined"==typeof Proxy?void 0:Proxy,"%RangeError%":RangeError,"%ReferenceError%":ReferenceError,"%Reflect%":"undefined"==typeof Reflect?void 0:Reflect,"%RegExp%":RegExp,"%Set%":"undefined"==typeof Set?void 0:Set,"%SetIteratorPrototype%":"undefined"!=typeof Set&&u?s((new Set)[Symbol.iterator]()):void 0,"%SharedArrayBuffer%":"undefined"==typeof SharedArrayBuffer?void 0:SharedArrayBuffer,"%String%":String,"%StringIteratorPrototype%":u?s(""[Symbol.iterator]()):void 0,"%Symbol%":u?Symbol:void 0,"%SyntaxError%":f,"%ThrowTypeError%":a,"%TypedArray%":l,"%TypeError%":d,"%Uint8Array%":"undefined"==typeof Uint8Array?void 0:Uint8Array,"%Uint8ClampedArray%":"undefined"==typeof Uint8ClampedArray?void 0:Uint8ClampedArray,"%Uint16Array%":"undefined"==typeof Uint16Array?void 0:Uint16Array,"%Uint32Array%":"undefined"==typeof Uint32Array?void 0:Uint32Array,"%URIError%":URIError,"%WeakMap%":"undefined"==typeof WeakMap?void 0:WeakMap,"%WeakRef%":"undefined"==typeof WeakRef?void 0:WeakRef,"%WeakSet%":"undefined"==typeof WeakSet?void 0:WeakSet},y={"%ArrayBufferPrototype%":["ArrayBuffer","prototype"],"%ArrayPrototype%":["Array","prototype"],"%ArrayProto_entries%":["Array","prototype","entries"],"%ArrayProto_forEach%":["Array","prototype","forEach"],"%ArrayProto_keys%":["Array","prototype","keys"],"%ArrayProto_values%":["Array","prototype","values"],"%AsyncFunctionPrototype%":["AsyncFunction","prototype"],"%AsyncGenerator%":["AsyncGeneratorFunction","prototype"],"%AsyncGeneratorPrototype%":["AsyncGeneratorFunction","prototype","prototype"],"%BooleanPrototype%":["Boolean","prototype"],"%DataViewPrototype%":["DataView","prototype"],"%DatePrototype%":["Date","prototype"],"%ErrorPrototype%":["Error","prototype"],"%EvalErrorPrototype%":["EvalError","prototype"],"%Float32ArrayPrototype%":["Float32Array","prototype"],"%Float64ArrayPrototype%":["Float64Array","prototype"],"%FunctionPrototype%":["Function","prototype"],"%Generator%":["GeneratorFunction","prototype"],"%GeneratorPrototype%":["GeneratorFunction","prototype","prototype"],"%Int8ArrayPrototype%":["Int8Array","prototype"],"%Int16ArrayPrototype%":["Int16Array","prototype"],"%Int32ArrayPrototype%":["Int32Array","prototype"],"%JSONParse%":["JSON","parse"],"%JSONStringify%":["JSON","stringify"],"%MapPrototype%":["Map","prototype"],"%NumberPrototype%":["Number","prototype"],"%ObjectPrototype%":["Object","prototype"],"%ObjProto_toString%":["Object","prototype","toString"],"%ObjProto_valueOf%":["Object","prototype","valueOf"],"%PromisePrototype%":["Promise","prototype"],"%PromiseProto_then%":["Promise","prototype","then"],"%Promise_all%":["Promise","all"],"%Promise_reject%":["Promise","reject"],"%Promise_resolve%":["Promise","resolve"],"%RangeErrorPrototype%":["RangeError","prototype"],"%ReferenceErrorPrototype%":["ReferenceError","prototype"],"%RegExpPrototype%":["RegExp","prototype"],"%SetPrototype%":["Set","prototype"],"%SharedArrayBufferPrototype%":["SharedArrayBuffer","prototype"],"%StringPrototype%":["String","prototype"],"%SymbolPrototype%":["Symbol","prototype"],"%SyntaxErrorPrototype%":["SyntaxError","prototype"],"%TypedArrayPrototype%":["TypedArray","prototype"],"%TypeErrorPrototype%":["TypeError","prototype"],"%Uint8ArrayPrototype%":["Uint8Array","prototype"],"%Uint8ClampedArrayPrototype%":["Uint8ClampedArray","prototype"],"%Uint16ArrayPrototype%":["Uint16Array","prototype"],"%Uint32ArrayPrototype%":["Uint32Array","prototype"],"%URIErrorPrototype%":["URIError","prototype"],"%WeakMapPrototype%":["WeakMap","prototype"],"%WeakSetPrototype%":["WeakSet","prototype"]},u=n(9),b=n(25),D=u.call(Function.call,Array.prototype.concat),w=u.call(Function.apply,Array.prototype.splice),x=u.call(Function.call,String.prototype.replace),A=u.call(Function.call,String.prototype.slice),k=/[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,E=/\\(\\)?/g;e.exports=function(e,t){if("string"!=typeof e||0===e.length)throw new d("intrinsic name must be a non-empty string");if(1<arguments.length&&"boolean"!=typeof t)throw new d('"allowMissing" argument must be a boolean');var n=function(e){var t=A(e,0,1),n=A(e,-1);if("%"===t&&"%"!==n)throw new f("invalid intrinsic syntax, expected closing `%`");if("%"===n&&"%"!==t)throw new f("invalid intrinsic syntax, expected opening `%`");var o=[];return x(e,k,function(e,t,n,r){o[o.length]=n?x(r,E,"$1"):t||e}),o}(e),r=0<n.length?n[0]:"",o=function(e,t){var n,r=e;if(b(y,r)&&(r="%"+(n=y[r])[0]+"%"),b(m,r)){var o=m[r];if(void 0!==(o=o===v?g(r):o)||t)return{alias:n,name:r,value:o};throw new d("intrinsic "+e+" exists, but is not available. Please file an issue!")}throw new f("intrinsic "+e+" does not exist!")}("%"+r+"%",t),i=(o.name,o.value),a=!1,o=o.alias;o&&(r=o[0],w(n,D([0,1],o)));for(var u=1,s=!0;u<n.length;u+=1){var l=n[u],c=A(l,0,1),p=A(l,-1);if(('"'===c||"'"===c||"`"===c||'"'===p||"'"===p||"`"===p)&&c!==p)throw new f("property names with quotes must have matching quotes");if("constructor"!==l&&s||(a=!0),b(m,c="%"+(r+="."+l)+"%"))i=m[c];else if(null!=i){if(!(l in i)){if(t)return;throw new d("base intrinsic for "+e+" exists, but the property is not available.")}i=h&&u+1>=n.length?(s=!!(p=h(i,l)))&&"get"in p&&!("originalValue"in p.get)?p.get:i[l]:(s=b(i,l),i[l]),s&&!a&&(m[c]=i)}}return i}},function(e,t,n){"use strict";var r=n(0),o=n(4),i=o(r("String.prototype.indexOf"));e.exports=function(e,t){t=r(e,!!t);return"function"==typeof t&&-1<i(e,".prototype.")?o(t):t}},function(e,t,n){"use strict";function r(e,t){var n=2<arguments.length?arguments[2]:{},r=l(t);c&&(r=p.call(r,Object.getOwnPropertySymbols(t)));for(var o,i,a,u,s=0;s<r.length;s+=1)o=e,i=r[s],a=t[r[s]],u=n[r[s]],i in o&&(!d(u)||!u())||(h?f(o,i,{configurable:!0,enumerable:!1,value:a,writable:!0}):o[i]=a)}var l=n(88),c="function"==typeof Symbol&&"symbol"==typeof Symbol("foo"),o=Object.prototype.toString,p=Array.prototype.concat,f=Object.defineProperty,d=function(e){return"function"==typeof e&&"[object Function]"===o.call(e)},h=f&&function(){var e={};try{for(var t in f(e,"x",{enumerable:!1,value:e}),e)return!1;return e.x===e}catch(e){return!1}}();r.supportsDescriptors=!!h,e.exports=r},function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{default:e}}t.__esModule=!0;var o,i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},a=r(n(85)),u=r(n(49)),s=r(n(46)),l=r(n(48)),n=r(n(45)),c=document,p=navigator,f=/[&<>"'`\\]/g,d=RegExp(f.source),h=/&(?:amp|lt|gt|quot|#39|#x60|#x5c);/g,g=RegExp(h.source),v={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;","`":"&#x60;","\\":"&#x5c;"},m={};for(o in v)m[v[o]]=o;var y=null;Array.prototype.forEach||(Array.prototype.forEach=function(e,t){var n,r;if(null==this)throw new TypeError(" this is null or not defined");var o,i=Object(this),a=i.length>>>0;if("function"!=typeof e)throw new TypeError(e+" is not a function");for(1<arguments.length&&(n=t),r=0;r<a;)r in i&&(o=i[r],e.call(n,o,r,i)),r++}),window.NodeList&&!NodeList.prototype.forEach&&(NodeList.prototype.forEach=Array.prototype.forEach),String.prototype.trim||(String.prototype.trim=function(){return this.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,"")}),(0,a.default)(u.default.fn,{prepend:function(t){return t instanceof HTMLElement||(t=t[0]),this.forEach(function(e){e.insertAdjacentElement("afterBegin",t)}),this},append:function(t){return t instanceof HTMLElement||(t=t[0]),this.forEach(function(e){e.insertAdjacentElement("beforeEnd",t)}),this},remove:function(){return this.forEach(function(e){try{e.parentNode.removeChild(e)}catch(e){}}),this},find:function(e){return(0,u.default)(e,this)},show:function(){return this.forEach(function(e){e.style.display="block"}),this},hide:function(){return this.forEach(function(e){e.style.display="none"}),this},on:function(e,n,r){return u.default.fn.off(e,n,r),this.forEach(function(t){e.split(" ").forEach(function(e){t.addEventListener?t.addEventListener(e,n,r||!1):t.attachEvent?t.attachEvent("on"+e,n):t["on"+e]=n})}),this},off:function(e,n,r){return this.forEach(function(t){e.split(" ").forEach(function(e){t.removeEventListener?t.removeEventListener(e,n,r||!1):t.detachEvent?t.detachEvent("on"+e,n):t["on"+e]=null})}),this},html:function(t){return void 0!==t?(this.forEach(function(e){e.innerHTML=t}),this):this[0].innerHTML},text:function(t){return void 0!==t?(this.forEach(function(e){e.innerText=t}),this):this[0].innerText},empty:function(e){return e=e||0,this.forEach(function(t){setTimeout(function(e){t.innerText=""},e)}),this},val:function(t){return void 0!==t?(this.forEach(function(e){e.value=t}),this):this[0].value||""},attr:function(){var n,e,t=arguments;return"object"==i(arguments[0])?(n=arguments[0],e=this,Object.keys(n).forEach(function(t){e.forEach(function(e){e.setAttribute(t,n[t])})}),this):"string"==typeof arguments[0]&&arguments.length<2?this[0].getAttribute(arguments[0])||"":(this.forEach(function(e){e.setAttribute(t[0],t[1])}),this)},removeAttr:function(o){return this.forEach(function(e){var t,n=0,r=o&&o.match(/[^\x20\t\r\n\f\*\/\\]+/g);if(r&&1===e.nodeType)for(;t=r[n++];)e.removeAttribute(t)}),this},hasClass:function(e){return!!this[0]&&new RegExp("(\\s|^)"+e+"(\\s|$)").test(this[0].getAttribute("class"))},addClass:function(n){return this.forEach(function(e){var e=(0,u.default)(e),t=e.attr("class");e.hasClass(n)||e.attr("class",t+=" "+n)}),this},removeClass:function(r){return this.forEach(function(e){var t,e=(0,u.default)(e),n=e.attr("class");e.hasClass(r)&&(t=new RegExp("(\\s|^)"+r+"(\\s|$)"),e.attr("class",n.replace(t,"")))}),this}}),(0,a.default)(u.default,{extend:a.default,noop:function(){},navi:p,ua:p.userAgent,lang:p.language||p.languages[0],detect:s.default,store:l.default,escape:function(e){return e&&d.test(e)?e.replace(f,function(e){return v[e]}):e},unescape:function(e){return e&&g.test(e)?e.replace(h,function(e){return m[e]}):e},dynamicLoadSource:function(e,t){var n;(0,u.default)('script[src="'+e+'"]').length?t&&t():((n=c.createElement("script")).onload=n.onreadystatechange=function(){this.onload=this.onreadystatechange=null,t&&t(),(0,u.default)(n).remove()},n.async=!0,n.setAttribute("referrerPolicy","no-referrer"),(0,u.default)("head")[0].appendChild(n),n.src=e)},sdkLoader:function(e,t,n){t in window&&window[t]?(y&&clearTimeout(y),n&&n()):u.default.dynamicLoadSource(e,function(){y=setTimeout(u.default.sdkLoader(e,t,n),100)})},deleteInWin:function(t,e){function n(e){if(t in window)try{delete window[t]}catch(e){window[t]=null}}0===e?n():setTimeout(n,e||500)},ajax:n.default}),t.default=u.default},function(e,t,n){"use strict";var r=n(9),n=n(0),o=n("%Function.prototype.apply%"),i=n("%Function.prototype.call%"),a=n("%Reflect.apply%",!0)||r.call(i,o),u=n("%Object.getOwnPropertyDescriptor%",!0),s=n("%Object.defineProperty%",!0),l=n("%Math.max%");if(s)try{s({},"a",{value:1})}catch(e){s=null}e.exports=function(e){var t=a(r,i,arguments);return u&&s&&u(t,"length").configurable&&s(t,"length",{value:1+l(0,e.length-(arguments.length-1))}),t};function c(){return a(r,o,arguments)}s?s(e.exports,"apply",{value:c}):e.exports.apply=c},function(e,t,n){"use strict";e.exports=n(62)},function(e,t,n){"use strict";t.__esModule=!0,t.DEFAULT_EMOJI_CDN="//img.t.sinajs.cn/t4/appstyle/expression/ext/normal/",t.DB_NAME="Comment",t.CONFIG={lang:"zh-CN",langMode:null,appId:"",appKey:"",clazzName:"Comment",master:[],friends:[],tagMeta:["\u535a\u4e3b","\u5c0f\u4f19\u4f34","\u8bbf\u5ba2"],metaPlaceholder:{nick:"\u6635\u79f0/QQ\u53f7(\u5fc5\u586b)",mail:"\u90ae\u7bb1(\u5fc5\u586b)",link:"\u7f51\u5740(https://)"},meta:["nick","mail","link"],path:location.pathname,placeholder:"Just Go Go",pageSize:10,recordIP:!0,serverURLs:"",visitor:!1,mathJax:!1,emojiCDN:"",emojiMaps:void 0,enableQQ:!1,requiredFields:[]},t.defaultMeta=["nick","mail","link"],t.QQCacheKey="_v_Cache_Q",t.MetaCacheKey="_v_Cache_Meta",t.RandomStr=function(e){return(Date.now()+Math.round(1e3*Math.random())).toString(32)},t.VERSION="1.5.1"},function(e,t,n){var r,o=n(16),i=n(50);for(r in(t=e.exports=function(e,t){return new i(t).process(e)}).FilterCSS=i,o)t[r]=o[r];"undefined"!=typeof window&&(window.filterCSS=e.exports)},function(e,t,n){"use strict";var r=n(66);e.exports=function(e){return"symbol"==typeof e?"Symbol":"bigint"==typeof e?"BigInt":r(e)}},function(e,t,n){"use strict";n=n(78);e.exports=Function.prototype.bind||n},function(e,t,n){"use strict";var r,o,i=Function.prototype.toString,a="object"==typeof Reflect&&null!==Reflect&&Reflect.apply;if("function"==typeof a&&"function"==typeof Object.defineProperty)try{r=Object.defineProperty({},"length",{get:function(){throw o}}),o={},a(function(){throw 42},null,r)}catch(e){e!==o&&(a=null)}else a=null;function u(e){try{var t=i.call(e);return s.test(t)}catch(e){return}}var s=/^\s*class\b/,l=Object.prototype.toString,c="function"==typeof Symbol&&!!Symbol.toStringTag,p="object"==typeof document&&void 0===document.all&&void 0!==document.all?document.all:{};e.exports=a?function(e){if(e===p)return!0;if(!e)return!1;if("function"!=typeof e&&"object"!=typeof e)return!1;if("function"==typeof e&&!e.prototype)return!0;try{a(e,null,r)}catch(e){if(e!==o)return!1}return!u(e)}:function(e){if(e===p)return!0;if(!e)return!1;if("function"!=typeof e&&"object"!=typeof e)return!1;if("function"==typeof e&&!e.prototype)return!0;if(!c){if(u(e))return!1;var t=l.call(e);return"[object Function]"===t||"[object GeneratorFunction]"===t}var n=e;try{return!u(n)&&(i.call(n),!0)}catch(n){return!1}}},function(e,t){e.exports={indexOf:function(e,t){var n,r;if(Array.prototype.indexOf)return e.indexOf(t);for(n=0,r=e.length;n<r;n++)if(e[n]===t)return n;return-1},forEach:function(e,t,n){var r,o;if(Array.prototype.forEach)return e.forEach(t,n);for(r=0,o=e.length;r<o;r++)t.call(n,e[r],r,e)},trim:function(e){return String.prototype.trim?e.trim():e.replace(/(^\s*)|(\s*$)/g,"")},spaceIndex:function(e){e=/\s|\n|\t/.exec(e);return e?e.index:-1}}},function(e,t,n){"use strict";t.__esModule=!0;var o={cdn:n(6).DEFAULT_EMOJI_CDN,maps:n(97),parse:function(e,n){return String(e).replace(new RegExp(":("+Object.keys(o.maps).join("|")+"):","ig"),function(e,t){return o.maps[t]?o.build(t,n):e})},build:function(e,t){var n=/^(https?:)?\/\//i,r=o.maps[e],r=n.test(r)?r:o.cdn+r,e=' <img alt="'+e+'" referrerpolicy="no-referrer" class="vemoji" src="'+r+'" />';return n.test(r)?e:""}};t.default=o},function(e,t,n){"use strict";t.__esModule=!0;var n=n(95),i=n&&n.__esModule?n:{default:n},o=(t.default=function(e){return(0,i.default)(e,{onTagAttr:function(e,t,n,r){return o(e,t,n,r)},onIgnoreTagAttr:function(e,t,n,r){return o(e,t,n,r)}}).replace(/\<\/?div\>/gi,"")},function(e,t,n,r){if(/video|audio/i.test(e))return"";if(/code|pre|span/i.test(e)){var o;if("style"==t)return(o=n.match(/color:([#a-z0-9]{3,7}|\s+[#a-z0-9]{3,8})/gi))&&o.length?'style="'+o[0]+'"':"";if("class"==t)return t+"='"+i.default.escapeAttrValue(n)+"'"}return"a"===e&&"class"==t&&"at"===n?t+"='"+i.default.escapeAttrValue(n)+"'":"img"===e&&/src|class/i.test(t)?t+"='"+i.default.escapeAttrValue(n)+"' referrerPolicy='no-referrer'":void 0})},function(e,t,n){"use strict";var r=n(0),o=n(1),u=r("%TypeError%"),s=n(52),l=n(18),c=n(53),p=n(55),f=n(56),d=n(60),h=n(20),g=n(81),v=o("String.prototype.split"),r=Object("a"),m="a"!==r[0]||!(0 in r);e.exports=function(e){var t,n=d(this),r=m&&g(this)?v(this,""):n,o=f(r);if(!p(e))throw new u("Array.prototype.forEach callback must be a function");1<arguments.length&&(t=arguments[1]);for(var i=0;i<o;){var a=h(i);c(r,a)&&(a=l(r,a),s(e,t,[a,i,r])),i+=1}}},function(e,t,n){"use strict";var r=n(75),o=n(14);e.exports=function(){var e=Array.prototype.forEach;return r(e)?e:o}},function(e,t){function n(){var e={"align-content":!1,"align-items":!1,"align-self":!1,"alignment-adjust":!1,"alignment-baseline":!1,all:!1,"anchor-point":!1,animation:!1,"animation-delay":!1,"animation-direction":!1,"animation-duration":!1,"animation-fill-mode":!1,"animation-iteration-count":!1,"animation-name":!1,"animation-play-state":!1,"animation-timing-function":!1,azimuth:!1,"backface-visibility":!1,background:!0,"background-attachment":!0,"background-clip":!0,"background-color":!0,"background-image":!0,"background-origin":!0,"background-position":!0,"background-repeat":!0,"background-size":!0,"baseline-shift":!1,binding:!1,bleed:!1,"bookmark-label":!1,"bookmark-level":!1,"bookmark-state":!1,border:!0,"border-bottom":!0,"border-bottom-color":!0,"border-bottom-left-radius":!0,"border-bottom-right-radius":!0,"border-bottom-style":!0,"border-bottom-width":!0,"border-collapse":!0,"border-color":!0,"border-image":!0,"border-image-outset":!0,"border-image-repeat":!0,"border-image-slice":!0,"border-image-source":!0,"border-image-width":!0,"border-left":!0,"border-left-color":!0,"border-left-style":!0,"border-left-width":!0,"border-radius":!0,"border-right":!0,"border-right-color":!0,"border-right-style":!0,"border-right-width":!0,"border-spacing":!0,"border-style":!0,"border-top":!0,"border-top-color":!0,"border-top-left-radius":!0,"border-top-right-radius":!0,"border-top-style":!0,"border-top-width":!0,"border-width":!0,bottom:!1,"box-decoration-break":!0,"box-shadow":!0,"box-sizing":!0,"box-snap":!0,"box-suppress":!0,"break-after":!0,"break-before":!0,"break-inside":!0,"caption-side":!1,chains:!1,clear:!0,clip:!1,"clip-path":!1,"clip-rule":!1,color:!0,"color-interpolation-filters":!0,"column-count":!1,"column-fill":!1,"column-gap":!1,"column-rule":!1,"column-rule-color":!1,"column-rule-style":!1,"column-rule-width":!1,"column-span":!1,"column-width":!1,columns:!1,contain:!1,content:!1,"counter-increment":!1,"counter-reset":!1,"counter-set":!1,crop:!1,cue:!1,"cue-after":!1,"cue-before":!1,cursor:!1,direction:!1,display:!0,"display-inside":!0,"display-list":!0,"display-outside":!0,"dominant-baseline":!1,elevation:!1,"empty-cells":!1,filter:!1,flex:!1,"flex-basis":!1,"flex-direction":!1,"flex-flow":!1,"flex-grow":!1,"flex-shrink":!1,"flex-wrap":!1,float:!1,"float-offset":!1,"flood-color":!1,"flood-opacity":!1,"flow-from":!1,"flow-into":!1,font:!0,"font-family":!0,"font-feature-settings":!0,"font-kerning":!0,"font-language-override":!0,"font-size":!0,"font-size-adjust":!0,"font-stretch":!0,"font-style":!0,"font-synthesis":!0,"font-variant":!0,"font-variant-alternates":!0,"font-variant-caps":!0,"font-variant-east-asian":!0,"font-variant-ligatures":!0,"font-variant-numeric":!0,"font-variant-position":!0,"font-weight":!0,grid:!1,"grid-area":!1,"grid-auto-columns":!1,"grid-auto-flow":!1,"grid-auto-rows":!1,"grid-column":!1,"grid-column-end":!1,"grid-column-start":!1,"grid-row":!1,"grid-row-end":!1,"grid-row-start":!1,"grid-template":!1,"grid-template-areas":!1,"grid-template-columns":!1,"grid-template-rows":!1,"hanging-punctuation":!1,height:!0,hyphens:!1,icon:!1,"image-orientation":!1,"image-resolution":!1,"ime-mode":!1,"initial-letters":!1,"inline-box-align":!1,"justify-content":!1,"justify-items":!1,"justify-self":!1,left:!1,"letter-spacing":!0,"lighting-color":!0,"line-box-contain":!1,"line-break":!1,"line-grid":!1,"line-height":!1,"line-snap":!1,"line-stacking":!1,"line-stacking-ruby":!1,"line-stacking-shift":!1,"line-stacking-strategy":!1,"list-style":!0,"list-style-image":!0,"list-style-position":!0,"list-style-type":!0,margin:!0,"margin-bottom":!0,"margin-left":!0,"margin-right":!0,"margin-top":!0,"marker-offset":!1,"marker-side":!1,marks:!1,mask:!1,"mask-box":!1,"mask-box-outset":!1,"mask-box-repeat":!1,"mask-box-slice":!1,"mask-box-source":!1,"mask-box-width":!1,"mask-clip":!1,"mask-image":!1,"mask-origin":!1,"mask-position":!1,"mask-repeat":!1,"mask-size":!1,"mask-source-type":!1,"mask-type":!1,"max-height":!0,"max-lines":!1,"max-width":!0,"min-height":!0,"min-width":!0,"move-to":!1,"nav-down":!1,"nav-index":!1,"nav-left":!1,"nav-right":!1,"nav-up":!1,"object-fit":!1,"object-position":!1,opacity:!1,order:!1,orphans:!1,outline:!1,"outline-color":!1,"outline-offset":!1,"outline-style":!1,"outline-width":!1,overflow:!1,"overflow-wrap":!1,"overflow-x":!1,"overflow-y":!1,padding:!0,"padding-bottom":!0,"padding-left":!0,"padding-right":!0,"padding-top":!0,page:!1,"page-break-after":!1,"page-break-before":!1,"page-break-inside":!1,"page-policy":!1,pause:!1,"pause-after":!1,"pause-before":!1,perspective:!1,"perspective-origin":!1,pitch:!1,"pitch-range":!1,"play-during":!1,position:!1,"presentation-level":!1,quotes:!1,"region-fragment":!1,resize:!1,rest:!1,"rest-after":!1,"rest-before":!1,richness:!1,right:!1,rotation:!1,"rotation-point":!1,"ruby-align":!1,"ruby-merge":!1,"ruby-position":!1,"shape-image-threshold":!1,"shape-outside":!1,"shape-margin":!1,size:!1,speak:!1,"speak-as":!1,"speak-header":!1,"speak-numeral":!1,"speak-punctuation":!1,"speech-rate":!1,stress:!1,"string-set":!1,"tab-size":!1,"table-layout":!1,"text-align":!0,"text-align-last":!0,"text-combine-upright":!0,"text-decoration":!0,"text-decoration-color":!0,"text-decoration-line":!0,"text-decoration-skip":!0,"text-decoration-style":!0,"text-emphasis":!0,"text-emphasis-color":!0,"text-emphasis-position":!0,"text-emphasis-style":!0,"text-height":!0,"text-indent":!0,"text-justify":!0,"text-orientation":!0,"text-overflow":!0,"text-shadow":!0,"text-space-collapse":!0,"text-transform":!0,"text-underline-position":!0,"text-wrap":!0,top:!1,transform:!1,"transform-origin":!1,"transform-style":!1,transition:!1,"transition-delay":!1,"transition-duration":!1,"transition-property":!1,"transition-timing-function":!1,"unicode-bidi":!1,"vertical-align":!1,visibility:!1,"voice-balance":!1,"voice-duration":!1,"voice-family":!1,"voice-pitch":!1,"voice-range":!1,"voice-rate":!1,"voice-stress":!1,"voice-volume":!1,volume:!1,"white-space":!1,widows:!1,width:!0,"will-change":!1,"word-break":!0,"word-spacing":!0,"word-wrap":!0,"wrap-flow":!1,"wrap-through":!1,"writing-mode":!1,"z-index":!1};return e}var r=/javascript\s*\:/gim;t.whiteList=n(),t.getDefaultWhiteList=n,t.onAttr=function(e,t,n){},t.onIgnoreAttr=function(e,t,n){},t.safeAttrValue=function(e,t){return r.test(t)?"":t}},function(e,t){e.exports={indexOf:function(e,t){var n,r;if(Array.prototype.indexOf)return e.indexOf(t);for(n=0,r=e.length;n<r;n++)if(e[n]===t)return n;return-1},forEach:function(e,t,n){var r,o;if(Array.prototype.forEach)return e.forEach(t,n);for(r=0,o=e.length;r<o;r++)t.call(n,e[r],r,e)},trim:function(e){return String.prototype.trim?e.trim():e.replace(/(^\s*)|(\s*$)/g,"")},trimRight:function(e){return String.prototype.trimRight?e.trimRight():e.replace(/(\s*$)/g,"")}}},function(e,t,n){"use strict";var r=n(0)("%TypeError%"),o=n(86),i=n(19),a=n(8);e.exports=function(e,t){if("Object"!==a(e))throw new r("Assertion failed: Type(O) is not Object");if(i(t))return e[t];throw new r("Assertion failed: IsPropertyKey(P) is not true, got "+o(t))}},function(e,t,n){"use strict";e.exports=function(e){return"string"==typeof e||"symbol"==typeof e}},function(e,t,n){"use strict";var n=n(0),r=n("%String%"),o=n("%TypeError%");e.exports=function(e){if("symbol"==typeof e)throw new o("Cannot convert a Symbol value to a string");return r(e)}},function(e,t,n){"use strict";e.exports=function(e){return null===e||"function"!=typeof e&&"object"!=typeof e}},function(e,t,n){"use strict";var r="undefined"!=typeof Symbol&&Symbol,o=n(23);e.exports=function(){return"function"==typeof r&&"function"==typeof Symbol&&"symbol"==typeof r("foo")&&"symbol"==typeof Symbol("bar")&&o()}},function(e,t,n){"use strict";e.exports=function(){if("function"!=typeof Symbol||"function"!=typeof Object.getOwnPropertySymbols)return!1;if("symbol"==typeof Symbol.iterator)return!0;var e={},t=Symbol("test"),n=Object(t);if("string"==typeof t)return!1;if("[object Symbol]"!==Object.prototype.toString.call(t))return!1;if("[object Symbol]"!==Object.prototype.toString.call(n))return!1;for(t in e[t]=42,e)return!1;if("function"==typeof Object.keys&&0!==Object.keys(e).length)return!1;if("function"==typeof Object.getOwnPropertyNames&&0!==Object.getOwnPropertyNames(e).length)return!1;n=Object.getOwnPropertySymbols(e);if(1!==n.length||n[0]!==t)return!1;if(!Object.prototype.propertyIsEnumerable.call(e,t))return!1;if("function"==typeof Object.getOwnPropertyDescriptor){n=Object.getOwnPropertyDescriptor(e,t);if(42!==n.value||!0!==n.enumerable)return!1}return!0}},function(e,t,n){"use strict";var r=n(23);e.exports=function(){return r()&&!!Symbol.toStringTag}},function(e,t,n){"use strict";n=n(9);e.exports=n.call(Function.call,Object.prototype.hasOwnProperty)},function(e,t,n){"use strict";var r=Object.prototype.toString;e.exports=function(e){var t=r.call(e);return"[object Arguments]"===t||"[object Array]"!==t&&null!==e&&"object"==typeof e&&"number"==typeof e.length&&0<=e.length&&"[object Function]"===r.call(e.callee)}},function(e,t,n){"use strict";var o=n(5),n=n(1),i=n("Object.prototype.propertyIsEnumerable"),a=n("Array.prototype.push");e.exports=function(e){var t,n=o(e),r=[];for(t in n)i(n,t)&&a(r,[t,n[t]]);return r}},function(e,t,n){"use strict";var r=n(27);e.exports=function(){return"function"==typeof Object.entries?Object.entries:r}},function(e,t,n){"use strict";var r=n(5),o=n(20),i=n(1)("String.prototype.replace"),a=/^[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]+/,u=/[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]+$/;e.exports=function(){var e=o(r(this));return i(i(e,a,""),u,"")}},function(e,t,n){"use strict";var r=n(29);e.exports=function(){return String.prototype.trim&&"\u200b"==="\u200b".trim()?String.prototype.trim:r}},function(e,t,n){function r(){return{a:["target","href","title"],abbr:["title"],address:[],area:["shape","coords","href","alt"],article:[],aside:[],audio:["autoplay","controls","crossorigin","loop","muted","preload","src"],b:[],bdi:["dir"],bdo:["dir"],big:[],blockquote:["cite"],br:[],caption:[],center:[],cite:[],code:[],col:["align","valign","span","width"],colgroup:["align","valign","span","width"],dd:[],del:["datetime"],details:["open"],div:[],dl:[],dt:[],em:[],figcaption:[],figure:[],font:["color","size","face"],footer:[],h1:[],h2:[],h3:[],h4:[],h5:[],h6:[],header:[],hr:[],i:[],img:["src","alt","title","width","height"],ins:["datetime"],li:[],mark:[],nav:[],ol:[],p:[],pre:[],s:[],section:[],small:[],span:[],sub:[],summary:[],sup:[],strong:[],strike:[],table:["width","border","align","valign"],tbody:["align","valign"],td:["width","rowspan","colspan","align","valign"],tfoot:["align","valign"],th:["width","rowspan","colspan","align","valign"],thead:["align","valign"],tr:["rowspan","align","valign"],tt:[],u:[],ul:[],video:["autoplay","controls","crossorigin","loop","muted","playsinline","poster","preload","src","height","width"]}}function o(e){return e.replace(v,"&lt;").replace(m,"&gt;")}function i(e){return e.replace(y,"&quot;")}function a(e){return e.replace(b,'"')}function u(e){return e.replace(D,function(e,t){return"x"===t[0]||"X"===t[0]?String.fromCharCode(parseInt(t.substr(1),16)):String.fromCharCode(parseInt(t,10))})}function s(e){return e.replace(w,":").replace(x," ")}function l(e){for(var t="",n=0,r=e.length;n<r;n++)t+=e.charCodeAt(n)<32?" ":e.charAt(n);return h.trim(t)}function c(e){return l(e=s(e=u(e=a(e))))}function p(e){return o(e=i(e))}var f=n(7).FilterCSS,d=n(7).getDefaultWhiteList,h=n(11),g=new f,v=/</g,m=/>/g,y=/"/g,b=/&quot;/g,D=/&#([a-zA-Z0-9]*);?/gim,w=/&colon;?/gim,x=/&newline;?/gim,A=/((j\s*a\s*v\s*a|v\s*b|l\s*i\s*v\s*e)\s*s\s*c\s*r\s*i\s*p\s*t\s*|m\s*o\s*c\s*h\s*a)\:/gi,k=/e\s*x\s*p\s*r\s*e\s*s\s*s\s*i\s*o\s*n\s*\(.*/gi,E=/u\s*r\s*l\s*\(.*/gi;t.whiteList=r(),t.getDefaultWhiteList=r,t.onTag=function(e,t,n){},t.onIgnoreTag=function(e,t,n){},t.onTagAttr=function(e,t,n){},t.onIgnoreTagAttr=function(e,t,n){},t.safeAttrValue=function(e,t,n,r){if(n=c(n),"href"===t||"src"===t){if("#"===(n=h.trim(n)))return"#";if("http://"!==n.substr(0,7)&&"https://"!==n.substr(0,8)&&"mailto:"!==n.substr(0,7)&&"tel:"!==n.substr(0,4)&&"data:image/"!==n.substr(0,11)&&"ftp://"!==n.substr(0,6)&&"./"!==n.substr(0,2)&&"../"!==n.substr(0,3)&&"#"!==n[0]&&"/"!==n[0])return""}else if("background"===t){if(A.lastIndex=0,A.test(n))return""}else if("style"===t){if(k.lastIndex=0,k.test(n))return"";if(E.lastIndex=0,E.test(n)&&(A.lastIndex=0,A.test(n)))return"";!1!==r&&(n=(r=r||g).process(n))}return p(n)},t.escapeHtml=o,t.escapeQuote=i,t.unescapeQuote=a,t.escapeHtmlEntities=u,t.escapeDangerHtml5Entities=s,t.clearNonPrintableCharacter=l,t.friendlyAttrValue=c,t.escapeAttrValue=p,t.onIgnoreTagStripAll=function(){return""},t.StripTagBody=function(i,a){"function"!=typeof a&&(a=function(){});var u=!Array.isArray(i),s=[],l=!1;return{onIgnoreTag:function(e,t,n){var r,o;return o=e,u||-1!==h.indexOf(i,o)?n.isClosing?(r=n.position+(o="[/removed]").length,s.push([!1!==l?l:n.position,r]),l=!1,o):(l=l||n.position,"[removed]"):a(e,t,n)},remove:function(t){var n="",r=0;return h.forEach(s,function(e){n+=t.slice(r,e[0]),r=e[1]}),n+=t.slice(r)}}},t.stripCommentTag=function(e){for(var t="",n=0;n<e.length;){var r=e.indexOf("\x3c!--",n);if(-1===r){t+=e.slice(n);break}t+=e.slice(n,r);r=e.indexOf("--\x3e",r);if(-1===r)break;n=r+3}return t},t.stripBlankChar=function(e){return e.split("").filter(function(e){e=e.charCodeAt(0);return!(127===e||e<=31&&10!==e&&13!==e)}).join("")},t.cssFilter=g,t.getDefaultCSSWhiteList=d},function(e,t,n){function h(e){var t=d.spaceIndex(e);return e=-1===t?e.slice(1,-1):e.slice(1,t+1),e="/"===(e="/"===(e=d.trim(e).toLowerCase()).slice(0,1)?e.slice(1):e).slice(-1)?e.slice(0,-1):e}function g(e){return"</"===e.slice(0,2)}function c(e,t){for(;t<e.length;t++){var n=e[t];if(" "!==n)return"="===n?t:-1}}function p(e,t){for(;0<t;t--){var n=e[t];if(" "!==n)return"="===n?t:-1}}function f(e){return'"'===(t=e)[0]&&'"'===t[t.length-1]||"'"===t[0]&&"'"===t[t.length-1]?e.substr(1,e.length-2):e;var t}var d=n(11),v=/[^a-zA-Z0-9_:\.\-]/gim;t.parseTag=function(e,t,n){"use strict";var r,o,i="",a=0,u=!1,s=!1,l=0,c=e.length;e:for(l=0;l<c;l++){var p=e.charAt(l);if(!1===u)"<"===p&&(u=l);else if(!1===s){if("<"===p)i+=n(e.slice(a,l)),a=u=l;else if(">"===p)i+=n(e.slice(a,u)),r=h(o=e.slice(u,l+1)),i+=t(u,i.length,r,o,g(o)),a=l+1,u=!1;else if('"'===p||"'"===p)for(var f=1,d=e.charAt(l-f);""===d.trim()||"="===d;){if("="===d){s=p;continue e}d=e.charAt(l-++f)}}else if(p===s){s=!1;continue}}return a<e.length&&(i+=n(e.substr(a))),i},t.parseAttr=function(e,n){"use strict";function t(e,t){(e=(e=d.trim(e)).replace(v,"").toLowerCase()).length<1||(e=n(e,t||""))&&o.push(e)}for(var r=0,o=[],i=!1,a=e.length,u=0;u<a;u++){var s,l=e.charAt(u);if(!1!==i||"="!==l)if(!1===i||u!==r||'"'!==l&&"'"!==l||"="!==e.charAt(u-1))/\s|\n|\t/.test(l)&&(e=e.replace(/\s|\n|\t/g," "),!1===i?-1===(s=c(e,u))?(t(d.trim(e.slice(r,u))),i=!1,r=u+1):u=s-1:-1===(s=p(e,u-1))&&(t(i,f(d.trim(e.slice(r,u)))),i=!1,r=u+1));else{if(-1===(s=e.indexOf(l,u+1)))break;t(i,d.trim(e.slice(r+1,s))),i=!1,r=(u=s)+1}else i=e.slice(r,u),r=u+1}return r<e.length&&(!1===i?t(e.slice(r)):t(i,f(d.trim(e.slice(r))))),d.trim(o.join(" "))}},function(e,t,n){var r;
/*!
	autosize 4.0.4
	license: MIT
	http://www.jacklmoore.com/autosize
*/void 0!==(t="function"==typeof(r=function(e,t){"use strict";function n(o){function i(e){var t=o.style.width;o.style.width="0px",o.offsetWidth,o.style.width=t,o.style.overflowY=e}function n(e){for(var t=[];e&&e.parentNode&&e.parentNode instanceof Element;)e.parentNode.scrollTop&&t.push({node:e.parentNode,scrollTop:e.parentNode.scrollTop}),e=e.parentNode;return t}function a(){if(0!==o.scrollHeight){var e=n(o),t=document.documentElement&&document.documentElement.scrollTop;o.style.height="",o.style.height=o.scrollHeight+u+"px",s=o.clientWidth,e.forEach(function(e){e.node.scrollTop=e.scrollTop}),t&&(document.documentElement.scrollTop=t)}}function r(){a();var e=Math.round(parseFloat(o.style.height)),t=window.getComputedStyle(o,null),n="content-box"===t.boxSizing?Math.round(parseFloat(t.height)):o.offsetHeight;if(n<e?"hidden"===t.overflowY&&(i("scroll"),a(),n="content-box"===t.boxSizing?Math.round(parseFloat(window.getComputedStyle(o,null).height)):o.offsetHeight):"hidden"!==t.overflowY&&(i("hidden"),a(),n="content-box"===t.boxSizing?Math.round(parseFloat(window.getComputedStyle(o,null).height)):o.offsetHeight),l!==n){l=n;var r=f("autosize:resized");try{o.dispatchEvent(r)}catch(e){}}}if(o&&o.nodeName&&"TEXTAREA"===o.nodeName&&!p.has(o)){var u=null,s=null,l=null,e=function(){o.clientWidth!==s&&r()},c=function(t){window.removeEventListener("resize",e,!1),o.removeEventListener("input",r,!1),o.removeEventListener("keyup",r,!1),o.removeEventListener("autosize:destroy",c,!1),o.removeEventListener("autosize:update",r,!1),Object.keys(t).forEach(function(e){o.style[e]=t[e]}),p.delete(o)}.bind(o,{height:o.style.height,resize:o.style.resize,overflowY:o.style.overflowY,overflowX:o.style.overflowX,wordWrap:o.style.wordWrap});o.addEventListener("autosize:destroy",c,!1),"onpropertychange"in o&&"oninput"in o&&o.addEventListener("keyup",r,!1),window.addEventListener("resize",e,!1),o.addEventListener("input",r,!1),o.addEventListener("autosize:update",r,!1),o.style.overflowX="hidden",o.style.wordWrap="break-word",p.set(o,{destroy:c,update:r}),function(){var e=window.getComputedStyle(o,null);"vertical"===e.resize?o.style.resize="none":"both"===e.resize&&(o.style.resize="horizontal"),u="content-box"===e.boxSizing?-(parseFloat(e.paddingTop)+parseFloat(e.paddingBottom)):parseFloat(e.borderTopWidth)+parseFloat(e.borderBottomWidth),isNaN(u)&&(u=0),r()}()}}function r(e){var t=p.get(e);t&&t.destroy()}function o(e){var t=p.get(e);t&&t.update()}var p="function"==typeof Map?new Map:function(){var n=[],r=[];return{has:function(e){return n.indexOf(e)>-1},get:function(e){return r[n.indexOf(e)]},set:function(e,t){-1===n.indexOf(e)&&(n.push(e),r.push(t))},delete:function(e){var t=n.indexOf(e);t>-1&&(n.splice(t,1),r.splice(t,1))}}}(),f=function(e){return new Event(e,{bubbles:!0})};try{new Event("test")}catch(e){f=function(e){var t=document.createEvent("Event");return t.initEvent(e,!0,!1),t}}var i=null;"undefined"==typeof window||"function"!=typeof window.getComputedStyle?((i=function(e){return e}).destroy=function(e){return e},i.update=function(e){return e}):((i=function(e,t){return e&&Array.prototype.forEach.call(e.length?e:[e],function(e){return n(e)}),e}).destroy=function(e){return e&&Array.prototype.forEach.call(e.length?e:[e],r),e},i.update=function(e){return e&&Array.prototype.forEach.call(e.length?e:[e],o),e}),t.default=i,e.exports=t.default})?r.apply(t,[e,t]):r)&&(e.exports=t)},function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{default:e}}function o(e){return e&&this.init(e),this}function i(e){return new o(e)}function l(e,t){var e=new e,n=new AV.ACL;n.setPublicReadAccess(!0),n.setPublicWriteAccess(!0),e.setACL(n),e.set("url",t.url),e.set("xid",t.xid),e.set("title",t.title),e.set("time",1),e.save().then(function(e){(0,L.default)(t.el).find(".leancloud-visitors-count").text(1)}).catch(function(e){})}var j=r(n(42)),T=r(n(33)),a=r(n(37)),z=r(n(12)),I=n(6),R=r(n(41)),b=r(n(36)),P=n(40),M=r(n(38)),L=r(n(3)),N=r(n(39)),U=r(n(13)),Q=(r(n(35)),{comment:"",nick:"",mail:"",link:"",ua:L.default.ua,url:"",QQAvatar:""}),q="",W={},V={cdn:"https://gravatar.loli.net/avatar/",ds:["mp","identicon","monsterid","wavatar","robohash","retro",""],params:"",hide:!1},D=(o.prototype.init=function(e){if("undefined"==typeof document)throw new Error("Sorry, Valine does not support Server-side rendering.");return e&&(e=L.default.extend(I.CONFIG,e),this.i18n=(0,a.default)(e.lang||L.default.lang,e.langMode),this.cfg=e,z.default.maps=!!e.emojiMaps&&e.emojiMaps||z.default.maps,z.default.cdn=!!e.emojiCDN&&e.emojiCDN||z.default.cdn,this._init()),this},o.prototype._init=function(){var i=this;try{var e,t,n,r,o,a=i.cfg,u=a.avatar,s=a.avatarForce,l=a.avatar_cdn,c=a.visitor,p=a.path,f=void 0===p?location.pathname:p,d=a.pageSize,h=a.recordIP,g=(i.cfg.path=f.replace(/index\.html?$/,""),V.ds),v=s?"&q="+(0,I.RandomStr)():"",m=(V.params="?d="+(-1<g.indexOf(u)?u:"mp")+"&v="+I.VERSION+v,V.hide="hide"===u,V.cdn=/^https?\:\/\//.test(l)?l:V.cdn,i.cfg.pageSize=isNaN(d)||d<1?10:d,h&&(0,P.recordIPFn)(function(e){return Q.ip=e}),i.cfg.el||null),y=(0,L.default)(m);(m=m instanceof HTMLElement?m:y[y.length-1]||null)&&(i.$el=(0,L.default)(m),i.$el.addClass("v").attr("data-class","v"),V.hide&&i.$el.addClass("hide-avatar"),i.cfg.meta=(i.cfg.guest_info||i.cfg.meta||I.defaultMeta).filter(function(e){return-1<I.defaultMeta.indexOf(e)}),i.cfg.requiredFields=i.cfg.requiredFields.filter(function(e){return-1<I.defaultMeta.indexOf(e)}),e=(0==i.cfg.meta.length?I.defaultMeta:i.cfg.meta).map(function(e){var t="mail"==e?"email":"text";return-1<I.defaultMeta.indexOf(e)?'<input name="'+e+'" placeholder="'+(i.cfg.metaPlaceholder[e]||i.i18n.t(e))+'" class="v'+e+' vinput" type="'+t+'">':""}),t='<div class="vpanel"><div class="vwrap"><p class="cancel-reply text-right" style="display:none;" title="'+i.i18n.t("cancelReply")+'"><svg class="vicon cancel-reply-btn" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4220" width="22" height="22"><path d="M796.454 985H227.545c-50.183 0-97.481-19.662-133.183-55.363-35.7-35.701-55.362-83-55.362-133.183V227.545c0-50.183 19.662-97.481 55.363-133.183 35.701-35.7 83-55.362 133.182-55.362h568.909c50.183 0 97.481 19.662 133.183 55.363 35.701 35.702 55.363 83 55.363 133.183v568.909c0 50.183-19.662 97.481-55.363 133.183S846.637 985 796.454 985zM227.545 91C152.254 91 91 152.254 91 227.545v568.909C91 871.746 152.254 933 227.545 933h568.909C871.746 933 933 871.746 933 796.454V227.545C933 152.254 871.746 91 796.454 91H227.545z" p-id="4221"></path><path d="M568.569 512l170.267-170.267c15.556-15.556 15.556-41.012 0-56.569s-41.012-15.556-56.569 0L512 455.431 341.733 285.165c-15.556-15.556-41.012-15.556-56.569 0s-15.556 41.012 0 56.569L455.431 512 285.165 682.267c-15.556 15.556-15.556 41.012 0 56.569 15.556 15.556 41.012 15.556 56.569 0L512 568.569l170.267 170.267c15.556 15.556 41.012 15.556 56.569 0 15.556-15.556 15.556-41.012 0-56.569L568.569 512z" p-id="4222" ></path></svg></p><div class="vheader item'+e.length+'">'+e.join("")+'</div><div class="vedit"><textarea id="veditor" class="veditor vinput" placeholder="'+i.cfg.placeholder+'"></textarea><div class="vrow"><div class="vcol vcol-60 status-bar"></div><div class="vcol vcol-40 vctrl text-right"><span title="'+i.i18n.t("emoji")+'"  class="vicon vemoji-btn"><svg  viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="16172" width="22" height="22" ><path d="M512 1024a512 512 0 1 1 512-512 512 512 0 0 1-512 512zM512 56.888889a455.111111 455.111111 0 1 0 455.111111 455.111111 455.111111 455.111111 0 0 0-455.111111-455.111111zM312.888889 512A85.333333 85.333333 0 1 1 398.222222 426.666667 85.333333 85.333333 0 0 1 312.888889 512z" p-id="16173"></path><path d="M512 768A142.222222 142.222222 0 0 1 369.777778 625.777778a28.444444 28.444444 0 0 1 56.888889 0 85.333333 85.333333 0 0 0 170.666666 0 28.444444 28.444444 0 0 1 56.888889 0A142.222222 142.222222 0 0 1 512 768z" p-id="16174"></path><path d="M782.222222 391.964444l-113.777778 59.733334a29.013333 29.013333 0 0 1-38.684444-10.808889 28.444444 28.444444 0 0 1 10.24-38.684445l113.777778-56.888888a28.444444 28.444444 0 0 1 38.684444 10.24 28.444444 28.444444 0 0 1-10.24 36.408888z" p-id="16175"></path><path d="M640.568889 451.697778l113.777778 56.888889a27.875556 27.875556 0 0 0 38.684444-10.24 27.875556 27.875556 0 0 0-10.24-38.684445l-113.777778-56.888889a28.444444 28.444444 0 0 0-38.684444 10.808889 28.444444 28.444444 0 0 0 10.24 38.115556z" p-id="16176"></path></svg></span><span title="'+i.i18n.t("preview")+'" class="vicon vpreview-btn"><svg  viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="17688" width="22" height="22"><path d="M502.390154 935.384615a29.538462 29.538462 0 1 1 0 59.076923H141.430154C79.911385 994.461538 29.538462 946.254769 29.538462 886.153846V137.846154C29.538462 77.745231 79.950769 29.538462 141.390769 29.538462h741.218462c61.44 0 111.852308 48.206769 111.852307 108.307692v300.268308a29.538462 29.538462 0 1 1-59.076923 0V137.846154c0-26.899692-23.355077-49.230769-52.775384-49.230769H141.390769c-29.420308 0-52.775385 22.331077-52.775384 49.230769v748.307692c0 26.899692 23.355077 49.230769 52.775384 49.230769h360.999385z" p-id="17689"></path><path d="M196.923077 216.615385m29.538461 0l374.153847 0q29.538462 0 29.538461 29.538461l0 0q0 29.538462-29.538461 29.538462l-374.153847 0q-29.538462 0-29.538461-29.538462l0 0q0-29.538462 29.538461-29.538461Z" p-id="17690"></path><path d="M649.846154 846.769231a216.615385 216.615385 0 1 0 0-433.230769 216.615385 216.615385 0 0 0 0 433.230769z m0 59.076923a275.692308 275.692308 0 1 1 0-551.384616 275.692308 275.692308 0 0 1 0 551.384616z" p-id="17691"></path><path d="M807.398383 829.479768m20.886847-20.886846l0 0q20.886846-20.886846 41.773692 0l125.321079 125.321079q20.886846 20.886846 0 41.773693l0 0q-20.886846 20.886846-41.773693 0l-125.321078-125.321079q-20.886846-20.886846 0-41.773693Z" p-id="17692"></path></svg></span></div></div></div><div class="vrow"><div class="vcol vcol-30" ><a alt="Markdown is supported" href="https://guides.github.com/features/mastering-markdown/" class="vicon" target="_blank"><svg class="markdown" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M14.85 3H1.15C.52 3 0 3.52 0 4.15v7.69C0 12.48.52 13 1.15 13h13.69c.64 0 1.15-.52 1.15-1.15v-7.7C16 3.52 15.48 3 14.85 3zM9 11H7V8L5.5 9.92 4 8v3H2V5h2l1.5 2L7 5h2v6zm2.99.5L9.5 8H11V5h2v3h1.5l-2.51 3.5z"></path></svg></a></div><div class="vcol vcol-70 text-right"><button type="button"  title="Cmd|Ctrl+Enter" class="vsubmit vbtn">'+i.i18n.t("submit")+'</button></div></div><div class="vemojis" style="display:none;"></div><div class="vinput vpreview" style="display:none;"></div></div></div><div class="vcount" style="display:none;"><span class="vnum">0</span> '+i.i18n.t("comments")+'</div><div class="vload-top text-center" style="display:none;"><i class="vspinner" style="width:30px;height:30px;"></i></div><div class="vcards"></div><div class="vload-bottom text-center" style="display:none;"><i class="vspinner" style="width:30px;height:30px;"></i></div><div class="vempty" style="display:none;"></div><div class="vpage txt-center" style="display:none"><button type="button" class="vmore vbtn">'+i.i18n.t("more")+'</button></div><div class="vpower txt-right">Powered By <a href="https://valine.js.org" target="_blank">Valine</a><br>v'+I.VERSION+"</div>",i.$el.html(t),i.$el.find(".cancel-reply").on("click",function(e){i.reset()}),n=i.$el.find(".vempty"),i.$nodata={show:function(e){return n.html(e||i.i18n.t("sofa")).show(),i},hide:function(){return n.hide(),i}},r=i.$el.find(".vload-bottom"),o=i.$el.find(".vload-top"),i.$loading={show:function(e){return e&&o.show()||r.show(),i.$nodata.hide(),i},hide:function(){return o.hide(),r.hide(),0===i.$el.find(".vcard").length&&i.$nodata.show(),i}}),(0,b.default)(i.cfg,function(e){var t=(0,L.default)(".valine-comment-count"),o=0;!function t(n){var e,r=n[o++];r&&(e=(0,L.default)(r).attr("data-xid"))&&i.Q(e).count().then(function(e){r.innerText=e,t(n)}).catch(function(e){r.innerText=0})}(t),c&&D.add(AV.Object.extend("Counter"),i.cfg.path),i.$el&&i.bind()})}catch(a){(0,M.default)(i,a,"init")}},{add:function(t,e){var n,r,o,i,a,u=this,s=(0,L.default)(".leancloud_visitors,.leancloud-visitors");1===s.length?(n=s[0],r=decodeURI((0,L.default)(n).attr("id")),o=(0,L.default)(n).attr("data-flag-title"),a=encodeURI(r),i={el:n,url:r,xid:a,title:o},decodeURI(r)===decodeURI(e)?((a=new AV.Query(t)).equalTo("url",r),a.find().then(function(e){0<e.length?((e=e[0]).increment("time"),e.save().then(function(e){(0,L.default)(n).find(".leancloud-visitors-count").text(e.get("time"))}).catch(function(e){})):l(t,i)}).catch(function(e){101==e.code?l(t,i):(0,M.default)(u,e)})):D.show(t,s)):D.show(t,s)},show:function(e,t){var n=[];t.forEach(function(e){var t=(0,L.default)(e).find(".leancloud-visitors-count");t&&t.text("0"),n.push(/\%/.test((0,L.default)(e).attr("id"))?decodeURI((0,L.default)(e).attr("id")):(0,L.default)(e).attr("id"))}),n.length&&((e=new AV.Query(e)).containedIn("url",n),e.find().then(function(e){0<e.length&&t.forEach(function(o){e.forEach(function(e){var t=e.get("xid")||encodeURI(e.get("url")),e=e.get("time"),n=(0,L.default)(o),r=n.attr("id");(/\%/.test(r)?r:encodeURI(r))==t&&(r=n.find(".leancloud-visitors-count"))&&r.text(e)})})}).catch(function(e){}))}});o.prototype.Q=function(e){var t,n=this.cfg.clazzName;if(1==arguments.length)return(t=new AV.Query(n)).doesNotExist("rid"),(r=new AV.Query(n)).equalTo("rid",""),t=AV.Query.or(t,r),"*"===e?t.exists("url"):t.equalTo("url",decodeURI(e)),t.addDescending("createdAt"),t.addDescending("insertedAt"),t;var r=JSON.stringify(arguments[1]).replace(/(\[|\])/g,"");return AV.Query.doCloudQuery("select * from "+n+" where rid in ("+r+") order by -createdAt,-createdAt")},o.prototype.installLocale=function(e,t){return this.i18n(e,t),this},o.prototype.setPath=function(e){return this.config.path=e,this},o.prototype.bind=function(){var e,s=this,n=s.$el.find(".vemojis"),t=s.$el.find(".vpreview"),r=s.$el.find(".vemoji-btn"),o=s.$el.find(".vpreview-btn"),i=s.$el.find(".veditor"),a=z.default.maps,u=!1,l=(s.$emoji={show:function(){if(!u){var e,t=[];for(e in a)a.hasOwnProperty(e)&&z.default.build(e)&&t.push('<i title="'+e+'" >'+z.default.build(e)+"</i>");n.html(t.join("")),u=!0,n.find("i").on("click",function(e){e.preventDefault(),h(i[0]," :"+(0,L.default)(this).attr("title")+":")})}return s.$preview.hide(),n.show(),r.addClass("actived"),s.$emoji},hide:function(){return r.removeClass("actived"),n.hide(),s.$emoji}},s.$preview={show:function(){return q?(s.$emoji.hide(),o.addClass("actived"),t.html((0,N.default)(q)).show(),x()):s.$preview.hide(),s.$preview},hide:function(){return o.removeClass("actived"),t.hide().html(""),s.$preview}},function(e){e=e.val()||"";e||s.$preview.hide(),q!=e&&(q=e,-1<o.hasClass("actived")&&q!=t.html()&&t.html((0,N.default)(q)),x())}),c=(r.on("click",function(e){r.hasClass("actived")?s.$emoji.hide():s.$emoji.show()}),o.on("click",function(e){o.hasClass("actived")?s.$preview.hide():s.$preview.show()}),s.cfg.meta),p={},f={veditor:"comment"};for(e in c.forEach(function(e){f["v"+e]=e}),f)f.hasOwnProperty(e)&&function(){var t=f[e],r=s.$el.find("."+e);(p[t]=r).on("input change blur propertychange",function(e){s.cfg.enableQQ&&"blur"===e.type&&"nick"===t&&(r.val()&&!isNaN(r.val())?(0,P.fetchQQFn)(r.val(),function(e){var t=e.nick||r.val(),n=e.qq+"@qq.com";(0,L.default)(".vnick").val(t),(0,L.default)(".vmail").val(n),Q.nick=t,Q.mail=n,Q.QQAvatar=e.pic}):L.default.store.get(I.QQCacheKey)&&L.default.store.get(I.QQCacheKey).nick!=r.val()&&(L.default.store.remove(I.QQCacheKey),Q.nick=r.val(),Q.mail="",Q.QQAvatar="")),"comment"===t?((0,T.default)(r[0]),d(function(e){l(r)})()):Q[t]=(0,U.default)(r.val().replace(/(^\s*)|(\s*$)/g,"").substring(0,35))})}();var d=function(n){var r=1<arguments.length&&void 0!==arguments[1]?arguments[1]:300,o=void 0;return function(){var e=this,t=arguments;o&&clearTimeout(o),o=setTimeout(function(){n.apply(e,t)},r)}},h=function(t,e){var n,r,o;document.selection?(t.focus(),document.selection.createRange().text=e,t.focus()):t.selectionStart||"0"==t.selectionStart?(n=t.selectionStart,r=t.selectionEnd,o=t.scrollTop,t.value=t.value.substring(0,n)+e+t.value.substring(r,t.value.length),t.focus(),t.selectionStart=n+e.length,t.selectionEnd=n+e.length,t.scrollTop=o):(t.focus(),t.value+=e),d(function(e){l((0,L.default)(t))})()},g={no:1,size:s.cfg.pageSize,skip:s.cfg.pageSize},v=s.$el.find(".vpage"),m=(v.on("click",function(e){v.hide(),g.no++,m()}),function(){var n=g.size,r=g.no,o=Number(s.$el.find(".vnum").text()),e=(s.$loading.show(),s.Q(s.cfg.path));e.limit(n),e.skip((r-1)*n),e.find().then(function(e){var t;g.skip=g.size,e&&e.length?(t=[],e.forEach(function(e){t.push(e.id),b(e,s.$el.find(".vcards"),!0)}),s.Q(s.cfg.path,t).then(function(e){(e&&e.results||[]).forEach(function(e){b(e,(0,L.default)('.vquote[data-self-id="'+e.get("rid")+'"]'))})}).catch(function(e){}),n*r<o?v.show():v.hide(),x()):s.$nodata.show(),s.$loading.hide()}).catch(function(e){s.$loading.hide(),(0,M.default)(s,e,"query")})}),y=(s.Q(s.cfg.path).count().then(function(e){0<e?(s.$el.find(".vcount").show().find(".vnum").text(e),m()):s.$loading.hide()}).catch(function(e){(0,M.default)(s,e,"count")}),function(){var e=(0<arguments.length&&void 0!==arguments[0]?arguments[0]:"").match(/(https?|http):\/\/[-A-Za-z0-9+&@#/%?=~_|!:,.;]+[-A-Za-z0-9+&@#/%=~_|]/g)||[];return 0<e.length?e[0]:""}),b=function(e,t,n){var r=(0,L.default)('<div class="vcard" id="'+e.id+'"></div>'),o=(0,U.default)(e.get("ua")),i="",o=(o&&!/ja/.test(s.cfg.lang)&&(i=(o=L.default.detect(o)).version?o.os?'<span class="vsys"><i class="browser-icon fab fa-'+(["xiaomi"].includes(o.browser.toLowerCase())?"mobile-alt fas":o.browser.toLowerCase())+'"></i>'+o.browser+" "+o.version+'</span> <span class="vsys"><i class="os-icon fab fa-'+(["mac os","ios"].includes(o.os.toLowerCase())?"apple":o.os.toLowerCase())+'"></i>'+o.os+" "+o.osVersion+"</span>":"":'<span class="vsys">'+o.browser+"</span>"),"*"===s.cfg.path&&(i='<a href="'+e.get("url")+'" class="vsys">'+e.get("url")+"</a>"),s.cfg.master.includes((0,j.default)(e.get("mail")))),a=s.cfg.friends.includes((0,j.default)(e.get("mail").toLowerCase())),o=o?'<span class="vtag vmaster">'+s.cfg.tagMeta[0]+"</span>":a?'<span class="vtag vfriend">'+s.cfg.tagMeta[1]+"</span>":'<span class="vtag vvisitor">'+s.cfg.tagMeta[2]+"</span>",a=e.get("link")?/^https?\:\/\//.test(e.get("link"))?e.get("link"):"http://"+e.get("link"):"",u=L.default.escape((0,U.default)(e.get("nick").substring(0,30))),a=a?'<a class="vnick" rel="nofollow" href="'+y(a)+'" target="_blank" >'+u+"</a>"+o:'<span class="vnick">'+u+"</span>"+o,u=(V.hide?"":s.cfg.enableQQ&&e.get("QQAvatar")?(0,U.default)('<img class="vimg" src="'+y(e.get("QQAvatar"))+'" referrerPolicy="no-referrer"/>'):'<img class="vimg" src="'+(V.cdn+(0,j.default)(e.get("mail"))+V.params)+'">')+'<div class="vh"><div class="vhead">'+a+" "+i+'</div><div class="vmeta"><span class="vtime" >'+(0,R.default)(e.get("insertedAt"),s.i18n)+'</span><span class="vat" data-vm-id="'+(e.get("rid")||e.id)+'" data-self-id="'+e.id+'">'+s.i18n.t("reply")+'</span></div><div class="vcontent" data-expand="'+s.i18n.t("expand")+'">'+(0,N.default)(e.get("comment"))+'</div><div class="vreply-wrapper" data-self-id="'+e.id+'"></div><div class="vquote" data-self-id="'+e.id+'"></div></div>',o=(r.html(u),r.find(".vat")),a=(r.find("a:not(.at)").forEach(function(e){(0,L.default)(e).attr({target:"_blank",rel:"noopener"})}),n?t.append(r):t.prepend(r),r.find(".vcontent"));a&&A(a),o&&w(o,e)},D={},w=function(i,a){i.on("click",function(e){var t=i.attr("data-vm-id"),n=i.attr("data-self-id"),r=s.$el.find(".vwrap"),o="@"+L.default.escape(a.get("nick"));(0,L.default)('.vreply-wrapper[data-self-id="'+n+'"]').append(r).find(".cancel-reply").show(),D={at:L.default.escape(o)+" ",rid:t,pid:n,rmail:a.get("mail")},p.comment.attr({placeholder:o})[0].focus()})},x=function(){setTimeout(function(){try{s.cfg.mathjax&&"MathJax"in window&&"version"in window.MathJax&&(/^3.*/.test(window.MathJax.version)&&MathJax.typeset()||MathJax.Hub.Queue(["Typeset",MathJax.Hub,document.querySelector(".v")])),"renderMathInElement"in window&&renderMathInElement((0,L.default)(".v")[0],{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})}catch(e){}},100)},A=function(t){setTimeout(function(){200<t[0].offsetHeight&&(t.addClass("expand"),t.on("click",function(e){t.removeClass("expand")}))})},k=void 0;if(k=L.default.store.get(I.MetaCacheKey)||k)for(var E in c)c.hasOwnProperty(E)&&(E=c[E],s.$el.find(".v"+E).val(L.default.unescape(k[E])),Q[E]=k[E]);function F(e){if(-1<s.cfg.requiredFields.indexOf("nick")&&Q.nick.length<3)return p.nick[0].focus(),void s.$el.find(".status-bar").text(""+s.i18n.t("nickFail")).empty(3e3);if(-1<s.cfg.requiredFields.indexOf("mail")&&!/^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/.test(Q.mail))return p.mail[0].focus(),void s.$el.find(".status-bar").text(""+s.i18n.t("mailFail")).empty(3e3);if(""==q)p.comment[0].focus();else{for(var t in W){var n;W.hasOwnProperty(t)&&(n=W[t],q=q.replace(t,n),URL.revokeObjectURL(t))}W={},Q.comment=(0,U.default)(q),Q.nick=Q.nick||"Anonymous";var r=L.default.store.get("vlx");r&&Date.now()/1e3-r/1e3<20?s.$el.find(".status-bar").text(s.i18n.t("busy")).empty(3e3):O()}}var C=L.default.store.get(I.QQCacheKey),_=(Q.QQAvatar=s.cfg.enableQQ&&!!C&&C.pic||"",s.reset=function(){Q.comment="",p.comment.val(""),l(p.comment),p.comment.attr("placeholder",s.cfg.placeholder),D={},s.$preview.hide(),s.$el.find(".vpanel").append(s.$el.find(".vwrap")),s.$el.find(".cancel-reply").hide(),q="",T.default.update(p.comment[0])},s.$el.find(".vsubmit")),S=function(){var e=new AV.ACL;return e.setPublicReadAccess(!0),e.setPublicWriteAccess(!1),e},O=function(){L.default.store.set("vlx",Date.now()),_.attr({disabled:!0}),s.$loading.show(!0);var e,t,n,r=new(AV.Object.extend(s.cfg.clazzName||"Comment"));for(t in Q.url=decodeURI(s.cfg.path),Q.insertedAt=new Date,D.rid&&(e=D.pid||D.rid,r.set("rid",D.rid),r.set("pid",e),Q.comment=q.replace("<p>",'<p><a class="at" href="#'+e+'">'+D.at+"</a> , ")),Q)Q.hasOwnProperty(t)&&(n=Q[t],r.set(t,n));r.setACL(S()),r.save().then(function(e){"Anonymous"!=Q.nick&&L.default.store.set(I.MetaCacheKey,{nick:Q.nick,link:Q.link,mail:Q.mail});var t=s.$el.find(".vnum");try{D.rid?b(e,(0,L.default)('.vquote[data-self-id="'+D.rid+'"]'),!0):((Number(t.text())?t:s.$el.find(".vcount").show().find(".vnum")).text(Number(t.text())+1),b(e,s.$el.find(".vcards")),g.skip++),_.removeAttr("disabled"),s.$loading.hide(),s.reset()}catch(e){(0,M.default)(s,e,"save")}}).catch(function(e){(0,M.default)(s,e,"commitEvt")})},B=(_.on("click",F),(0,L.default)(document).on("keydown",function(e){var t=(e=window.event||e).keyCode||e.which||e.charCode;(e.ctrlKey||e.metaKey)&&13===t&&F(),9===t&&"veditor"==(document.activeElement.id||"")&&(e.preventDefault(),h(i[0],"    "))}).on("paste",function(e){e="clipboardData"in e?e.clipboardData:e.originalEvent&&e.originalEvent.clipboardData||window.clipboardData;e&&B(e.items,!0)}),i.on("dragenter dragleave dragover drop",function(e){e.stopPropagation(),e.preventDefault(),"drop"===e.type&&B(e.dataTransfer.items)}),function(e,t){for(var n=0,r=e.length;n<r;n++){var o=e[n];if("string"===o.kind&&o.type.match("^text/html"))t||o.getAsString(function(e){e&&h(i[0],e.replace(/<[^>]+>/g,""))});else if(-1<o.type.indexOf("image")){$(o.getAsFile());continue}}}),$=function(e){try{var t=URL.createObjectURL(e),n="![image]("+t+") ",r=new FileReader;h(i[0],n),r.onload=function(){W[t]=r.result},r.readAsDataURL(e)}catch(e){}}},e.exports=i,e.exports.default=i},function(e,t,n){"use strict";t.__esModule=!0;var n=n(3),r=n&&n.__esModule?n:{default:n};t.default={getApi:function(e,t){r.default.ajax({url:"https://app-router.com/2/route",body:{appId:e}}).then(function(e){e.json().then(function(e){return t&&t("//"+e.api_server)})})}}},function(e,t,n){"use strict";t.__esModule=!0;var n=n(3),r=n&&n.__esModule?n:{default:n},u=!1;t.default=function(i,a){var e;"AV"in window&&(e=window.AV.version||window.AV.VERSION,2<parseInt(e.split(".")[0])?u=!!AV.applicationId&&!!AV.applicationKey:r.default.deleteInWin("AV",0)),u?a&&a():r.default.sdkLoader("//unpkg.com/leancloud-storage@3/dist/av-min.js","AV",function(e){var t,n="https://",r=i.app_id||i.appId,o=i.app_key||i.appKey;if(!i.serverURLs)switch(r.slice(-9)){case"-9Nh9j0Va":n+="tab.";break;case"-MdYXbMMI":n+="us."}t=i.serverURLs||n+"leancloud.cn",AV.init({appId:r,appKey:o,serverURLs:t}),u=!0,a&&a()})}},function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{default:e}}t.__esModule=!0;var o=r(n(84)),i=r(n(100)),a=r(n(101)),u=r(n(98)),n=r(n(99)),s={zh:i.default,"zh-cn":i.default,"zh-CN":i.default,"zh-TW":a.default,en:u.default,"en-US":u.default,ja:n.default,"ja-JP":n.default};t.default=function(e,t){return!s[e]&&e&&t&&(s[e]=t),new o.default({phrases:s[e||"zh"],locale:e})}},function(e,t,n){"use strict";t.__esModule=!0,t.default=function(e,t){var n,r;e.$el&&e.$loading.hide().$nodata.hide(),"[object Error]"==={}.toString.call(t)?(n=t.code||t.message||t.error||"",isNaN(n)?e.$el&&e.$nodata.show('<pre style="text-align:left;"> '+JSON.stringify(t)+"</pre>"):(r=((r=e.i18n.t("code-"+n))=="code-"+n?void 0:r)||t.message||t.error||"",101==n||-1==n?e.$nodata.show():e.$el&&e.$nodata.show('<pre style="text-align:left;">Code '+n+": "+r+"</pre>"))):e.$el&&e.$nodata.show('<pre style="text-align:left;">'+JSON.stringify(t)+"</pre>")}},function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{default:e}}t.__esModule=!0;var o=n(83),i=r(n(79)),a=r(n(3)),u=r(n(12)),s=r(n(13)),n=new o.marked.Renderer;n.code=function(e,t){return'<pre><code class="hljs language-'+t+'">'+(t&&hljs.getLanguage(t)?hljs.highlight(t,e).value:a.default.escape(e))+"</code></pre>"},o.marked.setOptions({renderer:"hljs"in window?n:new o.marked.Renderer,highlight:function(e,t){return"hljs"in window?t&&hljs.getLanguage(t)&&hljs.highlight(t,e,!0).value||hljs.highlightAuto(e).value:(0,i.default)(e)},gfm:!0,tables:!0,breaks:!0,pedantic:!1,sanitize:!1,smartLists:!0,smartypants:!0,headerPrefix:"v-"}),t.default=function(e){return(0,s.default)((0,o.marked)(u.default.parse(e,!0)))}},function(e,t,n){"use strict";t.__esModule=!0,t.recordIPFn=t.fetchQQFn=void 0;var r=n(3),o=r&&r.__esModule?r:{default:r},i=n(6);t.fetchQQFn=function(e,t){var n=o.default.store.get(i.QQCacheKey);n&&n.qq==e?t&&t(n):o.default.ajax({url:"//valine.api.ioliu.cn/getqqinfo",method:"POST",body:{qq:e}}).then(function(e){e.json().then(function(e){e.errmsg||(o.default.store.set(i.QQCacheKey,e),t&&t(e))})})},t.recordIPFn=function(t){o.default.ajax({url:"https://forge.speedtest.cn/api/location/info",method:"get"}).then(function(e){return e.json()}).then(function(e){t&&t(e.ip)})}},function(e,t,n){"use strict";t.__esModule=!0,t.default=function(e,t){if(!e)return"Invalid Date.";try{var n=p(e).getTime();if(isNaN(n))return"Invalid Date.";var r,o,i,a,u,s=(new Date).getTime()-n,l=Math.floor(s/864e5);return 0===l?(r=s%864e5,0===(o=Math.floor(r/36e5))?(i=r%36e5,0===(a=Math.floor(i/6e4))?(u=i%6e4,Math.round(u/1e3)+" "+t.t("seconds")):a+" "+t.t("minutes")):o+" "+t.t("hours")):l<0?t.t("now"):l<8?l+" "+t.t("days"):c(e)}catch(e){}};var c=function(e){var t=r(e.getDate(),2),n=r(e.getMonth()+1,2);return r(e.getFullYear(),2)+"-"+n+"-"+t},p=function e(t){return t instanceof Date?t:!isNaN(t)||/^\d+$/.test(t)?new Date(parseInt(t)):/GMT/.test(t||"")?e(new Date(t).getTime()):(t=(t||"").replace(/(^\s*)|(\s*$)/g,"").replace(/\.\d+/,"").replace(/-/,"/").replace(/-/,"/").replace(/(\d)T(\d)/,"$1 $2").replace(/Z/," UTC").replace(/([+-]\d\d):?(\d\d)/," $1$2"),new Date(t))},r=function(e,t){for(var n=e.toString();n.length<t;)n="0"+n;return n}},function(t,n,v){var m;!function(){"use strict";function p(e,t){var n=(65535&e)+(65535&t);return(e>>16)+(t>>16)+(n>>16)<<16|65535&n}function u(e,t,n,r,o,i){return p((t=p(p(t,e),p(r,i)))<<o|t>>>32-o,n)}function f(e,t,n,r,o,i,a){return u(t&n|~t&r,e,t,o,i,a)}function d(e,t,n,r,o,i,a){return u(t&r|n&~r,e,t,o,i,a)}function h(e,t,n,r,o,i,a){return u(t^n^r,e,t,o,i,a)}function g(e,t,n,r,o,i,a){return u(n^(t|~r),e,t,o,i,a)}function a(e,t){e[t>>5]|=128<<t%32,e[14+(t+64>>>9<<4)]=t;for(var n,r,o,i,a=1732584193,u=-271733879,s=-1732584194,l=271733878,c=0;c<e.length;c+=16)a=f(n=a,r=u,o=s,i=l,e[c],7,-680876936),l=f(l,a,u,s,e[c+1],12,-389564586),s=f(s,l,a,u,e[c+2],17,606105819),u=f(u,s,l,a,e[c+3],22,-1044525330),a=f(a,u,s,l,e[c+4],7,-176418897),l=f(l,a,u,s,e[c+5],12,1200080426),s=f(s,l,a,u,e[c+6],17,-1473231341),u=f(u,s,l,a,e[c+7],22,-45705983),a=f(a,u,s,l,e[c+8],7,1770035416),l=f(l,a,u,s,e[c+9],12,-1958414417),s=f(s,l,a,u,e[c+10],17,-42063),u=f(u,s,l,a,e[c+11],22,-1990404162),a=f(a,u,s,l,e[c+12],7,1804603682),l=f(l,a,u,s,e[c+13],12,-40341101),s=f(s,l,a,u,e[c+14],17,-1502002290),a=d(a,u=f(u,s,l,a,e[c+15],22,1236535329),s,l,e[c+1],5,-165796510),l=d(l,a,u,s,e[c+6],9,-1069501632),s=d(s,l,a,u,e[c+11],14,643717713),u=d(u,s,l,a,e[c],20,-373897302),a=d(a,u,s,l,e[c+5],5,-701558691),l=d(l,a,u,s,e[c+10],9,38016083),s=d(s,l,a,u,e[c+15],14,-660478335),u=d(u,s,l,a,e[c+4],20,-405537848),a=d(a,u,s,l,e[c+9],5,568446438),l=d(l,a,u,s,e[c+14],9,-1019803690),s=d(s,l,a,u,e[c+3],14,-187363961),u=d(u,s,l,a,e[c+8],20,1163531501),a=d(a,u,s,l,e[c+13],5,-1444681467),l=d(l,a,u,s,e[c+2],9,-51403784),s=d(s,l,a,u,e[c+7],14,1735328473),a=h(a,u=d(u,s,l,a,e[c+12],20,-1926607734),s,l,e[c+5],4,-378558),l=h(l,a,u,s,e[c+8],11,-2022574463),s=h(s,l,a,u,e[c+11],16,1839030562),u=h(u,s,l,a,e[c+14],23,-35309556),a=h(a,u,s,l,e[c+1],4,-1530992060),l=h(l,a,u,s,e[c+4],11,1272893353),s=h(s,l,a,u,e[c+7],16,-155497632),u=h(u,s,l,a,e[c+10],23,-1094730640),a=h(a,u,s,l,e[c+13],4,681279174),l=h(l,a,u,s,e[c],11,-358537222),s=h(s,l,a,u,e[c+3],16,-722521979),u=h(u,s,l,a,e[c+6],23,76029189),a=h(a,u,s,l,e[c+9],4,-640364487),l=h(l,a,u,s,e[c+12],11,-421815835),s=h(s,l,a,u,e[c+15],16,530742520),a=g(a,u=h(u,s,l,a,e[c+2],23,-995338651),s,l,e[c],6,-198630844),l=g(l,a,u,s,e[c+7],10,1126891415),s=g(s,l,a,u,e[c+14],15,-1416354905),u=g(u,s,l,a,e[c+5],21,-57434055),a=g(a,u,s,l,e[c+12],6,1700485571),l=g(l,a,u,s,e[c+3],10,-1894986606),s=g(s,l,a,u,e[c+10],15,-1051523),u=g(u,s,l,a,e[c+1],21,-2054922799),a=g(a,u,s,l,e[c+8],6,1873313359),l=g(l,a,u,s,e[c+15],10,-30611744),s=g(s,l,a,u,e[c+6],15,-1560198380),u=g(u,s,l,a,e[c+13],21,1309151649),a=g(a,u,s,l,e[c+4],6,-145523070),l=g(l,a,u,s,e[c+11],10,-1120210379),s=g(s,l,a,u,e[c+2],15,718787259),u=g(u,s,l,a,e[c+9],21,-343485551),a=p(a,n),u=p(u,r),s=p(s,o),l=p(l,i);return[a,u,s,l]}function s(e){for(var t="",n=32*e.length,r=0;r<n;r+=8)t+=String.fromCharCode(e[r>>5]>>>r%32&255);return t}function l(e){var t=[];for(t[(e.length>>2)-1]=void 0,r=0;r<t.length;r+=1)t[r]=0;for(var n=8*e.length,r=0;r<n;r+=8)t[r>>5]|=(255&e.charCodeAt(r/8))<<r%32;return t}function r(e){for(var t,n="0123456789abcdef",r="",o=0;o<e.length;o+=1)t=e.charCodeAt(o),r+=n.charAt(t>>>4&15)+n.charAt(15&t);return r}function c(e){return unescape(encodeURIComponent(e))}function o(e){return s(a(l(e=c(e)),8*e.length))}function i(e,t){var n,e=c(e),t=c(t),r=l(e),o=[],i=[];for(o[15]=i[15]=void 0,16<r.length&&(r=a(r,8*e.length)),n=0;n<16;n+=1)o[n]=909522486^r[n],i[n]=1549556828^r[n];return e=a(o.concat(l(t)),512+8*t.length),s(a(i.concat(e),640))}function e(e,t,n){return t?n?i(t,e):r(i(t,e)):n?o(e):r(o(e))}void 0!==(m=function(){return e}.call(n,v,n,t))&&(t.exports=m)}()},function(e,t,n){"use strict";function r(e,t){return u(e),f(e,p(arguments,1))}var o=n(2),i=n(4),a=n(1),u=n(5),s=n(14),l=n(15),c=l(),n=n(44),p=a("Array.prototype.slice"),f=i.apply(c);o(r,{getPolyfill:l,implementation:s,shim:n}),e.exports=r},function(e,t,n){"use strict";var r=n(2),o=n(15);e.exports=function(){var e=o();return r(Array.prototype,{forEach:e},{forEach:function(){return Array.prototype.forEach!==e}}),e}},function(e,t,n){"use strict";t.__esModule=!0;var n=n(47),r=n&&n.__esModule?n:{default:n},o=(t.default=function(f){return f=(0,r.default)({url:"",method:"get",body:{}},f),new Promise(function(t,e){var n,r,o,i;if("jsonp"==f.method)return n="cb_"+(Date.now()+Math.round(1e3*Math.random())).toString(32),r=document,o=r.body,(i=r.createElement("script")).async=!0,i.defer=!0,-1<f.url.indexOf("?")?f.url+="&"+d({callback:n,t:Date.now()}):f.url+="?"+d({callback:n,t:Date.now()}),i.src=f.url,window[n]=function(e){window[n]=null,o.removeChild(i),t(e)},void o.appendChild(i);function a(){return{ok:2==(s.status/100|0),statusText:s.statusText,status:s.status,url:s.responseURL,text:function(){return Promise.resolve(s.responseText)},json:function(){return Promise.resolve(s.responseText).then(JSON.parse)},blob:function(){return Promise.resolve(new Blob([s.response]))},clone:a,headers:{keys:function(){return l},entries:function(){return c},get:function(e){return p[e.toLowerCase()]},has:function(e){return e.toLowerCase()in p}}}}var u,s="XMLHttpRequest"in window?new XMLHttpRequest:new ActiveXObject("Microsoft.XMLHTTP"),l=[],c=[],p={};for(u in d(f.body)&&(f.url=f.url+"?"+("get"==f.method?d(f.body):"")),s.open(f.method||"get",f.url),"blob"==f.dataType&&(s.responseType="blob"),s.onload=function(){s.getAllResponseHeaders().replace(/^(.*?):[^\S\n]*([\s\S]*?)$/gm,function(e,t,n){l.push(t=t.toLowerCase()),c.push([t,n]),p[t]=p[t]?p[t]+","+n:n}),t(a())},s.onerror=e,s.withCredentials="include"==f.credentials,f.headers)s.setRequestHeader(u,f.headers[u]);s.send("post"==f.method?f.body:"get"==f.method?"":d(f.body))})},encodeURIComponent),d=function(e){var t,n=[];for(t in e)e.hasOwnProperty(t)&&n.push(o(t)+"="+o(e[t]));return n.join("&").replace(/%20/g,"+")||""}},function(e,t,n){"use strict";t.__esModule=!0;t.default=function(e){var t,n={},r={Trident:-1<(e=e||navigator.userAgent).indexOf("Trident")||-1<e.indexOf("NET CLR"),Presto:-1<e.indexOf("Presto"),WebKit:-1<e.indexOf("AppleWebKit"),Gecko:-1<e.indexOf("Gecko/"),Safari:-1<e.indexOf("Safari"),Edge:-1<e.indexOf("Edge")||-1<e.indexOf("Edg"),Chrome:-1<e.indexOf("Chrome")||-1<e.indexOf("CriOS"),IE:-1<e.indexOf("MSIE")||-1<e.indexOf("Trident"),Firefox:-1<e.indexOf("Firefox")||-1<e.indexOf("FxiOS"),"Firefox Focus":-1<e.indexOf("Focus"),Chromium:-1<e.indexOf("Chromium"),Opera:-1<e.indexOf("Opera")||-1<e.indexOf("OPR"),Vivaldi:-1<e.indexOf("Vivaldi"),Yandex:-1<e.indexOf("YaBrowser"),Kindle:-1<e.indexOf("Kindle")||-1<e.indexOf("Silk/"),360:-1<e.indexOf("360EE")||-1<e.indexOf("360SE"),UC:-1<e.indexOf("UC")||-1<e.indexOf(" UBrowser"),QQBrowser:-1<e.indexOf("QQBrowser"),QQ:-1<e.indexOf("QQ/"),Baidu:-1<e.indexOf("Baidu")||-1<e.indexOf("BIDUBrowser"),Maxthon:-1<e.indexOf("Maxthon"),Sogou:-1<e.indexOf("MetaSr")||-1<e.indexOf("Sogou"),LBBROWSER:-1<e.indexOf("LBBROWSER"),"2345Explorer":-1<e.indexOf("2345Explorer"),TheWorld:-1<e.indexOf("TheWorld"),XiaoMi:-1<e.indexOf("MiuiBrowser"),Quark:-1<e.indexOf("Quark"),Qiyu:-1<e.indexOf("Qiyu"),Wechat:-1<e.indexOf("MicroMessenger"),Taobao:-1<e.indexOf("AliApp(TB"),Alipay:-1<e.indexOf("AliApp(AP"),Weibo:-1<e.indexOf("Weibo"),Douban:-1<e.indexOf("com.douban.frodo"),Suning:-1<e.indexOf("SNEBUY-APP"),iQiYi:-1<e.indexOf("IqiyiApp"),Windows:-1<e.indexOf("Windows"),Linux:-1<e.indexOf("Linux")||-1<e.indexOf("X11"),macOS:-1<e.indexOf("Macintosh"),Android:-1<e.indexOf("Android")||-1<e.indexOf("Adr"),Ubuntu:-1<e.indexOf("Ubuntu"),FreeBSD:-1<e.indexOf("FreeBSD"),Debian:-1<e.indexOf("Debian"),"Windows Phone":-1<e.indexOf("IEMobile")||-1<e.indexOf("Windows Phone"),BlackBerry:-1<e.indexOf("BlackBerry")||-1<e.indexOf("RIM")||-1<e.indexOf("BB10"),MeeGo:-1<e.indexOf("MeeGo"),Symbian:-1<e.indexOf("Symbian"),iOS:-1<e.indexOf("like Mac OS X"),"Chrome OS":-1<e.indexOf("CrOS"),WebOS:-1<e.indexOf("hpwOS"),Mobile:-1<e.indexOf("Mobi")||-1<e.indexOf("iPh")||-1<e.indexOf("480"),Tablet:-1<e.indexOf("Tablet")||-1<e.indexOf("Pad")||-1<e.indexOf("Nexus 7")},o=(r.Mobile&&(r.Mobile=!(-1<e.indexOf("iPad"))),{browser:["Safari","Chrome","Edge","IE","Firefox","Firefox Focus","Chromium","Opera","Vivaldi","Yandex","Kindle","360","UC","QQBrowser","QQ","Baidu","Maxthon","Sogou","LBBROWSER","2345Explorer","TheWorld","XiaoMi","Quark","Qiyu","Wechat","Taobao","Alipay","Weibo","Douban","Suning","iQiYi"],os:["Windows","Linux","Mac OS","macOS","Android","Ubuntu","FreeBSD","Debian","iOS","Windows Phone","BlackBerry","MeeGo","Symbian","Chrome OS","WebOS"]});for(t in o)if(o.hasOwnProperty(t))for(var i=0,a=o[t].length;i<a;i++){var u=o[t][i];r[u]&&(n[t]=u)}var s={Windows:function(){return{"10.0":"11",6.4:"10",6.3:"8.1",6.2:"8",6.1:"7","6.0":"Vista",5.2:"XP",5.1:"XP","5.0":"2000"}[e.replace(/^.*Windows NT ([\d.]+).*$/,"$1")]},Android:e.replace(/^.*Android ([\d.]+);.*$/,"$1"),iOS:e.replace(/^.*OS ([\d_]+) like.*$/,"$1").replace(/_/g,"."),Debian:e.replace(/^.*Debian\/([\d.]+).*$/,"$1"),"Windows Phone":e.replace(/^.*Windows Phone( OS)? ([\d.]+);.*$/,"$2"),macOS:e.replace(/^.*Mac OS X ([\d_]+).*$/,"$1").replace(/_/g,"."),WebOS:e.replace(/^.*hpwOS\/([\d.]+);.*$/,"$1"),BlackBerry:e.replace(/^.*BB([\d.]+);*$/,"$1")},s=(n.osVersion="",s[n.os]),s=(s&&(n.osVersion="function"==typeof s?s():s==e?"":s),{Safari:e.replace(/^.*Version\/([\d.]+).*$/,"$1"),Chrome:e.replace(/^.*Chrome\/([\d.]+).*$/,"$1").replace(/^.*CriOS\/([\d.]+).*$/,"$1"),IE:e.replace(/^.*MSIE ([\d.]+).*$/,"$1").replace(/^.*rv:([\d.]+).*$/,"$1"),Edge:e.replace(/^.*Edge?\/([\d.]+).*$/,"$1"),Firefox:e.replace(/^.*Firefox\/([\d.]+).*$/,"$1").replace(/^.*FxiOS\/([\d.]+).*$/,"$1"),"Firefox Focus":e.replace(/^.*Focus\/([\d.]+).*$/,"$1"),Chromium:e.replace(/^.*Chromium\/([\d.]+).*$/,"$1"),Opera:e.replace(/^.*Opera\/([\d.]+).*$/,"$1").replace(/^.*OPR\/([\d.]+).*$/,"$1"),Vivaldi:e.replace(/^.*Vivaldi\/([\d.]+).*$/,"$1"),Yandex:e.replace(/^.*YaBrowser\/([\d.]+).*$/,"$1"),Kindle:e.replace(/^.*Version\/([\d.]+).*$/,"$1"),Maxthon:e.replace(/^.*Maxthon\/([\d.]+).*$/,"$1"),QQBrowser:e.replace(/^.*QQBrowser\/([\d.]+).*$/,"$1"),QQ:e.replace(/^.*QQ\/([\d.]+).*$/,"$1"),Baidu:e.replace(/^.*BIDUBrowser[\s\/]([\d.]+).*$/,"$1"),UC:e.replace(/^.*UC?Browser\/([\d.]+).*$/,"$1"),Sogou:e.replace(/^.*SE ([\d.X]+).*$/,"$1").replace(/^.*SogouMobileBrowser\/([\d.]+).*$/,"$1"),"2345Explorer":e.replace(/^.*2345Explorer\/([\d.]+).*$/,"$1"),TheWorld:e.replace(/^.*TheWorld ([\d.]+).*$/,"$1"),XiaoMi:e.replace(/^.*MiuiBrowser\/([\d.]+).*$/,"$1"),Quark:e.replace(/^.*Quark\/([\d.]+).*$/,"$1"),Qiyu:e.replace(/^.*Qiyu\/([\d.]+).*$/,"$1"),Wechat:e.replace(/^.*MicroMessenger\/([\d.]+).*$/,"$1"),Taobao:e.replace(/^.*AliApp\(TB\/([\d.]+).*$/,"$1"),Alipay:e.replace(/^.*AliApp\(AP\/([\d.]+).*$/,"$1"),Weibo:e.replace(/^.*weibo__([\d.]+).*$/,"$1"),Douban:e.replace(/^.*com.douban.frodo\/([\d.]+).*$/,"$1"),Suning:e.replace(/^.*SNEBUY-APP([\d.]+).*$/,"$1"),iQiYi:e.replace(/^.*IqiyiVersion\/([\d.]+).*$/,"$1")}),s=(n.version="",s[n.browser]);return s&&(n.version="function"==typeof s?s():s==e?"":s),null==n.browser&&(n.browser="Unknow App"),n}},function(e,t,n){"use strict";t.__esModule=!0,t.default=function(e){e=Object(e);for(var t=1,n=arguments.length;t<n;t++){var r=arguments[t];if(r)for(var o in r)Object.prototype.hasOwnProperty.call(r,o)&&(e[o]=r[o])}return e}},function(e,t,n){"use strict";function a(e){return/^\{[\s\S]*\}$/.test(JSON.stringify(e))}function u(e){return"[object Function]"==={}.toString.call(e)}function s(t){if("string"==typeof t)try{return JSON.parse(t)}catch(e){return t}}function l(){if(!(this instanceof l))return new l}function c(e,t){var n=arguments,r=null;if(f=f||l(),0===n.length)return f.get();if(1===n.length){if("string"==typeof e)return f.get(e);if(a(e))return f.set(e)}if(2===n.length&&"string"==typeof e){if(!t)return f.remove(e);if(t&&"string"==typeof t)return f.set(e,t);t&&u(t)&&(r=null,r=t(e,f.get(e)),c.set(e,r))}if(2===n.length&&(n=e,"[object Array]"==={}.toString.call(n))&&u(t))for(var o=0,i=e.length;o<i;o++)r=t(e[o],f.get(e[o])),c.set(e[o],r);return c}t.__esModule=!0;var r,p=function(e){var t,n="_Is_Incognit";try{e.setItem(n,"yes")}catch(n){-1<["QuotaExceededError","NS_ERROR_DOM_QUOTA_REACHED"].indexOf(n.name)&&(t=function(){},e.__proto__={setItem:t,getItem:t,removeItem:t,clear:t})}finally{"yes"===e.getItem(n)&&e.removeItem(n)}return e}(p=window.localStorage),f=null;for(r in l.prototype={set:function(e,t){if(e&&!a(e))p.setItem(e,void 0===(t=t)||"function"==typeof t?t+"":JSON.stringify(t));else if(a(e))for(var n in e)this.set(n,e[n]);return this},get:function(e){var n;if(!e)return n={},this.each(function(e,t){return n[e]=t}),n;if("?"===e.charAt(0))return this.has(e.substr(1));var t=arguments;if(1<t.length){for(var r={},o=0,i=t.length;o<i;o++){var a=s(p.getItem(t[o]));a&&(r[t[o]]=a)}return r}return s(p.getItem(e))},clear:function(){return p.clear(),this},remove:function(e){var t=this.get(e);return p.removeItem(e),t},has:function(e){return{}.hasOwnProperty.call(this.get(),e)},keys:function(){var t=[];return this.each(function(e){t.push(e)}),t},each:function(e){for(var t=0,n=p.length;t<n;t++){var r=p.key(t);e(r,this.get(r))}return this},search:function(e){for(var t=this.keys(),n={},r=0,o=t.length;r<o;r++)-1<t[r].indexOf(e)&&(n[t[r]]=this.get(t[r]));return n}})c[r]=l.prototype[r];t.default=c},function(e,t,n){var r,o,i,a;function u(e,t,n){return n=Object.create(u.fn),e&&n.push.apply(n,e[i]?[e]:""+e===e?/</.test(e)?((t=o.createElement(t)).innerHTML=e,t.children):t?(t=u(t)[0])?t[a](e):n:o[a](e):e),n}o=document,i="addEventListener",a="querySelectorAll",u.fn=[],u.one=function(e,t){return u(e,t)[0]||null},r=u,void 0!==(t=function(){return r}.apply(t,[]))&&(e.exports=t)},function(e,t,n){function f(e){return null==e}function r(e){(e=function(e){var t,n={};for(t in e)n[t]=e[t];return n}(e||{})).whiteList=e.whiteList||o.whiteList,e.onAttr=e.onAttr||o.onAttr,e.onIgnoreAttr=e.onIgnoreAttr||o.onIgnoreAttr,e.safeAttrValue=e.safeAttrValue||o.safeAttrValue,this.options=e}var o=n(16),i=n(51);n(17),r.prototype.process=function(e){if(!(e=(e=e||"").toString()))return"";var t=this.options,s=t.whiteList,l=t.onAttr,c=t.onIgnoreAttr,p=t.safeAttrValue;return i(e,function(e,t,n,r,o){var i,a=s[n],u=!1;if(!0===a?u=a:"function"==typeof a?u=a(r):a instanceof RegExp&&(u=a.test(r)),!0!==u&&(u=!1),r=p(n,r))return a={position:t,sourcePosition:e,source:o,isWhite:u},u?f(i=l(n,r,a))?n+":"+r:i:f(i=c(n,r,a))?void 0:i})},e.exports=r},function(e,t,n){var c=n(17);e.exports=function(r,o){function e(){var e,t,n;i||-1!==(t=(e=c.trim(r.slice(a,u))).indexOf(":"))&&(n=c.trim(e.slice(0,t)),t=c.trim(e.slice(t+1)),n&&(n=o(a,s.length,n,t,e))&&(s+=n+"; ")),a=u+1}";"!==(r=c.trimRight(r))[r.length-1]&&(r+=";");for(var t=r.length,i=!1,a=0,u=0,s="";u<t;u++){var n=r[u];if("/"===n&&"*"===r[u+1]){var l=r.indexOf("*/",u+2);if(-1===l)break;a=(u=l+1)+1,i=!1}else"("===n?i=!0:")"===n?i=!1:";"===n?i||e():"\n"===n&&e()}return c.trim(s)}},function(e,t,n){"use strict";var r=n(0),o=n(1),i=r("%TypeError%"),a=n(54),u=r("%Reflect.apply%",!0)||o("%Function.prototype.apply%");e.exports=function(e,t){var n=2<arguments.length?arguments[2]:[];if(a(n))return u(e,t,n);throw new i("Assertion failed: optional `argumentsList`, if provided, must be a List")}},function(e,t,n){"use strict";var r=n(0)("%TypeError%"),o=n(19),i=n(8);e.exports=function(e,t){if("Object"!==i(e))throw new r("Assertion failed: `O` must be an Object");if(o(t))return t in e;throw new r("Assertion failed: `P` must be a Property Key")}},function(e,t,n){"use strict";var r=n(0)("%Array%"),o=!r.isArray&&n(1)("Object.prototype.toString");e.exports=r.isArray||function(e){return"[object Array]"===o(e)}},function(e,t,n){"use strict";e.exports=n(10)},function(e,t,n){"use strict";var r=n(0)("%TypeError%"),o=n(18),i=n(58),a=n(8);e.exports=function(e){if("Object"!==a(e))throw new r("Assertion failed: `obj` must be an Object");return i(o(e,"length"))}},function(e,t,n){"use strict";var r=n(63),o=n(59);e.exports=function(e){e=o(e);return 0===(e=0!==e?r(e):e)?0:e}},function(e,t,n){"use strict";var r=n(72),o=n(57);e.exports=function(e){e=o(e);return e<=0?0:r<e?r:e}},function(e,t,n){"use strict";var r=n(0),o=r("%TypeError%"),i=r("%Number%"),a=r("%RegExp%"),u=r("%parseInt%"),r=n(1),s=n(73),l=n(71),c=r("String.prototype.slice"),p=s(/^0b[01]+$/i),f=s(/^0o[0-7]+$/i),d=s(/^[-+]0x[0-9a-f]+$/i),h=s(new a("["+["\x85","\u200b","\ufffe"].join("")+"]","g")),s=["\t\n\v\f\r \xa0\u1680\u180e\u2000\u2001\u2002\u2003","\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028","\u2029\ufeff"].join(""),g=new RegExp("(^["+s+"]+)|(["+s+"]+$)","g"),v=r("String.prototype.replace"),m=n(61);e.exports=function e(t){t=l(t)?t:m(t,i);if("symbol"==typeof t)throw new o("Cannot convert a Symbol value to a number");if("bigint"==typeof t)throw new o("Conversion from 'BigInt' to 'number' is not allowed.");if("string"==typeof t){if(p(t))return e(u(c(t,2),2));if(f(t))return e(u(c(t,2),8));if(h(t)||d(t))return NaN;var n=v(t,g,"");if(n!==t)return e(n)}return i(t)}},function(e,t,n){"use strict";var r=n(0)("%Object%"),o=n(5);e.exports=function(e){return o(e),r(e)}},function(e,t,n){"use strict";var r=n(76);e.exports=function(e){return 1<arguments.length?r(e,arguments[1]):r(e)}},function(e,t,n){"use strict";var r=n(0)("%TypeError%");e.exports=function(e,t){if(null==e)throw new r(t||"Cannot call method on "+e);return e}},function(e,t,n){"use strict";var r=n(67),o=n(68),i=n(64),a=n(70),u=n(69),s=n(74);e.exports=function(e){e=i(e);return a(e)?0:0!==e&&u(e)?s(e)*o(r(e)):e}},function(e,t,n){"use strict";var r=n(65);e.exports=function(e){e=r(e,Number);if("string"!=typeof e)return+e;e=e.replace(/^[ \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u0085]+|[ \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u0085]+$/g,"");return/^0[ob]|^[+-]0x/.test(e)?NaN:+e}},function(e,t,n){"use strict";e.exports=n(77)},function(e,t,n){"use strict";e.exports=function(e){return null===e?"Null":void 0===e?"Undefined":"function"==typeof e||"object"==typeof e?"Object":"number"==typeof e?"Number":"boolean"==typeof e?"Boolean":"string"==typeof e?"String":void 0}},function(e,t,n){"use strict";var r=n(0)("%Math.abs%");e.exports=function(e){return r(e)}},function(e,t,n){"use strict";var r=Math.floor;e.exports=function(e){return r(e)}},function(e,t,n){"use strict";var r=Number.isNaN||function(e){return e!=e};e.exports=Number.isFinite||function(e){return"number"==typeof e&&!r(e)&&e!==1/0&&e!==-1/0}},function(e,t,n){"use strict";e.exports=Number.isNaN||function(e){return e!=e}},function(e,t,n){"use strict";e.exports=function(e){return null===e||"function"!=typeof e&&"object"!=typeof e}},function(e,t,n){"use strict";var n=n(0),r=n("%Math%"),n=n("%Number%");e.exports=n.MAX_SAFE_INTEGER||r.pow(2,53)-1},function(e,t,n){"use strict";var r=n(0)("RegExp.prototype.test"),o=n(4);e.exports=function(e){return o(r,e)}},function(e,t,n){"use strict";e.exports=function(e){return 0<=e?1:-1}},function(e,t){e.exports=function(e){var r=!0,t=!0,n=!1;if("function"!=typeof e)return!1;try{e.call("f",function(e,t,n){"object"!=typeof n&&(r=!1)}),e.call([null],function(){"use strict";t="string"==typeof this},"x")}catch(e){n=!0}return!n&&r&&t}},function(e,t,n){"use strict";var l="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator,c=n(21),p=n(10),f=n(80),d=n(82);e.exports=function(e){if(c(e))return e;var t,n="default";if(1<arguments.length&&(arguments[1]===String?n="string":arguments[1]===Number&&(n="number")),l&&(Symbol.toPrimitive?t=function(e,t){var n=e[t];if(null!=n){if(p(n))return n;throw new TypeError(n+" returned for property "+t+" of object "+e+" is not a function")}}(e,Symbol.toPrimitive):d(e)&&(t=Symbol.prototype.valueOf)),void 0===t){"default"===n&&(f(e)||d(e))&&(n="string");var r=e,o="default"===n?"number":n;if(null==r)throw new TypeError("Cannot call method on "+r);if("string"!=typeof o||"number"!==o&&"string"!==o)throw new TypeError('hint must be "string" or "number"');for(var i,a,u="string"===o?["toString","valueOf"]:["valueOf","toString"],s=0;s<u.length;++s)if(i=r[u[s]],p(i)&&(a=i.call(r),c(a)))return a;throw new TypeError("No default value")}o=t.call(e,n);if(c(o))return o;throw new TypeError("unable to convert exotic object to primitive")}},function(e,t,n){"use strict";var i=Object.prototype.toString,a=n(21),u=n(10),r=function(e){var t;if((t=1<arguments.length?arguments[1]:"[object Date]"===i.call(e)?String:Number)!==String&&t!==Number)throw new TypeError("invalid [[DefaultValue]] hint supplied");for(var n,r=t===String?["toString","valueOf"]:["valueOf","toString"],o=0;o<r.length;++o)if(u(e[r[o]])&&(n=e[r[o]](),a(n)))return n;throw new TypeError("No default value")};e.exports=function(e){return a(e)?e:1<arguments.length?r(e,arguments[1]):r(e)}},function(e,t,n){"use strict";var s=Array.prototype.slice,l=Object.prototype.toString;e.exports=function(t){var n=this;if("function"!=typeof n||"[object Function]"!==l.call(n))throw new TypeError("Function.prototype.bind called on incompatible "+n);for(var r=s.call(arguments,1),e=Math.max(0,n.length-r.length),o=[],i=0;i<e;i++)o.push("$"+i);var a,u=Function("binder","return function ("+o.join(",")+"){ return binder.apply(this,arguments); }")(function(){var e;return this instanceof u?(e=n.apply(this,r.concat(s.call(arguments))),Object(e)===e?e:this):n.apply(t,r.concat(s.call(arguments)))});return n.prototype&&((a=function(){}).prototype=n.prototype,u.prototype=new a,a.prototype=null),u}},function(e,t,n){e.exports=function(){"use strict";function s(e){return'<span style="color: slategray">'+e+"</span>"}var l=function(e,t){return t={exports:{}},e(t,t.exports),t.exports}(function(e){var t=e.exports=function(){return new RegExp("(?:"+t.line().source+")|(?:"+t.block().source+")","gm")};t.line=function(){return/(?:^|\s)\/\/(.+?)$/gm},t.block=function(){return/\/\*([\S\s]*?)\*\//gm}}),c=["23AC69","91C132","F19726","E8552D","1AAB8E","E1147F","2980C1","1BA1E6","9FA0A0","F19726","E30B20","E30B20","A3338B"];return function(e,t){void 0===t&&(t={});var i=t.colors;void 0===i&&(i=c);var a=0,u={},n=/[\u4E00-\u9FFF\u3400-\u4dbf\uf900-\ufaff\u3040-\u309f\uac00-\ud7af\u0400-\u04FF]+|\w+/,r=/</,o=new RegExp("("+n.source+"|"+r.source+")|("+l().source+")","gmi");return e.replace(o,function(e,t,n){if(n)return s(n);if("<"===t)return"&lt;";var r;u[t]?r=u[t]:(r=i[a],u[t]=r);var o='<span style="color: #'+r+'">'+t+"</span>";return a=++a%i.length,o})}}()},function(e,t,n){"use strict";var r=Date.prototype.getDay,o=Object.prototype.toString,i=n(24)();e.exports=function(e){return"object"==typeof e&&null!==e&&(i?function(e){try{return r.call(e),!0}catch(e){return!1}}(e):"[object Date]"===o.call(e))}},function(e,t,n){"use strict";var r=String.prototype.valueOf,o=Object.prototype.toString,i=n(24)();e.exports=function(e){return"string"==typeof e||"object"==typeof e&&(i?function(e){try{return r.call(e),!0}catch(e){return!1}}(e):"[object String]"===o.call(e))}},function(e,t,n){"use strict";var r,o,i=Object.prototype.toString;n(22)()?(r=Symbol.prototype.toString,o=/^Symbol\(.*\)$/,e.exports=function(e){if("symbol"==typeof e)return!0;if("[object Symbol]"!==i.call(e))return!1;try{return"symbol"==typeof(t=e).valueOf()&&o.test(r.call(t))}catch(e){return!1}var t}):e.exports=function(e){return!1}},function(e,t,n){!function(r){"use strict";function o(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function t(e,t,n){return t&&o(e.prototype,t),n&&o(e,n),Object.defineProperty(e,"prototype",{writable:!1}),e}function i(e,t){if(e){if("string"==typeof e)return a(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);return"Object"===n&&e.constructor&&(n=e.constructor.name),"Map"===n||"Set"===n?Array.from(e):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?a(e,t):void 0}}function a(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,r=new Array(t);n<t;n++)r[n]=e[n];return r}function x(e,t){var n="undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(n)return(n=n.call(e)).next.bind(n);if(Array.isArray(e)||(n=i(e))||t&&e&&"number"==typeof e.length){n&&(e=n);var r=0;return function(){return r>=e.length?{done:!0}:{done:!1,value:e[r++]}}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function e(){return{baseUrl:null,breaks:!1,extensions:null,gfm:!0,headerIds:!0,headerPrefix:"",highlight:null,langPrefix:"language-",mangle:!0,pedantic:!1,renderer:null,sanitize:!1,sanitizer:null,silent:!1,smartLists:!1,smartypants:!1,tokenizer:null,walkTokens:null,xhtml:!1}}function n(e){r.defaults=e}function s(e,t){if(t){if(A.test(e))return e.replace(I,E)}else if(R.test(e))return e.replace(P,E);return e}function k(e){return e.replace(L,function(e,t){return t=t.toLowerCase(),"colon"===t?":":"#"===t.charAt(0)?"x"===t.charAt(1)?String.fromCharCode(parseInt(t.substring(2),16)):String.fromCharCode(+t.substring(1)):""})}function u(n,e){n=n.source||n,e=e||"";var r={replace:function(e,t){return t=t.source||t,t=t.replace(N,"$1"),n=n.replace(e,t),r},getRegex:function(){return new RegExp(n,e)}};return r}function l(e,t,n){if(e){var r;try{r=decodeURIComponent(k(n)).replace(U,"").toLowerCase()}catch(e){return null}if(0===r.indexOf("javascript:")||0===r.indexOf("vbscript:")||0===r.indexOf("data:"))return null}t&&!Q.test(n)&&(n=c(t,n));try{n=encodeURI(n).replace(/%25/g,"%")}catch(e){return null}return n}function c(e,t){F[" "+e]||(q.test(e)?F[" "+e]=e+"/":F[" "+e]=d(e,"/",!0)),e=F[" "+e];var n=-1===e.indexOf(":");return"//"===t.substring(0,2)?n?t:e.replace(W,"$1")+t:"/"===t.charAt(0)?n?t:e.replace(V,"$1")+t:e+t}function p(e){for(var t,n,r=1;r<arguments.length;r++){t=arguments[r];for(n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])}return e}function f(e,t){var n=e.replace(/\|/g,function(e,t,n){for(var r=!1,o=t;--o>=0&&"\\"===n[o];)r=!r;return r?"|":" |"}),r=n.split(/ \|/),o=0;if(r[0].trim()||r.shift(),r.length>0&&!r[r.length-1].trim()&&r.pop(),r.length>t)r.splice(t);else for(;r.length<t;)r.push("");for(;o<r.length;o++)r[o]=r[o].trim().replace(/\\\|/g,"|");return r}function d(e,t,n){var r=e.length;if(0===r)return"";for(var o=0;o<r;){var i=e.charAt(r-o-1);if(i!==t||n){if(i===t||!n)break;o++}else o++}return e.substr(0,r-o)}function h(e,t){if(-1===e.indexOf(t[1]))return-1;for(var n=e.length,r=0,o=0;o<n;o++)if("\\"===e[o])o++;else if(e[o]===t[0])r++;else if(e[o]===t[1]&&--r<0)return o;return-1}function g(e){e&&e.sanitize&&e.silent}function v(e,t){if(t<1)return"";for(var n="";t>1;)1&t&&(n+=e),t>>=1,e+=e;return n+e}function m(e,t,n,r){var o=t.href,i=t.title?s(t.title):null,a=e[1].replace(/\\([\[\]])/g,"$1");if("!"!==e[0].charAt(0)){r.state.inLink=!0;var u={type:"link",raw:n,href:o,title:i,text:a,tokens:r.inlineTokens(a,[])};return r.state.inLink=!1,u}return{type:"image",raw:n,href:o,title:i,text:s(a)}}function y(e,t){var n=e.match(/^(\s+)(?:```)/);if(null===n)return t;var r=n[1];return t.split("\n").map(function(e){var t=e.match(/^\s+/);return null===t?e:t[0].length>=r.length?e.slice(r.length):e}).join("\n")}function b(e){return e.replace(/---/g,"\u2014").replace(/--/g,"\u2013").replace(/(^|[-\u2014/(\[{"\s])'/g,"$1\u2018").replace(/'/g,"\u2019").replace(/(^|[-\u2014/(\[{\u2018\s])"/g,"$1\u201c").replace(/"/g,"\u201d").replace(/\.{3}/g,"\u2026")}function D(e){var t,n,r="",o=e.length;for(t=0;t<o;t++)n=e.charCodeAt(t),Math.random()>.5&&(n="x"+n.toString(16)),r+="&#"+n+";";return r}function w(e,n,r){if(void 0===e||null===e)throw new Error("marked(): input parameter is undefined or null");if("string"!=typeof e)throw new Error("marked(): input parameter is of type "+Object.prototype.toString.call(e)+", string expected");if("function"==typeof n&&(r=n,n=null),n=p({},w.defaults,n||{}),g(n),r){var o,i=n.highlight;try{o=B.lex(e,n)}catch(e){return r(e)}var a=function(t){var e;if(!t)try{n.walkTokens&&w.walkTokens(o,n.walkTokens),e=z.parse(o,n)}catch(e){t=e}return n.highlight=i,t?r(t):r(null,e)};if(!i||i.length<3)return a();if(delete n.highlight,!o.length)return a();var u=0;return w.walkTokens(o,function(n){"code"===n.type&&(u++,setTimeout(function(){i(n.text,n.lang,function(e,t){if(e)return a(e);null!=t&&t!==n.text&&(n.text=t,n.escaped=!0),0===--u&&a()})},0))}),void(0===u&&a())}try{var t=B.lex(e,n);return n.walkTokens&&w.walkTokens(t,n.walkTokens),z.parse(t,n)}catch(e){if(e.message+="\nPlease report this to https://github.com/markedjs/marked.",n.silent)return"<p>An error occurred:</p><pre>"+s(e.message+"",!0)+"</pre>";throw e}}r.defaults=e();var A=/[&<>"']/,I=/[&<>"']/g,R=/[<>"']|&(?!#?\w+;)/,P=/[<>"']|&(?!#?\w+;)/g,M={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"},E=function(e){return M[e]},L=/&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/gi,N=/(^|[^\[])\^/g,U=/[^\w:]/g,Q=/^$|^[a-z][a-z0-9+.-]*:|^[?#]/i,F={},q=/^[^:]+:\/*[^/]*$/,W=/^([^:]+:)[\s\S]*$/,V=/^([^:]+:\/*[^/]*)[\s\S]*$/,C={exec:function(){}},_=function(){function e(e){this.options=e||r.defaults}var t=e.prototype;return t.space=function(e){var t=this.rules.block.newline.exec(e);if(t&&t[0].length>0)return{type:"space",raw:t[0]}},t.code=function(e){var t=this.rules.block.code.exec(e);if(t){var n=t[0].replace(/^ {1,4}/gm,"");return{type:"code",raw:t[0],codeBlockStyle:"indented",text:this.options.pedantic?n:d(n,"\n")}}},t.fences=function(e){var t=this.rules.block.fences.exec(e);if(t){var n=t[0],r=y(n,t[3]||"");return{type:"code",raw:n,lang:t[2]?t[2].trim():t[2],text:r}}},t.heading=function(e){var t=this.rules.block.heading.exec(e);if(t){var n=t[2].trim();if(/#$/.test(n)){var r=d(n,"#");this.options.pedantic?n=r.trim():r&&!/ $/.test(r)||(n=r.trim())}var o={type:"heading",raw:t[0],depth:t[1].length,text:n,tokens:[]};return this.lexer.inline(o.text,o.tokens),o}},t.hr=function(e){var t=this.rules.block.hr.exec(e);if(t)return{type:"hr",raw:t[0]}},t.blockquote=function(e){var t=this.rules.block.blockquote.exec(e);if(t){var n=t[0].replace(/^ *> ?/gm,"");return{type:"blockquote",raw:t[0],tokens:this.lexer.blockTokens(n,[]),text:n}}},t.list=function(e){var t=this.rules.block.list.exec(e);if(t){var n,r,o,i,a,u,s,l,c,p,f,d,h=t[1].trim(),g=h.length>1,v={type:"list",raw:"",ordered:g,start:g?+h.slice(0,-1):"",loose:!1,items:[]};h=g?"\\d{1,9}\\"+h.slice(-1):"\\"+h,this.options.pedantic&&(h=g?h:"[*+-]");for(var m=new RegExp("^( {0,3}"+h+")((?: [^\\n]*)?(?:\\n|$))");e&&(d=!1,t=m.exec(e))&&!this.rules.block.hr.test(e);){if(n=t[0],e=e.substring(n.length),l=t[2].split("\n",1)[0],c=e.split("\n",1)[0],this.options.pedantic?(i=2,f=l.trimLeft()):(i=t[2].search(/[^ ]/),i=i>4?1:i,f=l.slice(i),i+=t[1].length),u=!1,!l&&/^ *$/.test(c)&&(n+=c+"\n",e=e.substring(c.length+1),d=!0),!d)for(var y=new RegExp("^ {0,"+Math.min(3,i-1)+"}(?:[*+-]|\\d{1,9}[.)])");e&&(p=e.split("\n",1)[0],l=p,this.options.pedantic&&(l=l.replace(/^ {1,4}(?=( {4})*[^ ])/g,"  ")),!y.test(l));){if(l.search(/[^ ]/)>=i||!l.trim())f+="\n"+l.slice(i);else{if(u)break;f+="\n"+l}u||l.trim()||(u=!0),n+=p+"\n",e=e.substring(p.length+1)}v.loose||(s?v.loose=!0:/\n *\n *$/.test(n)&&(s=!0)),this.options.gfm&&(r=/^\[[ xX]\] /.exec(f))&&(o="[ ] "!==r[0],f=f.replace(/^\[[ xX]\] +/,"")),v.items.push({type:"list_item",raw:n,task:!!r,checked:o,loose:!1,text:f}),v.raw+=n}v.items[v.items.length-1].raw=n.trimRight(),v.items[v.items.length-1].text=f.trimRight(),v.raw=v.raw.trimRight();var b=v.items.length;for(a=0;a<b;a++){this.lexer.state.top=!1,v.items[a].tokens=this.lexer.blockTokens(v.items[a].text,[]);var D=v.items[a].tokens.filter(function(e){return"space"===e.type}),w=D.every(function(e){for(var t,n=e.raw.split(""),r=0,o=x(n);!(t=o()).done;)if("\n"===t.value&&(r+=1),r>1)return!0;return!1});!v.loose&&D.length&&w&&(v.loose=!0,v.items[a].loose=!0)}return v}},t.html=function(e){var t=this.rules.block.html.exec(e);if(t){var n={type:"html",raw:t[0],pre:!this.options.sanitizer&&("pre"===t[1]||"script"===t[1]||"style"===t[1]),text:t[0]};return this.options.sanitize&&(n.type="paragraph",n.text=this.options.sanitizer?this.options.sanitizer(t[0]):s(t[0]),n.tokens=[],this.lexer.inline(n.text,n.tokens)),n}},t.def=function(e){var t=this.rules.block.def.exec(e);if(t){t[3]&&(t[3]=t[3].substring(1,t[3].length-1));return{type:"def",tag:t[1].toLowerCase().replace(/\s+/g," "),raw:t[0],href:t[2],title:t[3]}}},t.table=function(e){var t=this.rules.block.table.exec(e);if(t){var n={type:"table",header:f(t[1]).map(function(e){return{text:e}}),align:t[2].replace(/^ *|\| *$/g,"").split(/ *\| */),rows:t[3]&&t[3].trim()?t[3].replace(/\n[ \t]*$/,"").split("\n"):[]};if(n.header.length===n.align.length){n.raw=t[0];var r,o,i,a,u=n.align.length;for(r=0;r<u;r++)/^ *-+: *$/.test(n.align[r])?n.align[r]="right":/^ *:-+: *$/.test(n.align[r])?n.align[r]="center":/^ *:-+ *$/.test(n.align[r])?n.align[r]="left":n.align[r]=null;for(u=n.rows.length,r=0;r<u;r++)n.rows[r]=f(n.rows[r],n.header.length).map(function(e){return{text:e}});for(u=n.header.length,o=0;o<u;o++)n.header[o].tokens=[],this.lexer.inlineTokens(n.header[o].text,n.header[o].tokens);for(u=n.rows.length,o=0;o<u;o++)for(a=n.rows[o],i=0;i<a.length;i++)a[i].tokens=[],this.lexer.inlineTokens(a[i].text,a[i].tokens);return n}}},t.lheading=function(e){var t=this.rules.block.lheading.exec(e);if(t){var n={type:"heading",raw:t[0],depth:"="===t[2].charAt(0)?1:2,text:t[1],tokens:[]};return this.lexer.inline(n.text,n.tokens),n}},t.paragraph=function(e){var t=this.rules.block.paragraph.exec(e);if(t){var n={type:"paragraph",raw:t[0],text:"\n"===t[1].charAt(t[1].length-1)?t[1].slice(0,-1):t[1],tokens:[]};return this.lexer.inline(n.text,n.tokens),n}},t.text=function(e){var t=this.rules.block.text.exec(e);if(t){var n={type:"text",raw:t[0],text:t[0],tokens:[]};return this.lexer.inline(n.text,n.tokens),n}},t.escape=function(e){var t=this.rules.inline.escape.exec(e);if(t)return{type:"escape",raw:t[0],text:s(t[1])}},t.tag=function(e){var t=this.rules.inline.tag.exec(e);if(t)return!this.lexer.state.inLink&&/^<a /i.test(t[0])?this.lexer.state.inLink=!0:this.lexer.state.inLink&&/^<\/a>/i.test(t[0])&&(this.lexer.state.inLink=!1),!this.lexer.state.inRawBlock&&/^<(pre|code|kbd|script)(\s|>)/i.test(t[0])?this.lexer.state.inRawBlock=!0:this.lexer.state.inRawBlock&&/^<\/(pre|code|kbd|script)(\s|>)/i.test(t[0])&&(this.lexer.state.inRawBlock=!1),{type:this.options.sanitize?"text":"html",raw:t[0],inLink:this.lexer.state.inLink,inRawBlock:this.lexer.state.inRawBlock,text:this.options.sanitize?this.options.sanitizer?this.options.sanitizer(t[0]):s(t[0]):t[0]}},t.link=function(e){var t=this.rules.inline.link.exec(e);if(t){var n=t[2].trim();if(!this.options.pedantic&&/^</.test(n)){if(!/>$/.test(n))return;var r=d(n.slice(0,-1),"\\");if((n.length-r.length)%2==0)return}else{var o=h(t[2],"()");if(o>-1){var i=0===t[0].indexOf("!")?5:4,a=i+t[1].length+o;t[2]=t[2].substring(0,o),t[0]=t[0].substring(0,a).trim(),t[3]=""}}var u=t[2],s="";if(this.options.pedantic){var l=/^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(u);l&&(u=l[1],s=l[3])}else s=t[3]?t[3].slice(1,-1):"";return u=u.trim(),/^</.test(u)&&(u=this.options.pedantic&&!/>$/.test(n)?u.slice(1):u.slice(1,-1)),m(t,{href:u?u.replace(this.rules.inline._escapes,"$1"):u,title:s?s.replace(this.rules.inline._escapes,"$1"):s},t[0],this.lexer)}},t.reflink=function(e,t){var n;if((n=this.rules.inline.reflink.exec(e))||(n=this.rules.inline.nolink.exec(e))){var r=(n[2]||n[1]).replace(/\s+/g," ");if(!(r=t[r.toLowerCase()])||!r.href){var o=n[0].charAt(0);return{type:"text",raw:o,text:o}}return m(n,r,n[0],this.lexer)}},t.emStrong=function(e,t,n){void 0===n&&(n="");var r=this.rules.inline.emStrong.lDelim.exec(e);if(r&&(!r[3]||!n.match(/(?:[0-9A-Za-z\xAA\xB2\xB3\xB5\xB9\xBA\xBC-\xBE\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u0660-\u0669\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0966-\u096F\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09E6-\u09F1\u09F4-\u09F9\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A66-\u0A6F\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AE6-\u0AEF\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B66-\u0B6F\u0B71-\u0B77\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0BE6-\u0BF2\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C66-\u0C6F\u0C78-\u0C7E\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CE6-\u0CEF\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D58-\u0D61\u0D66-\u0D78\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DE6-\u0DEF\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F20-\u0F33\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F-\u1049\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u1090-\u1099\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1369-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A16\u1A20-\u1A54\u1A80-\u1A89\u1A90-\u1A99\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B50-\u1B59\u1B83-\u1BA0\u1BAE-\u1BE5\u1C00-\u1C23\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2070\u2071\u2074-\u2079\u207F-\u2089\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2150-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2CFD\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3192-\u3195\u31A0-\u31BF\u31F0-\u31FF\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA830-\uA835\uA840-\uA873\uA882-\uA8B3\uA8D0-\uA8D9\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA900-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF-\uA9D9\uA9E0-\uA9E4\uA9E6-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDE80-\uDE9C\uDEA0-\uDED0\uDEE1-\uDEFB\uDF00-\uDF23\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC58-\uDC76\uDC79-\uDC9E\uDCA7-\uDCAF\uDCE0-\uDCF2\uDCF4\uDCF5\uDCFB-\uDD1B\uDD20-\uDD39\uDD80-\uDDB7\uDDBC-\uDDCF\uDDD2-\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE40-\uDE48\uDE60-\uDE7E\uDE80-\uDE9F\uDEC0-\uDEC7\uDEC9-\uDEE4\uDEEB-\uDEEF\uDF00-\uDF35\uDF40-\uDF55\uDF58-\uDF72\uDF78-\uDF91\uDFA9-\uDFAF]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDCFA-\uDD23\uDD30-\uDD39\uDE60-\uDE7E\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF27\uDF30-\uDF45\uDF51-\uDF54\uDF70-\uDF81\uDFB0-\uDFCB\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC52-\uDC6F\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD03-\uDD26\uDD36-\uDD3F\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDD0-\uDDDA\uDDDC\uDDE1-\uDDF4\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDEF0-\uDEF9\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC50-\uDC59\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE50-\uDE59\uDE80-\uDEAA\uDEB8\uDEC0-\uDEC9\uDF00-\uDF1A\uDF30-\uDF3B\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCF2\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDD50-\uDD59\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC50-\uDC6C\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD50-\uDD59\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDDA0-\uDDA9\uDEE0-\uDEF2\uDFB0\uDFC0-\uDFD4]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDE70-\uDEBE\uDEC0-\uDEC9\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF50-\uDF59\uDF5B-\uDF61\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE96\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD834[\uDEE0-\uDEF3\uDF60-\uDF78]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD40-\uDD49\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB\uDEF0-\uDEF9]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDCC7-\uDCCF\uDD00-\uDD43\uDD4B\uDD50-\uDD59]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD83C[\uDD00-\uDD0C]|\uD83E[\uDFF0-\uDFF9]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])/))){var o=r[1]||r[2]||"";if(!o||o&&(""===n||this.rules.inline.punctuation.exec(n))){var i,a,u=r[0].length-1,s=u,l=0,c="*"===r[0][0]?this.rules.inline.emStrong.rDelimAst:this.rules.inline.emStrong.rDelimUnd;for(c.lastIndex=0,t=t.slice(-1*e.length+u);null!=(r=c.exec(t));)if(i=r[1]||r[2]||r[3]||r[4]||r[5]||r[6])if(a=i.length,r[3]||r[4])s+=a;else if(!((r[5]||r[6])&&u%3)||(u+a)%3){if(!((s-=a)>0)){if(a=Math.min(a,a+s+l),Math.min(u,a)%2){var p=e.slice(1,u+r.index+a);return{type:"em",raw:e.slice(0,u+r.index+a+1),text:p,tokens:this.lexer.inlineTokens(p,[])}}var f=e.slice(2,u+r.index+a-1);return{type:"strong",raw:e.slice(0,u+r.index+a+1),text:f,tokens:this.lexer.inlineTokens(f,[])}}}else l+=a}}},t.codespan=function(e){var t=this.rules.inline.code.exec(e);if(t){var n=t[2].replace(/\n/g," "),r=/[^ ]/.test(n),o=/^ /.test(n)&&/ $/.test(n);return r&&o&&(n=n.substring(1,n.length-1)),n=s(n,!0),{type:"codespan",raw:t[0],text:n}}},t.br=function(e){var t=this.rules.inline.br.exec(e);if(t)return{type:"br",raw:t[0]}},t.del=function(e){var t=this.rules.inline.del.exec(e);if(t)return{type:"del",raw:t[0],text:t[2],tokens:this.lexer.inlineTokens(t[2],[])}},t.autolink=function(e,t){var n=this.rules.inline.autolink.exec(e);if(n){var r,o;return"@"===n[2]?(r=s(this.options.mangle?t(n[1]):n[1]),o="mailto:"+r):(r=s(n[1]),o=r),{type:"link",raw:n[0],text:r,href:o,tokens:[{type:"text",raw:r,text:r}]}}},t.url=function(e,t){var n;if(n=this.rules.inline.url.exec(e)){var r,o;if("@"===n[2])r=s(this.options.mangle?t(n[0]):n[0]),o="mailto:"+r;else{var i;do{i=n[0],n[0]=this.rules.inline._backpedal.exec(n[0])[0]}while(i!==n[0]);r=s(n[0]),o="www."===n[1]?"http://"+r:r}return{type:"link",raw:n[0],text:r,href:o,tokens:[{type:"text",raw:r,text:r}]}}},t.inlineText=function(e,t){var n=this.rules.inline.text.exec(e);if(n){var r;return r=this.lexer.state.inRawBlock?this.options.sanitize?this.options.sanitizer?this.options.sanitizer(n[0]):s(n[0]):n[0]:s(this.options.smartypants?t(n[0]):n[0]),{type:"text",raw:n[0],text:r}}},e}(),S={newline:/^(?: *(?:\n|$))+/,code:/^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,fences:/^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?=\n|$)|$)/,hr:/^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/,heading:/^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,blockquote:/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,list:/^( {0,3}bull)( [^\n]+?)?(?:\n|$)/,html:"^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",def:/^ {0,3}\[(label)\]: *(?:\n *)?<?([^\s>]+)>?(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,table:C,lheading:/^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/,_paragraph:/^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,text:/^[^\n]+/,_label:/(?!\s*\])(?:\\.|[^\[\]\\])+/,_title:/(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/},O=(S.def=u(S.def).replace("label",S._label).replace("title",S._title).getRegex(),S.bullet=/(?:[*+-]|\d{1,9}[.)])/,S.listItemStart=u(/^( *)(bull) */).replace("bull",S.bullet).getRegex(),S.list=u(S.list).replace(/bull/g,S.bullet).replace("hr","\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def","\\n+(?="+S.def.source+")").getRegex(),S._tag="address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul",S._comment=/<!--(?!-?>)[\s\S]*?(?:-->|$)/,S.html=u(S.html,"i").replace("comment",S._comment).replace("tag",S._tag).replace("attribute",/ +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(),S.paragraph=u(S._paragraph).replace("hr",S.hr).replace("heading"," {0,3}#{1,6} ").replace("|lheading","").replace("|table","").replace("blockquote"," {0,3}>").replace("fences"," {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list"," {0,3}(?:[*+-]|1[.)]) ").replace("html","</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag",S._tag).getRegex(),S.blockquote=u(S.blockquote).replace("paragraph",S.paragraph).getRegex(),S.normal=p({},S),S.gfm=p({},S.normal,{table:"^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"}),S.gfm.table=u(S.gfm.table).replace("hr",S.hr).replace("heading"," {0,3}#{1,6} ").replace("blockquote"," {0,3}>").replace("code"," {4}[^\\n]").replace("fences"," {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list"," {0,3}(?:[*+-]|1[.)]) ").replace("html","</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag",S._tag).getRegex(),S.gfm.paragraph=u(S._paragraph).replace("hr",S.hr).replace("heading"," {0,3}#{1,6} ").replace("|lheading","").replace("table",S.gfm.table).replace("blockquote"," {0,3}>").replace("fences"," {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list"," {0,3}(?:[*+-]|1[.)]) ").replace("html","</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag",S._tag).getRegex(),S.pedantic=p({},S.normal,{html:u("^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:\"[^\"]*\"|'[^']*'|\\s[^'\"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))").replace("comment",S._comment).replace(/tag/g,"(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),def:/^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,heading:/^(#{1,6})(.*)(?:\n+|$)/,fences:C,paragraph:u(S.normal._paragraph).replace("hr",S.hr).replace("heading"," *#{1,6} *[^\n]").replace("lheading",S.lheading).replace("blockquote"," {0,3}>").replace("|fences","").replace("|list","").replace("|html","").getRegex()}),{escape:/^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,autolink:/^<(scheme:[^\s\x00-\x1f<>]*|email)>/,url:C,tag:"^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",link:/^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,reflink:/^!?\[(label)\]\[(ref)\]/,nolink:/^!?\[(ref)\](?:\[\])?/,reflinkSearch:"reflink|nolink(?!\\()",emStrong:{lDelim:/^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,rDelimAst:/^[^_*]*?\_\_[^_*]*?\*[^_*]*?(?=\_\_)|[punct_](\*+)(?=[\s]|$)|[^punct*_\s](\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|[^punct*_\s](\*+)(?=[^punct*_\s])/,rDelimUnd:/^[^_*]*?\*\*[^_*]*?\_[^_*]*?(?=\*\*)|[punct*](\_+)(?=[\s]|$)|[^punct*_\s](\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/},code:/^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,br:/^( {2,}|\\)\n(?!\s*$)/,del:C,text:/^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,punctuation:/^([\spunctuation])/,_punctuation:"!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~"}),B=(O.punctuation=u(O.punctuation).replace(/punctuation/g,O._punctuation).getRegex(),O.blockSkip=/\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g,O.escapedEmSt=/\\\*|\\_/g,O._comment=u(S._comment).replace("(?:--\x3e|$)","--\x3e").getRegex(),O.emStrong.lDelim=u(O.emStrong.lDelim).replace(/punct/g,O._punctuation).getRegex(),O.emStrong.rDelimAst=u(O.emStrong.rDelimAst,"g").replace(/punct/g,O._punctuation).getRegex(),O.emStrong.rDelimUnd=u(O.emStrong.rDelimUnd,"g").replace(/punct/g,O._punctuation).getRegex(),O._escapes=/\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g,O._scheme=/[a-zA-Z][a-zA-Z0-9+.-]{1,31}/,O._email=/[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/,O.autolink=u(O.autolink).replace("scheme",O._scheme).replace("email",O._email).getRegex(),O._attribute=/\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/,O.tag=u(O.tag).replace("comment",O._comment).replace("attribute",O._attribute).getRegex(),O._label=/(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/,O._href=/<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/,O._title=/"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/,O.link=u(O.link).replace("label",O._label).replace("href",O._href).replace("title",O._title).getRegex(),O.reflink=u(O.reflink).replace("label",O._label).replace("ref",S._label).getRegex(),O.nolink=u(O.nolink).replace("ref",S._label).getRegex(),O.reflinkSearch=u(O.reflinkSearch,"g").replace("reflink",O.reflink).replace("nolink",O.nolink).getRegex(),O.normal=p({},O),O.pedantic=p({},O.normal,{strong:{start:/^__|\*\*/,middle:/^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,endAst:/\*\*(?!\*)/g,endUnd:/__(?!_)/g},em:{start:/^_|\*/,middle:/^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,endAst:/\*(?!\*)/g,endUnd:/_(?!_)/g},link:u(/^!?\[(label)\]\((.*?)\)/).replace("label",O._label).getRegex(),reflink:u(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label",O._label).getRegex()}),O.gfm=p({},O.normal,{escape:u(O.escape).replace("])","~|])").getRegex(),_extended_email:/[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,url:/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,_backpedal:/(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,del:/^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,text:/^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/}),O.gfm.url=u(O.gfm.url,"i").replace("email",O.gfm._extended_email).getRegex(),O.breaks=p({},O.gfm,{br:u(O.br).replace("{2,}","*").getRegex(),text:u(O.gfm.text).replace("\\b_","\\b_| {2,}\\n").replace(/\{2,\}/g,"*").getRegex()}),function(){function n(e){this.tokens=[],this.tokens.links=Object.create(null),this.options=e||r.defaults,this.options.tokenizer=this.options.tokenizer||new _,this.tokenizer=this.options.tokenizer,this.tokenizer.options=this.options,this.tokenizer.lexer=this,this.inlineQueue=[],this.state={inLink:!1,inRawBlock:!1,top:!0};var t={block:S.normal,inline:O.normal};this.options.pedantic?(t.block=S.pedantic,t.inline=O.pedantic):this.options.gfm&&(t.block=S.gfm,this.options.breaks?t.inline=O.breaks:t.inline=O.gfm),this.tokenizer.rules=t}n.lex=function(e,t){return new n(t).lex(e)},n.lexInline=function(e,t){return new n(t).inlineTokens(e)};var e=n.prototype;return e.lex=function(e){e=e.replace(/\r\n|\r/g,"\n").replace(/\t/g,"    "),this.blockTokens(e,this.tokens);for(var t;t=this.inlineQueue.shift();)this.inlineTokens(t.src,t.tokens);return this.tokens},e.blockTokens=function(o,t){var i=this;void 0===t&&(t=[]),this.options.pedantic&&(o=o.replace(/^ +$/gm,""));for(var n,e,a,r;o;)if(!(this.options.extensions&&this.options.extensions.block&&this.options.extensions.block.some(function(e){return!!(n=e.call({lexer:i},o,t))&&(o=o.substring(n.raw.length),t.push(n),!0)})))if(n=this.tokenizer.space(o))o=o.substring(n.raw.length),1===n.raw.length&&t.length>0?t[t.length-1].raw+="\n":t.push(n);else if(n=this.tokenizer.code(o))o=o.substring(n.raw.length),e=t[t.length-1],!e||"paragraph"!==e.type&&"text"!==e.type?t.push(n):(e.raw+="\n"+n.raw,e.text+="\n"+n.text,this.inlineQueue[this.inlineQueue.length-1].src=e.text);else if(n=this.tokenizer.fences(o))o=o.substring(n.raw.length),t.push(n);else if(n=this.tokenizer.heading(o))o=o.substring(n.raw.length),t.push(n);else if(n=this.tokenizer.hr(o))o=o.substring(n.raw.length),t.push(n);else if(n=this.tokenizer.blockquote(o))o=o.substring(n.raw.length),t.push(n);else if(n=this.tokenizer.list(o))o=o.substring(n.raw.length),t.push(n);else if(n=this.tokenizer.html(o))o=o.substring(n.raw.length),t.push(n);else if(n=this.tokenizer.def(o))o=o.substring(n.raw.length),e=t[t.length-1],!e||"paragraph"!==e.type&&"text"!==e.type?this.tokens.links[n.tag]||(this.tokens.links[n.tag]={href:n.href,title:n.title}):(e.raw+="\n"+n.raw,e.text+="\n"+n.raw,this.inlineQueue[this.inlineQueue.length-1].src=e.text);else if(n=this.tokenizer.table(o))o=o.substring(n.raw.length),t.push(n);else if(n=this.tokenizer.lheading(o))o=o.substring(n.raw.length),t.push(n);else if(a=o,this.options.extensions&&this.options.extensions.startBlock&&function(){var t=1/0,n=o.slice(1),r=void 0;i.options.extensions.startBlock.forEach(function(e){"number"==typeof(r=e.call({lexer:this},n))&&r>=0&&(t=Math.min(t,r))}),t<1/0&&t>=0&&(a=o.substring(0,t+1))}(),this.state.top&&(n=this.tokenizer.paragraph(a)))e=t[t.length-1],r&&"paragraph"===e.type?(e.raw+="\n"+n.raw,e.text+="\n"+n.text,this.inlineQueue.pop(),this.inlineQueue[this.inlineQueue.length-1].src=e.text):t.push(n),r=a.length!==o.length,o=o.substring(n.raw.length);else if(n=this.tokenizer.text(o))o=o.substring(n.raw.length),e=t[t.length-1],e&&"text"===e.type?(e.raw+="\n"+n.raw,e.text+="\n"+n.text,this.inlineQueue.pop(),this.inlineQueue[this.inlineQueue.length-1].src=e.text):t.push(n);else if(o){var u="Infinite loop on byte: "+o.charCodeAt(0);if(this.options.silent)break;throw new Error(u)}return this.state.top=!0,t},e.inline=function(e,t){this.inlineQueue.push({src:e,tokens:t})},e.inlineTokens=function(o,t){var i=this;void 0===t&&(t=[]);var n,e,a,r,u,s,l=o;if(this.tokens.links){var c=Object.keys(this.tokens.links);if(c.length>0)for(;null!=(r=this.tokenizer.rules.inline.reflinkSearch.exec(l));)c.includes(r[0].slice(r[0].lastIndexOf("[")+1,-1))&&(l=l.slice(0,r.index)+"["+v("a",r[0].length-2)+"]"+l.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex))}for(;null!=(r=this.tokenizer.rules.inline.blockSkip.exec(l));)l=l.slice(0,r.index)+"["+v("a",r[0].length-2)+"]"+l.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);for(;null!=(r=this.tokenizer.rules.inline.escapedEmSt.exec(l));)l=l.slice(0,r.index)+"++"+l.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);for(;o;)if(u||(s=""),u=!1,!(this.options.extensions&&this.options.extensions.inline&&this.options.extensions.inline.some(function(e){return!!(n=e.call({lexer:i},o,t))&&(o=o.substring(n.raw.length),t.push(n),!0)})))if(n=this.tokenizer.escape(o))o=o.substring(n.raw.length),t.push(n);else if(n=this.tokenizer.tag(o))o=o.substring(n.raw.length),e=t[t.length-1],e&&"text"===n.type&&"text"===e.type?(e.raw+=n.raw,e.text+=n.text):t.push(n);else if(n=this.tokenizer.link(o))o=o.substring(n.raw.length),t.push(n);else if(n=this.tokenizer.reflink(o,this.tokens.links))o=o.substring(n.raw.length),e=t[t.length-1],e&&"text"===n.type&&"text"===e.type?(e.raw+=n.raw,e.text+=n.text):t.push(n);else if(n=this.tokenizer.emStrong(o,l,s))o=o.substring(n.raw.length),t.push(n);else if(n=this.tokenizer.codespan(o))o=o.substring(n.raw.length),t.push(n);else if(n=this.tokenizer.br(o))o=o.substring(n.raw.length),t.push(n);else if(n=this.tokenizer.del(o))o=o.substring(n.raw.length),t.push(n);else if(n=this.tokenizer.autolink(o,D))o=o.substring(n.raw.length),t.push(n);else if(this.state.inLink||!(n=this.tokenizer.url(o,D))){if(a=o,this.options.extensions&&this.options.extensions.startInline&&function(){var t=1/0,n=o.slice(1),r=void 0;i.options.extensions.startInline.forEach(function(e){"number"==typeof(r=e.call({lexer:this},n))&&r>=0&&(t=Math.min(t,r))}),t<1/0&&t>=0&&(a=o.substring(0,t+1))}(),n=this.tokenizer.inlineText(a,b))o=o.substring(n.raw.length),"_"!==n.raw.slice(-1)&&(s=n.raw.slice(-1)),u=!0,e=t[t.length-1],e&&"text"===e.type?(e.raw+=n.raw,e.text+=n.text):t.push(n);else if(o){var p="Infinite loop on byte: "+o.charCodeAt(0);if(this.options.silent)break;throw new Error(p)}}else o=o.substring(n.raw.length),t.push(n);return t},t(n,null,[{key:"rules",get:function(){return{block:S,inline:O}}}]),n}()),$=function(){function e(e){this.options=e||r.defaults}var t=e.prototype;return t.code=function(e,t,n){var r=(t||"").match(/\S*/)[0];if(this.options.highlight){var o=this.options.highlight(e,r);null!=o&&o!==e&&(n=!0,e=o)}return e=e.replace(/\n$/,"")+"\n",r?'<pre><code class="'+this.options.langPrefix+s(r,!0)+'">'+(n?e:s(e,!0))+"</code></pre>\n":"<pre><code>"+(n?e:s(e,!0))+"</code></pre>\n"},t.blockquote=function(e){return"<blockquote>\n"+e+"</blockquote>\n"},t.html=function(e){return e},t.heading=function(e,t,n,r){return this.options.headerIds?"<h"+t+' id="'+this.options.headerPrefix+r.slug(n)+'">'+e+"</h"+t+">\n":"<h"+t+">"+e+"</h"+t+">\n"},t.hr=function(){return this.options.xhtml?"<hr/>\n":"<hr>\n"},t.list=function(e,t,n){var r=t?"ol":"ul";return"<"+r+(t&&1!==n?' start="'+n+'"':"")+">\n"+e+"</"+r+">\n"},t.listitem=function(e){return"<li>"+e+"</li>\n"},t.checkbox=function(e){return"<input "+(e?'checked="" ':"")+'disabled="" type="checkbox"'+(this.options.xhtml?" /":"")+"> "},t.paragraph=function(e){return"<p>"+e+"</p>\n"},t.table=function(e,t){return t&&(t="<tbody>"+t+"</tbody>"),"<table>\n<thead>\n"+e+"</thead>\n"+t+"</table>\n"},t.tablerow=function(e){return"<tr>\n"+e+"</tr>\n"},t.tablecell=function(e,t){var n=t.header?"th":"td";return(t.align?"<"+n+' align="'+t.align+'">':"<"+n+">")+e+"</"+n+">\n"},t.strong=function(e){return"<strong>"+e+"</strong>"},t.em=function(e){return"<em>"+e+"</em>"},t.codespan=function(e){return"<code>"+e+"</code>"},t.br=function(){return this.options.xhtml?"<br/>":"<br>"},t.del=function(e){return"<del>"+e+"</del>"},t.link=function(e,t,n){if(null===(e=l(this.options.sanitize,this.options.baseUrl,e)))return n;var r='<a href="'+s(e)+'"';return t&&(r+=' title="'+t+'"'),r+=">"+n+"</a>"},t.image=function(e,t,n){if(null===(e=l(this.options.sanitize,this.options.baseUrl,e)))return n;var r='<img src="'+e+'" alt="'+n+'"';return t&&(r+=' title="'+t+'"'),r+=this.options.xhtml?"/>":">"},t.text=function(e){return e},e}(),j=function(){function e(){}var t=e.prototype;return t.strong=function(e){return e},t.em=function(e){return e},t.codespan=function(e){return e},t.del=function(e){return e},t.html=function(e){return e},t.text=function(e){return e},t.link=function(e,t,n){return""+n},t.image=function(e,t,n){return""+n},t.br=function(){return""},e}(),T=function(){function e(){this.seen={}}var t=e.prototype;return t.serialize=function(e){return e.toLowerCase().trim().replace(/<[!\/a-z].*?>/gi,"").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g,"").replace(/\s/g,"-")},t.getNextSafeSlug=function(e,t){var n=e,r=0;if(this.seen.hasOwnProperty(n)){r=this.seen[e];do{r++,n=e+"-"+r}while(this.seen.hasOwnProperty(n))}return t||(this.seen[e]=r,this.seen[n]=0),n},t.slug=function(e,t){void 0===t&&(t={});var n=this.serialize(e);return this.getNextSafeSlug(n,t.dryrun)},e}(),z=function(){function n(e){this.options=e||r.defaults,this.options.renderer=this.options.renderer||new $,this.renderer=this.options.renderer,this.renderer.options=this.options,this.textRenderer=new j,this.slugger=new T}n.parse=function(e,t){return new n(t).parse(e)},n.parseInline=function(e,t){return new n(t).parseInline(e)};var e=n.prototype;return e.parse=function(e,t){void 0===t&&(t=!0);var n,r,o,i,a,u,s,l,c,p,f,d,h,g,v,m,y,b,D,w="",x=e.length;for(n=0;n<x;n++)if(p=e[n],!(this.options.extensions&&this.options.extensions.renderers&&this.options.extensions.renderers[p.type])||!1===(D=this.options.extensions.renderers[p.type].call({parser:this},p))&&["space","hr","heading","code","table","blockquote","list","html","paragraph","text"].includes(p.type))switch(p.type){case"space":continue;case"hr":w+=this.renderer.hr();continue;case"heading":w+=this.renderer.heading(this.parseInline(p.tokens),p.depth,k(this.parseInline(p.tokens,this.textRenderer)),this.slugger);continue;case"code":w+=this.renderer.code(p.text,p.lang,p.escaped);continue;case"table":for(l="",s="",i=p.header.length,r=0;r<i;r++)s+=this.renderer.tablecell(this.parseInline(p.header[r].tokens),{header:!0,align:p.align[r]});for(l+=this.renderer.tablerow(s),c="",i=p.rows.length,r=0;r<i;r++){for(u=p.rows[r],s="",a=u.length,o=0;o<a;o++)s+=this.renderer.tablecell(this.parseInline(u[o].tokens),{header:!1,align:p.align[o]});c+=this.renderer.tablerow(s)}w+=this.renderer.table(l,c);continue;case"blockquote":c=this.parse(p.tokens),w+=this.renderer.blockquote(c);continue;case"list":for(f=p.ordered,d=p.start,h=p.loose,i=p.items.length,c="",r=0;r<i;r++)v=p.items[r],m=v.checked,y=v.task,g="",v.task&&(b=this.renderer.checkbox(m),h?v.tokens.length>0&&"paragraph"===v.tokens[0].type?(v.tokens[0].text=b+" "+v.tokens[0].text,v.tokens[0].tokens&&v.tokens[0].tokens.length>0&&"text"===v.tokens[0].tokens[0].type&&(v.tokens[0].tokens[0].text=b+" "+v.tokens[0].tokens[0].text)):v.tokens.unshift({type:"text",text:b}):g+=b),g+=this.parse(v.tokens,h),c+=this.renderer.listitem(g,y,m);w+=this.renderer.list(c,f,d);continue;case"html":w+=this.renderer.html(p.text);continue;case"paragraph":w+=this.renderer.paragraph(this.parseInline(p.tokens));continue;case"text":for(c=p.tokens?this.parseInline(p.tokens):p.text;n+1<x&&"text"===e[n+1].type;)p=e[++n],c+="\n"+(p.tokens?this.parseInline(p.tokens):p.text);w+=t?this.renderer.paragraph(c):c;continue;default:var A='Token with "'+p.type+'" type was not found.';if(this.options.silent)return;throw new Error(A)}else w+=D||"";return w},e.parseInline=function(e,t){t=t||this.renderer;var n,r,o,i="",a=e.length;for(n=0;n<a;n++)if(r=e[n],!(this.options.extensions&&this.options.extensions.renderers&&this.options.extensions.renderers[r.type])||!1===(o=this.options.extensions.renderers[r.type].call({parser:this},r))&&["escape","html","link","image","strong","em","codespan","br","del","text"].includes(r.type))switch(r.type){case"escape":i+=t.text(r.text);break;case"html":i+=t.html(r.text);break;case"link":i+=t.link(r.href,r.title,this.parseInline(r.tokens,t));break;case"image":i+=t.image(r.href,r.title,r.text);break;case"strong":i+=t.strong(this.parseInline(r.tokens,t));break;case"em":i+=t.em(this.parseInline(r.tokens,t));break;case"codespan":i+=t.codespan(r.text);break;case"br":i+=t.br();break;case"del":i+=t.del(this.parseInline(r.tokens,t));break;case"text":i+=t.text(r.text);break;default:var u='Token with "'+r.type+'" type was not found.';if(this.options.silent)return;throw new Error(u)}else i+=o||"";return i},n}(),H=(w.options=w.setOptions=function(e){return p(w.defaults,e),n(w.defaults),w},w.getDefaults=e,w.defaults=r.defaults,w.use=function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];var r,o=p.apply(void 0,[{}].concat(t)),a=w.defaults.extensions||{renderers:{},childTokens:{}};t.forEach(function(u){if(u.extensions&&(r=!0,u.extensions.forEach(function(o){if(!o.name)throw new Error("extension name required");if(o.renderer){var i=a.renderers?a.renderers[o.name]:null;a.renderers[o.name]=i?function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];var r=o.renderer.apply(this,t);return!1===r&&(r=i.apply(this,t)),r}:o.renderer}if(o.tokenizer){if(!o.level||"block"!==o.level&&"inline"!==o.level)throw new Error("extension level must be 'block' or 'inline'");a[o.level]?a[o.level].unshift(o.tokenizer):a[o.level]=[o.tokenizer],o.start&&("block"===o.level?a.startBlock?a.startBlock.push(o.start):a.startBlock=[o.start]:"inline"===o.level&&(a.startInline?a.startInline.push(o.start):a.startInline=[o.start]))}o.childTokens&&(a.childTokens[o.name]=o.childTokens)})),u.renderer&&function(){var a=w.defaults.renderer||new $;for(var e in u.renderer)!function(o){var i=a[o];a[o]=function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];var r=u.renderer[o].apply(a,t);return!1===r&&(r=i.apply(a,t)),r}}(e);o.renderer=a}(),u.tokenizer&&function(){var a=w.defaults.tokenizer||new _;for(var e in u.tokenizer)!function(o){var i=a[o];a[o]=function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];var r=u.tokenizer[o].apply(a,t);return!1===r&&(r=i.apply(a,t)),r}}(e);o.tokenizer=a}(),u.walkTokens){var t=w.defaults.walkTokens;o.walkTokens=function(e){u.walkTokens.call(this,e),t&&t.call(this,e)}}r&&(o.extensions=a),w.setOptions(o)})},w.walkTokens=function(e,c){for(var p,t=x(e);!(p=t()).done;)!function(){var t=p.value;switch(c.call(w,t),t.type){case"table":for(var e,n=x(t.header);!(e=n()).done;){var r=e.value;w.walkTokens(r.tokens,c)}for(var o,i=x(t.rows);!(o=i()).done;)for(var a,u=o.value,s=x(u);!(a=s()).done;){var l=a.value;w.walkTokens(l.tokens,c)}break;case"list":w.walkTokens(t.items,c);break;default:w.defaults.extensions&&w.defaults.extensions.childTokens&&w.defaults.extensions.childTokens[t.type]?w.defaults.extensions.childTokens[t.type].forEach(function(e){w.walkTokens(t[e],c)}):t.tokens&&w.walkTokens(t.tokens,c)}}()},w.parseInline=function(e,t){if(void 0===e||null===e)throw new Error("marked.parseInline(): input parameter is undefined or null");if("string"!=typeof e)throw new Error("marked.parseInline(): input parameter is of type "+Object.prototype.toString.call(e)+", string expected");t=p({},w.defaults,t||{}),g(t);try{var n=B.lexInline(e,t);return t.walkTokens&&w.walkTokens(n,t.walkTokens),z.parseInline(n,t)}catch(e){if(e.message+="\nPlease report this to https://github.com/markedjs/marked.",t.silent)return"<p>An error occurred:</p><pre>"+s(e.message+"",!0)+"</pre>";throw e}},w.Parser=z,w.parser=z.parse,w.Renderer=$,w.TextRenderer=j,w.Lexer=B,w.lexer=B.lex,w.Tokenizer=_,w.Slugger=T,(w.parse=w).options),Z=w.setOptions,K=w.use,G=w.walkTokens,J=w.parseInline,X=w,Y=z.parse,ee=B.lex;r.Lexer=B,r.Parser=z,r.Renderer=$,r.Slugger=T,r.TextRenderer=j,r.Tokenizer=_,r.getDefaults=e,r.lexer=ee,r.marked=w,r.options=H,r.parse=X,r.parseInline=J,r.parser=Y,r.setOptions=Z,r.use=K,r.walkTokens=G,Object.defineProperty(r,"__esModule",{value:!0})}(t)},function(e,t,n){"use strict";function r(e,t){e=e.pluralTypeToLanguages,n={},c(p(e),function(e){var t=e[0],e=e[1];c(e,function(e){n[e]=t})});var n,e=n;return e[t]||e[v.call(t,/-/,1)[0]]||e.en}function o(e){return e.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function i(e,t,n,r,o){if("string"!=typeof e)throw new TypeError("Polyglot.transformPhrase expects argument #1 to be string");if(null==t)return e;var i=e,r=r||D,a="number"==typeof t?{smart_count:t}:t;return null!=a.smart_count&&e&&(t=o||y,o=v.call(e,m),e=b(t,n||"en"),n=a.smart_count,t=t.pluralTypes[e](n),i=h(o[t]||o[0])),g.call(i,r,function(e,t){return d(a,t)&&null!=a[t]?a[t]:e})}function a(e){var e=e||{},t=(this.phrases={},this.extend(e.phrases||{}),this.currentLocale=e.locale||"en",e.allowMissing?i:null);this.onMissingKey="function"==typeof e.onMissingKey?e.onMissingKey:t,this.warn=e.warn||u,this.tokenRegex=function(e){var t=e&&e.prefix||"%{",e=e&&e.suffix||"}";if(t===m||e===m)throw new RangeError('"'+m+'" token is reserved for pluralization');return new RegExp(o(t)+"(.*?)"+o(e),"g")}(e.interpolation),this.pluralRules=e.pluralRules||y}function u(e){f(!1,e)}function s(e){var t=(e=e%100)%10;return 11!=e&&1==t?0:2<=t&&t<=4&&!(12<=e&&e<=14)?1:2}var l,c=n(43),p=n(89),f=n(94),d=n(25),h=n(92),g=String.prototype.replace,v=String.prototype.split,m="||||",y={pluralTypes:{arabic:function(e){if(e<3)return e;e%=100;return 3<=e&&e<=10?3:11<=e?4:5},bosnian_serbian:s,chinese:function(){return 0},croatian:s,french:function(e){return 2<=e?1:0},german:function(e){return 1!==e?1:0},russian:s,lithuanian:function(e){return e%10==1&&e%100!=11?0:2<=e%10&&e%10<=9&&(e%100<11||19<e%100)?1:2},czech:function(e){return 1===e?0:2<=e&&e<=4?1:2},polish:function(e){if(1===e)return 0;var t=e%10;return 2<=t&&t<=4&&(e%100<10||20<=e%100)?1:2},icelandic:function(e){return e%10!=1||e%100==11?1:0},slovenian:function(e){e%=100;return 1==e?0:2==e?1:3==e||4==e?2:3}},pluralTypeToLanguages:{arabic:["ar"],bosnian_serbian:["bs-Latn-BA","bs-Cyrl-BA","srl-RS","sr-RS"],chinese:["id","id-ID","ja","ko","ko-KR","lo","ms","th","th-TH","zh"],croatian:["hr","hr-HR"],german:["fa","da","de","en","es","fi","el","he","hi-IN","hu","hu-HU","it","nl","no","pt","sv","tr"],french:["fr","tl","pt-br"],russian:["ru","ru-RU"],lithuanian:["lt"],czech:["cs","cs-CZ","sk"],polish:["pl"],icelandic:["is"],slovenian:["sl-SL"]}},b=(l={},function(e,t){var n=l[t];return n&&!e.pluralTypes[n]&&(l[t]=n=null),n||(n=r(e,t))&&(l[t]=n),n}),D=/%\{(.*?)\}/g;a.prototype.locale=function(e){return e&&(this.currentLocale=e),this.currentLocale},a.prototype.extend=function(e,n){c(p(e||{}),function(e){var t=e[0],e=e[1],t=n?n+"."+t:t;"object"==typeof e?this.extend(e,t):this.phrases[t]=e},this)},a.prototype.unset=function(e,n){"string"==typeof e?delete this.phrases[e]:c(p(e||{}),function(e){var t=e[0],e=e[1],t=n?n+"."+t:t;"object"==typeof e?this.unset(e,t):delete this.phrases[t]},this)},a.prototype.clear=function(){this.phrases={}},a.prototype.replace=function(e){this.clear(),this.extend(e)},a.prototype.t=function(e,t){var n,r,t=null==t?{}:t;return"string"==typeof this.phrases[e]?n=this.phrases[e]:"string"==typeof t._?n=t._:r=this.onMissingKey?(0,this.onMissingKey)(e,t,this.currentLocale,this.tokenRegex,this.pluralRules):(this.warn('Missing translation for key: "'+e+'"'),e),r="string"==typeof n?i(n,t,this.currentLocale,this.tokenRegex,this.pluralRules):r},a.prototype.has=function(e){return d(this.phrases,e)},a.transformPhrase=function(e,t,n){return i(e,t,n)},e.exports=a},function(e,t,n){"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var s=Object.getOwnPropertySymbols,l=Object.prototype.hasOwnProperty,c=Object.prototype.propertyIsEnumerable;e.exports=function(){try{if(!Object.assign)return;var e=new String("abc");if(e[5]="de","5"===Object.getOwnPropertyNames(e)[0])return;for(var t={},n=0;n<10;n++)t["_"+String.fromCharCode(n)]=n;if("0123456789"!==Object.getOwnPropertyNames(t).map(function(e){return t[e]}).join(""))return;var r={};return"abcdefghijklmnopqrst".split("").forEach(function(e){r[e]=e}),"abcdefghijklmnopqrst"===Object.keys(Object.assign({},r)).join("")}catch(e){return}}()?Object.assign:function(e,t){for(var n,r=function(e){if(null==e)throw new TypeError("Object.assign cannot be called with null or undefined");return Object(e)}(e),o=1;o<arguments.length;o++){for(var i in n=Object(arguments[o]))l.call(n,i)&&(r[i]=n[i]);if(s)for(var a=s(n),u=0;u<a.length;u++)c.call(n,a[u])&&(r[a[u]]=n[a[u]])}return r}},function(e,i,t){function m(e,t){if(e===1/0||e===-1/0||e!=e||e&&-1e3<e&&e<1e3||c.call(/e/,t))return t;var n=/[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;if("number"==typeof e){var r=e<0?-o(-e):o(e);if(r!==e)return e=String(r),r=T.call(t,e.length+1),z.call(e,n,"$&_")+"."+z.call(z.call(r,/([0-9]{3})/g,"$&_"),/_$/,"")}return z.call(t,n,"$&_")}function y(e,t,n){n="double"===(n.quoteStyle||t)?'"':"'";return n+e+n}function b(e){return!("[object Array]"!==x(e)||U&&"object"==typeof e&&U in e)}function D(e){if(N)return e&&"object"==typeof e&&e instanceof Symbol;if("symbol"==typeof e)return 1;if(e&&"object"==typeof e&&L)try{return L.call(e),1}catch(e){}}function w(e,t){return s.call(e,t)}function x(e){return a.call(e)}function A(e,t){if(e.indexOf)return e.indexOf(t);for(var n=0,r=e.length;n<r;n++)if(e[n]===t)return n;return-1}function V(e){var e=e.charCodeAt(0),t={8:"b",9:"t",10:"n",12:"f",13:"r"}[e];return t?"\\"+t:"\\x"+(e<16?"0":"")+u.call(e.toString(16))}function k(e){return"Object("+e+")"}function E(e){return e+" { ? }"}function F(e,t,n,r){return e+" ("+t+") {"+(r?C(n,r):P.call(n,", "))+"}"}function C(e,t){if(0===e.length)return"";var n="\n"+t.prev+t.base;return n+P.call(e,","+n)+"\n"+t.prev}function _(e,t){var n=b(e),r=[];if(n){r.length=e.length;for(var o=0;o<e.length;o++)r[o]=w(e,o)?t(e[o],e):""}var i,a="function"==typeof p?p(e):[];if(N)for(var u={},s=0;s<a.length;s++)u["$"+a[s]]=a[s];for(i in e)!w(e,i)||n&&String(Number(i))===i&&i<e.length||N&&u["$"+i]instanceof Symbol||(c.call(/[^\w$]/,i)?r.push(t(i,e)+": "+t(e[i],e)):r.push(i+": "+t(e[i],e)));if("function"==typeof p)for(var l=0;l<a.length;l++)Q.call(e,a[l])&&r.push("["+t(a[l])+"]: "+t(e[a[l]],e));return r}var n="function"==typeof Map&&Map.prototype,r=Object.getOwnPropertyDescriptor&&n?Object.getOwnPropertyDescriptor(Map.prototype,"size"):null,S=n&&r&&"function"==typeof r.get?r.get:null,H=n&&Map.prototype.forEach,r="function"==typeof Set&&Set.prototype,n=Object.getOwnPropertyDescriptor&&r?Object.getOwnPropertyDescriptor(Set.prototype,"size"):null,O=r&&n&&"function"==typeof n.get?n.get:null,Z=r&&Set.prototype.forEach,B="function"==typeof WeakMap&&WeakMap.prototype?WeakMap.prototype.has:null,$="function"==typeof WeakSet&&WeakSet.prototype?WeakSet.prototype.has:null,j="function"==typeof WeakRef&&WeakRef.prototype?WeakRef.prototype.deref:null,K=Boolean.prototype.valueOf,a=Object.prototype.toString,G=Function.prototype.toString,J=String.prototype.match,T=String.prototype.slice,z=String.prototype.replace,u=String.prototype.toUpperCase,I=String.prototype.toLowerCase,c=RegExp.prototype.test,R=Array.prototype.concat,P=Array.prototype.join,X=Array.prototype.slice,o=Math.floor,M="function"==typeof BigInt?BigInt.prototype.valueOf:null,p=Object.getOwnPropertySymbols,L="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?Symbol.prototype.toString:null,N="function"==typeof Symbol&&"object"==typeof Symbol.iterator,U="function"==typeof Symbol&&Symbol.toStringTag&&(typeof Symbol.toStringTag===N||"symbol")?Symbol.toStringTag:null,Q=Object.prototype.propertyIsEnumerable,q=("function"==typeof Reflect?Reflect:Object).getPrototypeOf||([].__proto__===Array.prototype?function(e){return e.__proto__}:null),n=t(102).custom,W=n&&D(n)?n:null,s=(e.exports=function r(n,e,o,i){function a(e,t,n){return t&&(i=X.call(i)).push(t),n?(t={depth:u.depth},w(u,"quoteStyle")&&(t.quoteStyle=u.quoteStyle),r(e,t,o+1,i)):r(e,u,o+1,i)}var u=e||{};if(w(u,"quoteStyle")&&"single"!==u.quoteStyle&&"double"!==u.quoteStyle)throw new TypeError('option "quoteStyle" must be "single" or "double"');if(w(u,"maxStringLength")&&("number"==typeof u.maxStringLength?u.maxStringLength<0&&u.maxStringLength!==1/0:null!==u.maxStringLength))throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');e=!w(u,"customInspect")||u.customInspect;if("boolean"!=typeof e&&"symbol"!==e)throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");if(w(u,"indent")&&null!==u.indent&&"\t"!==u.indent&&!(parseInt(u.indent,10)===u.indent&&0<u.indent))throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');if(w(u,"numericSeparator")&&"boolean"!=typeof u.numericSeparator)throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');var t=u.numericSeparator;if(void 0===n)return"undefined";if(null===n)return"null";if("boolean"==typeof n)return n?"true":"false";if("string"==typeof n)return function e(t,n){var r;return t.length>n.maxStringLength?(r="... "+(r=t.length-n.maxStringLength)+" more character"+(1<r?"s":""),e(T.call(t,0,n.maxStringLength),n)+r):y(z.call(z.call(t,/(['\\])/g,"\\$1"),/[\x00-\x1f]/g,V),"single",n)}(n,u);if("number"==typeof n){if(0===n)return 0<1/0/n?"0":"-0";var s=String(n);return t?m(n,s):s}if("bigint"==typeof n)return s=String(n)+"n",t?m(n,s):s;t=void 0===u.depth?5:u.depth;if(t<=(o=void 0===o?0:o)&&0<t&&"object"==typeof n)return b(n)?"[Array]":"[Object]";var l,c,p,f,d,s=function(e,t){var n;if("\t"===e.indent)n="\t";else{if(!("number"==typeof e.indent&&0<e.indent))return null;n=P.call(Array(e.indent+1)," ")}return{base:n,prev:P.call(Array(t+1),n)}}(u,o);if(void 0===i)i=[];else if(0<=A(i,n))return"[Circular]";if("function"==typeof n)return"[Function"+((t=(t=n).name||((t=J.call(G.call(t),/^function\s*([\w$]+)/))?t[1]:null))?": "+t:" (anonymous)")+"]"+(0<(t=_(n,a)).length?" { "+P.call(t,", ")+" }":"");if(D(n))return t=N?z.call(String(n),/^(Symbol\(.*\))_[^)]*$/,"$1"):L.call(n),"object"!=typeof n||N?t:k(t);if((t=n)&&"object"==typeof t&&("undefined"!=typeof HTMLElement&&t instanceof HTMLElement||"string"==typeof t.nodeName&&"function"==typeof t.getAttribute)){for(var h="<"+I.call(String(n.nodeName)),g=n.attributes||[],v=0;v<g.length;v++)h+=" "+g[v].name+"="+y((l=g[v].value,z.call(String(l),/"/g,"&quot;")),"double",u);return h+=">",n.childNodes&&n.childNodes.length&&(h+="..."),h+("</"+I.call(String(n.nodeName)))+">"}if(b(n)){if(0===n.length)return"[]";var t=_(n,a);return s&&!function(e){for(var t=0;t<e.length;t++)if(0<=A(e[t],"\n"))return;return 1}(t)?"["+C(t,s)+"]":"[ "+P.call(t,", ")+" ]"}if(!("[object Error]"!==x(t=n)||U&&"object"==typeof t&&U in t))return t=_(n,a),"cause"in n&&!Q.call(n,"cause")?"{ ["+String(n)+"] "+P.call(R.call("[cause]: "+a(n.cause),t),", ")+" }":0===t.length?"["+String(n)+"]":"{ ["+String(n)+"] "+P.call(t,", ")+" }";if("object"==typeof n&&e){if(W&&"function"==typeof n[W])return n[W]();if("symbol"!==e&&"function"==typeof n.inspect)return n.inspect()}return function(e){if(S&&e&&"object"==typeof e)try{S.call(e);try{O.call(e)}catch(e){return 1}return e instanceof Map}catch(e){}}(n)?(c=[],H.call(n,function(e,t){c.push(a(t,n,!0)+" => "+a(e,n))}),F("Map",S.call(n),c,s)):function(e){if(O&&e&&"object"==typeof e)try{O.call(e);try{S.call(e)}catch(e){return 1}return e instanceof Set}catch(e){}}(n)?(p=[],Z.call(n,function(e){p.push(a(e,n))}),F("Set",O.call(n),p,s)):function(e){if(B&&e&&"object"==typeof e)try{B.call(e,B);try{$.call(e,$)}catch(e){return 1}return e instanceof WeakMap}catch(e){}}(n)?E("WeakMap"):function(e){if($&&e&&"object"==typeof e)try{$.call(e,$);try{B.call(e,B)}catch(e){return 1}return e instanceof WeakSet}catch(e){}}(n)?E("WeakSet"):function(e){if(j&&e&&"object"==typeof e)try{return j.call(e),1}catch(e){}}(n)?E("WeakRef"):"[object Number]"!==x(t=n)||U&&"object"==typeof t&&U in t?function(e){if(e&&"object"==typeof e&&M)try{return M.call(e),1}catch(e){}}(n)?k(a(M.call(n))):"[object Boolean]"!==x(e=n)||U&&"object"==typeof e&&U in e?"[object String]"!==x(t=n)||U&&"object"==typeof t&&U in t?("[object Date]"!==x(e=n)||U&&"object"==typeof e&&U in e)&&("[object RegExp]"!==x(t=n)||U&&"object"==typeof t&&U in t)?(e=_(n,a),t=q?q(n)===Object.prototype:n instanceof Object||n.constructor===Object,f=n instanceof Object?"":"null prototype",d=!t&&U&&Object(n)===n&&U in n?T.call(x(n),8,-1):f?"Object":"",t=(!t&&"function"==typeof n.constructor&&n.constructor.name?n.constructor.name+" ":"")+(d||f?"["+P.call(R.call([],d||[],f||[]),": ")+"] ":""),0===e.length?t+"{}":s?t+"{"+C(e,s)+"}":t+"{ "+P.call(e,", ")+" }"):String(n):k(a(String(n))):k(K.call(n)):k(a(Number(n)))},Object.prototype.hasOwnProperty||function(e){return e in this})},function(e,t,n){"use strict";var f,d,h,g,v,m,y,r,b,o;Object.keys||(f=Object.prototype.hasOwnProperty,d=Object.prototype.toString,h=n(26),n=Object.prototype.propertyIsEnumerable,g=!n.call({toString:null},"toString"),v=n.call(function(){},"prototype"),m=["toString","toLocaleString","valueOf","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","constructor"],y=function(e){var t=e.constructor;return t&&t.prototype===e},r={$applicationCache:!0,$console:!0,$external:!0,$frame:!0,$frameElement:!0,$frames:!0,$innerHeight:!0,$innerWidth:!0,$onmozfullscreenchange:!0,$onmozfullscreenerror:!0,$outerHeight:!0,$outerWidth:!0,$pageXOffset:!0,$pageYOffset:!0,$parent:!0,$scrollLeft:!0,$scrollTop:!0,$scrollX:!0,$scrollY:!0,$self:!0,$webkitIndexedDB:!0,$webkitStorageInfo:!0,$window:!0},b=function(){if("undefined"==typeof window)return!1;for(var e in window)try{if(!r["$"+e]&&f.call(window,e)&&null!==window[e]&&"object"==typeof window[e])try{y(window[e])}catch(e){return!0}}catch(e){return!0}return!1}(),o=function(e){var t=null!==e&&"object"==typeof e,n="[object Function]"===d.call(e),r=h(e),o=t&&"[object String]"===d.call(e),i=[];if(!t&&!n&&!r)throw new TypeError("Object.keys called on a non-object");var a=v&&n;if(o&&0<e.length&&!f.call(e,0))for(var u=0;u<e.length;++u)i.push(String(u));if(r&&0<e.length)for(var s=0;s<e.length;++s)i.push(String(s));else for(var l in e)a&&"prototype"===l||!f.call(e,l)||i.push(String(l));if(g)for(var c=function(e){if("undefined"==typeof window||!b)return y(e);try{return y(e)}catch(e){return!1}}(e),p=0;p<m.length;++p)c&&"constructor"===m[p]||!f.call(e,m[p])||i.push(m[p]);return i}),e.exports=o},function(e,t,n){"use strict";var r=Array.prototype.slice,o=n(26),i=Object.keys,a=i?function(e){return i(e)}:n(87),u=Object.keys;a.shim=function(){return Object.keys?function(){var e=Object.keys(arguments);return e&&e.length===arguments.length}(1,2)||(Object.keys=function(e){return u(o(e)?r.call(e):e)}):Object.keys=a,Object.keys||a},e.exports=a},function(e,t,n){"use strict";var r=n(2),o=n(4),i=n(27),a=n(28),n=n(90),o=o(a(),Object);r(o,{getPolyfill:a,implementation:i,shim:n}),e.exports=o},function(e,t,n){"use strict";var r=n(28),o=n(2);e.exports=function(){var e=r();return o(Object,{entries:e},{entries:function(){return Object.entries!==e}}),e}},function(e,t){function n(){throw new Error("setTimeout has not been defined")}function r(){throw new Error("clearTimeout has not been defined")}function o(t){if(l===setTimeout)return setTimeout(t,0);if((l===n||!l)&&setTimeout)return(l=setTimeout)(t,0);try{return l(t,0)}catch(e){try{return l.call(null,t,0)}catch(e){return l.call(this,t,0)}}}function i(){d&&p&&(d=!1,p.length?f=p.concat(f):h=-1,f.length&&a())}function a(){if(!d){var e=o(i);d=!0;for(var t=f.length;t;){for(p=f,f=[];++h<t;)p&&p[h].run();h=-1,t=f.length}p=null,d=!1,function(t){if(c===clearTimeout)return clearTimeout(t);if((c===r||!c)&&clearTimeout)return(c=clearTimeout)(t);try{c(t)}catch(e){try{return c.call(null,t)}catch(e){return c.call(this,t)}}}(e)}}function u(e,t){this.fun=e,this.array=t}function s(){}var l,c,e=e.exports={};try{l="function"==typeof setTimeout?setTimeout:n}catch(e){l=n}try{c="function"==typeof clearTimeout?clearTimeout:r}catch(e){c=r}var p,f=[],d=!1,h=-1;e.nextTick=function(e){var t=new Array(arguments.length-1);if(1<arguments.length)for(var n=1;n<arguments.length;n++)t[n-1]=arguments[n];f.push(new u(e,t)),1!==f.length||d||o(a)},u.prototype.run=function(){this.fun.apply(null,this.array)},e.title="browser",e.browser=!0,e.env={},e.argv=[],e.version="",e.versions={},e.on=s,e.addListener=s,e.once=s,e.off=s,e.removeListener=s,e.removeAllListeners=s,e.emit=s,e.prependListener=s,e.prependOnceListener=s,e.listeners=function(e){return[]},e.binding=function(e){throw new Error("process.binding is not supported")},e.cwd=function(){return"/"},e.chdir=function(e){throw new Error("process.chdir is not supported")},e.umask=function(){return 0}},function(e,t,n){"use strict";var r=n(4),o=n(2),i=n(29),a=n(30),n=n(93),r=r(a());o(r,{getPolyfill:a,implementation:i,shim:n}),e.exports=r},function(e,t,n){"use strict";var r=n(2),o=n(30);e.exports=function(){var e=o();return r(String.prototype,{trim:e},{trim:function(){return String.prototype.trim!==e}}),e}},function(n,e,t){"use strict";!function(e){var t=function(){};"production"!==e.env.NODE_ENV&&(t=function(e,t,n){var r=arguments.length;n=new Array(2<r?r-2:0);for(var o=2;o<r;o++)n[o-2]=arguments[o];if(void 0===t)throw new Error("`warning(condition, format, ...args)` requires a warning message argument");e||function(e,t){var n=arguments.length;t=new Array(1<n?n-1:0);for(var r=1;r<n;r++)t[r-1]=arguments[r];var o=0,i="Warning: "+e.replace(/%s/g,function(){return t[o++]});try{throw new Error(i)}catch(e){}}.apply(null,[t].concat(n))}),n.exports=t}.call(e,t(91))},function(e,t,n){function r(e,t){return new u(t).process(e)}var o,i=n(31),a=n(32),u=n(96);for(o in(t=e.exports=r).filterXSS=r,t.FilterXSS=u,i)t[o]=i[o];for(o in a)t[o]=a[o];"undefined"!=typeof window&&(window.filterXSS=e.exports),"undefined"!=typeof self&&"undefined"!=typeof DedicatedWorkerGlobalScope&&self instanceof DedicatedWorkerGlobalScope&&(self.filterXSS=e.exports)},function(e,t,n){function g(e){return null==e}function r(e){(e=function(e){var t,n={};for(t in e)n[t]=e[t];return n}(e||{})).stripIgnoreTag&&(e.onIgnoreTag,e.onIgnoreTag=i.onIgnoreTagStripAll),e.whiteList=e.whiteList||e.allowList||i.whiteList,e.onTag=e.onTag||i.onTag,e.onTagAttr=e.onTagAttr||i.onTagAttr,e.onIgnoreTag=e.onIgnoreTag||i.onIgnoreTag,e.onIgnoreTagAttr=e.onIgnoreTagAttr||i.onIgnoreTagAttr,e.safeAttrValue=e.safeAttrValue||i.safeAttrValue,e.escapeHtml=e.escapeHtml||i.escapeHtml,!1===(this.options=e).css?this.cssFilter=!1:(e.css=e.css||{},this.cssFilter=new o(e.css))}var o=n(7).FilterCSS,i=n(31),a=n(32),v=a.parseTag,m=a.parseAttr,y=n(11);r.prototype.process=function(e){if(!(e=(e=e||"").toString()))return"";var t=this.options,u=t.whiteList,s=t.onTag,l=t.onIgnoreTag,c=t.onTagAttr,p=t.onIgnoreTagAttr,f=t.safeAttrValue,d=t.escapeHtml,h=this.cssFilter,n=(t.stripBlankChar&&(e=i.stripBlankChar(e)),t.allowCommentTag||(e=i.stripCommentTag(e)),!1),t=(t.stripIgnoreTagBody&&(l=(n=i.StripTagBody(t.stripIgnoreTagBody,l)).onIgnoreTag),v(e,function(e,t,o,n,r){e={sourcePosition:e,position:t,isClosing:r,isWhite:u.hasOwnProperty(o)},t=s(o,n,e);if(!g(t))return t;if(e.isWhite){if(e.isClosing)return"</"+o+">";r=n;var r=-1===(a=y.spaceIndex(r))?{html:"",closing:"/"===r[r.length-2]}:{html:r=(a="/"===(r=y.trim(r.slice(a+1,-1)))[r.length-1])?y.trim(r.slice(0,-1)):r,closing:a},i=u[o],a=m(r.html,function(e,t){var n=-1!==y.indexOf(i,e),r=c(o,e,t,n);return g(r)?n?(t=f(o,e,t,h))?e+'="'+t+'"':e:g(r=p(o,e,t,n))?void 0:r:r}),n="<"+o;return a&&(n+=" "+a),r.closing&&(n+=" /"),n+">"}return g(t=l(o,n,e))?d(n):t},d));return t=n?n.remove(t):t},e.exports=r},function(e,t){e.exports={smile:"e3/2018new_weixioa02_org.png",lovely:"09/2018new_keai_org.png",happy:"1e/2018new_taikaixin_org.png",clap:"6e/2018new_guzhang_thumb.png",whee:"33/2018new_xixi_thumb.png",haha:"8f/2018new_haha_thumb.png","laugh and cry":"4a/2018new_xiaoku_thumb.png",wink:"43/2018new_jiyan_org.png",greddy:"fa/2018new_chanzui_org.png",awkward:"a3/2018new_heixian_thumb.png",sweat:"28/2018new_han_org.png","pick nose":"9a/2018new_wabi_thumb.png",hum:"7c/2018new_heng_thumb.png",angry:"f6/2018new_nu_thumb.png",grievance:"a5/2018new_weiqu_thumb.png",poor:"96/2018new_kelian_org.png",disappoint:"aa/2018new_shiwang_thumb.png",sad:"ee/2018new_beishang_org.png",tear:"6e/2018new_leimu_org.png","no way":"83/2018new_kuxiao_org.png",shy:"c1/2018new_haixiu_org.png",dirt:"10/2018new_wu_thumb.png","love you":"f6/2018new_aini_org.png",kiss:"2c/2018new_qinqin_thumb.png",amorousness:"9d/2018new_huaxin_org.png",longing:"c9/2018new_chongjing_org.png",desire:"3e/2018new_tianping_thumb.png","bad laugh":"4d/2018new_huaixiao_org.png",blackness:"9e/2018new_yinxian_org.png","laugh without word":"2d/2018new_xiaoerbuyu_org.png",titter:"71/2018new_touxiao_org.png",cool:"c4/2018new_ku_org.png","not easy":"aa/2018new_bingbujiandan_thumb.png",think:"30/2018new_sikao_org.png",question:"b8/2018new_ningwen_org.png","no idea":"2a/2018new_wenhao_thumb.png",dizzy:"07/2018new_yun_thumb.png",bomb:"a2/2018new_shuai_thumb.png",bone:"a1/2018new_kulou_thumb.png","be quiet":"b0/2018new_xu_org.png","shut up":"62/2018new_bizui_org.png",stupid:"dd/2018new_shayan_org.png","surprise ":"49/2018new_chijing_org.png",vomit:"08/2018new_tu_org.png",cold:"40/2018new_kouzhao_thumb.png",sick:"3b/2018new_shengbing_thumb.png",bye:"fd/2018new_baibai_thumb.png","look down on":"da/2018new_bishi_org.png","white eye":"ef/2018new_landelini_org.png","left hum":"43/2018new_zuohengheng_thumb.png","right hum":"c1/2018new_youhengheng_thumb.png",crazy:"17/2018new_zhuakuang_org.png","scold ":"87/2018new_zhouma_thumb.png","hit on face":"cb/2018new_dalian_org.png",wow:"ae/2018new_ding_org.png",fan:"86/2018new_hufen02_org.png",money:"a2/2018new_qian_thumb.png",yawn:"55/2018new_dahaqian_org.png",sleepy:"3c/2018new_kun_thumb.png",sleep:"e2/2018new_shuijiao_thumb.png","watermelon ":"01/2018new_chigua_thumb.png",doge:"a1/2018new_doge02_org.png",dog:"22/2018new_erha_org.png",cat:"7b/2018new_miaomiao_thumb.png",thumb:"e6/2018new_zan_org.png",good:"8a/2018new_good_org.png",ok:"45/2018new_ok_org.png",yeah:"29/2018new_ye_thumb.png","shack hand":"e9/2018new_woshou_thumb.png",bow:"e7/2018new_zuoyi_org.png",come:"42/2018new_guolai_thumb.png",punch:"86/2018new_quantou_thumb.png"}},function(e,t){e.exports={nick:"NickName",mail:"E-Mail",link:"Website(http://)",nickFail:"NickName cannot be less than 3 bytes.",mailFail:"Please confirm your email address.",sofa:"No comment yet.",submit:"Submit",reply:"Reply",cancelReply:"Cancel reply",comments:"Comments",cancel:"Cancel",confirm:"Confirm",continue:"Continue",more:"Load More...",preview:"Preview",emoji:"Emoji",expand:"See more....",seconds:"seconds ago",minutes:"minutes ago",hours:"hours ago",days:"days ago",now:"just now",uploading:"Uploading ...",uploadDone:"Upload completed!",busy:"Submit is busy, please wait...","code-98":"Valine initialization failed, please check your version of av-min.js.","code-99":"Valine initialization failed, Please check the `el` element in the init method.","code-100":"Valine initialization failed, Please check your appId and appKey.","code-140":"The total number of API calls today has exceeded the development version limit.","code-401":"Unauthorized operation, Please check your appId and appKey.","code-403":"Access denied by API domain white list, Please check your security domain."}},function(e,t){e.exports={nick:"\u30cb\u30c3\u30af\u30cd\u30fc\u30e0",mail:"\u30e1\u30fc\u30eb\u30a2\u30c9\u30ec\u30b9",link:"\u30b5\u30a4\u30c8(http://)",nickFail:"3\u30d0\u30a4\u30c8\u4ee5\u4e0a\u306e\u30cb\u30c3\u30af\u30cd\u30fc\u30e0\u3092\u3054\u5165\u529b\u304f\u3060\u3055\u3044.",mailFail:"\u30e1\u30fc\u30eb\u30a2\u30c9\u30ec\u30b9\u3092\u3054\u78ba\u8a8d\u304f\u3060\u3055\u3044.",sofa:"\u30b3\u30e1\u30f3\u30c8\u3057\u307e\u3057\u3087\u3046~",submit:"\u63d0\u51fa\u3059\u308b",reply:"\u8fd4\u4fe1\u3059\u308b",cancelReply:"\u30ad\u30e3\u30f3\u30bb\u30eb",comments:"\u30b3\u30e1\u30f3\u30c8",cancel:"\u30ad\u30e3\u30f3\u30bb\u30eb",confirm:"\u78ba\u8a8d\u3059\u308b",continue:"\u7ee7\u7eed",more:"\u3055\u3089\u306b\u8aad\u307f\u8fbc\u3080...",preview:"\u30d7\u30ec\u30d3\u30e5\u30fc",emoji:"\u7d75\u6587\u5b57",expand:"\u3082\u3063\u3068\u898b\u308b",seconds:"\u79d2\u524d",minutes:"\u5206\u524d",hours:"\u6642\u9593\u524d",days:"\u65e5\u524d",now:"\u305f\u3063\u3060\u4eca",uploading:"\u30a2\u30c3\u30d7\u30ed\u30fc\u30c9\u4e2d...",uploadDone:"\u30a2\u30c3\u30d7\u30ed\u30fc\u30c9\u304c\u5b8c\u4e86\u3057\u307e\u3057\u305f!",busy:"20 \u79d2\u9593\u9694\u3067\u63d0\u51fa\u3057\u3066\u304f\u3060\u3055\u3044    ...","code-98":"\u30ed\u30fc\u30c9\u30a8\u30e9\u30fc\u3067\u3059\u3002av-min.js \u306e\u30d0\u30fc\u30b8\u30e7\u30f3\u3092\u78ba\u8a8d\u3057\u3066\u304f\u3060\u3055\u3044.","code-99":"\u30ed\u30fc\u30c9\u30a8\u30e9\u30fc\u3067\u3059\u3002init\u306b\u3042\u308b`el`\u30a8\u30ec\u30e1\u30f3\u30c8\u3092\u78ba\u8a8d\u304f\u3060\u3055\u3044.","code-100":"\u30ed\u30fc\u30c9\u30a8\u30e9\u30fc\u3067\u3059\u3002AppId\u3068AppKey\u3092\u78ba\u8a8d\u304f\u3060\u3055\u3044.","code-140":"\u4eca\u65e5\u306eAPI\u30b3\u30fc\u30eb\u306e\u7dcf\u6570\u304c\u958b\u767a\u30d0\u30fc\u30b8\u30e7\u30f3\u306e\u4e0a\u9650\u3092\u8d85\u3048\u305f.","code-401":"\u6a29\u9650\u304c\u5236\u9650\u3055\u308c\u3066\u3044\u307e\u3059\u3002AppId\u3068AppKey\u3092\u78ba\u8a8d\u304f\u3060\u3055\u3044.","code-403":"\u30a2\u30af\u30bb\u30b9\u304cAPI\u306a\u3069\u306b\u5236\u9650\u3055\u308c\u307e\u3057\u305f\u3001\u30c9\u30e1\u30a4\u30f3\u540d\u306e\u30bb\u30ad\u30e5\u30ea\u30c6\u30a3\u8a2d\u5b9a\u3092\u78ba\u8a8d\u304f\u3060\u3055\u3044"}},function(e,t){e.exports={nick:"\u6635\u79f0",mail:"\u90ae\u7bb1",link:"\u7f51\u5740(http://)",nickFail:"\u6635\u79f0\u4e0d\u80fd\u5c11\u4e8e3\u4e2a\u5b57\u7b26",mailFail:"\u8bf7\u586b\u5199\u6b63\u786e\u7684\u90ae\u4ef6\u5730\u5740",sofa:"\u6765\u53d1\u8bc4\u8bba\u5427~",submit:"\u63d0\u4ea4",reply:"\u56de\u590d",cancelReply:"\u53d6\u6d88\u56de\u590d",comments:"\u8bc4\u8bba",cancel:"\u53d6\u6d88",confirm:"\u786e\u8ba4",continue:"\u7ee7\u7eed",more:"\u52a0\u8f7d\u66f4\u591a...",preview:"\u9884\u89c8",emoji:"\u8868\u60c5",expand:"\u67e5\u770b\u66f4\u591a...",seconds:"\u79d2\u524d",minutes:"\u5206\u949f\u524d",hours:"\u5c0f\u65f6\u524d",days:"\u5929\u524d",now:"\u521a\u521a",uploading:"\u6b63\u5728\u4f20\u8f93...",uploadDone:"\u4f20\u8f93\u5b8c\u6210!",busy:"\u64cd\u4f5c\u9891\u7e41\uff0c\u8bf7\u7a0d\u5019\u518d\u8bd5...","code-98":"Valine \u521d\u59cb\u5316\u5931\u8d25\uff0c\u8bf7\u68c0\u67e5 av-min.js \u7248\u672c","code-99":"Valine \u521d\u59cb\u5316\u5931\u8d25\uff0c\u8bf7\u68c0\u67e5init\u4e2d\u7684`el`\u5143\u7d20.","code-100":"Valine \u521d\u59cb\u5316\u5931\u8d25\uff0c\u8bf7\u68c0\u67e5\u4f60\u7684AppId\u548cAppKey.","code-140":"\u4eca\u65e5 API \u8c03\u7528\u603b\u6b21\u6570\u5df2\u8d85\u8fc7\u5f00\u53d1\u7248\u9650\u5236.","code-401":"\u672a\u7ecf\u6388\u6743\u7684\u64cd\u4f5c\uff0c\u8bf7\u68c0\u67e5\u4f60\u7684AppId\u548cAppKey.","code-403":"\u8bbf\u95ee\u88abAPI\u57df\u540d\u767d\u540d\u5355\u62d2\u7edd\uff0c\u8bf7\u68c0\u67e5\u4f60\u7684\u5b89\u5168\u57df\u540d\u8bbe\u7f6e."}},function(e,t){e.exports={nick:"\u66b1\u7a31",mail:"\u90f5\u7bb1",link:"\u7db2\u5740(http://)",nickFail:"\u6635\u7a31\u4e0d\u80fd\u5c11\u65bc3\u500b\u5b57\u7b26",mailFail:"\u8acb\u586b\u5beb\u6b63\u78ba\u7684\u90f5\u4ef6\u5730\u5740",sofa:"\u4f86\u767c\u8a55\u8ad6\u5427~",submit:"\u63d0\u4ea4",reply:"\u56de\u8986",cancelReply:"\u53d6\u6d88\u56de\u8986",comments:"\u8a55\u8ad6",cancel:"\u53d6\u6d88",confirm:"\u78ba\u8a8d",continue:"\u7e7c\u7e8c",more:"\u52a0\u8f09\u66f4\u591a...",preview:"\u9810\u89bd",emoji:"\u8868\u60c5",expand:"\u67e5\u770b\u66f4\u591a...",seconds:"\u79d2\u524d",minutes:"\u5206\u9418\u524d",hours:"\u5c0f\u6642\u524d",days:"\u5929\u524d",now:"\u525b\u525b",uploading:"\u6b63\u5728\u4e0a\u50b3...",uploadDone:"\u4e0a\u50b3\u5b8c\u6210!",busy:"\u64cd\u4f5c\u983b\u7e41\uff0c\u8acb\u7a0d\u5019\u518d\u8a66...","code-98":"Valine \u521d\u59cb\u5316\u5931\u6557\uff0c\u8acb\u6aa2\u67e5 av-min.js \u7248\u672c","code-99":"Valine \u521d\u59cb\u5316\u5931\u6557\uff0c\u8acb\u6aa2\u67e5init\u4e2d\u7684`el`\u5143\u7d20.","code-100":"Valine \u521d\u59cb\u5316\u5931\u6557\uff0c\u8acb\u6aa2\u67e5\u4f60\u7684AppId\u548cAppKey.","code-140":"\u4eca\u65e5 API \u8abf\u7528\u7e3d\u6b21\u6578\u5df2\u8d85\u904e\u958b\u767c\u7248\u9650\u5236.","code-401":"\u672a\u7d93\u6388\u6b0a\u7684\u64cd\u4f5c\uff0c\u8acb\u6aa2\u67e5\u4f60\u7684AppId\u548cAppKey.","code-403":"\u8a2a\u554f\u88abAPI\u57df\u540d\u767d\u540d\u55ae\u62d2\u7d55\uff0c\u8acb\u6aa2\u67e5\u4f60\u7684\u5b89\u5168\u57df\u540d\u8a2d\u7f6e."}},function(e,t){},function(e,t,n){var r=n(104),o=("string"==typeof r&&(r=[[e.i,r,""]]),{});o.transform=void 0,n(106)(r,o),r.locals&&(e.exports=r.locals)},function(e,t,n){(t=n(105)(!1)).push([e.i,'.v[data-class=v]{font-size:16px;text-align:left}.v[data-class=v] *{-webkit-box-sizing:border-box;box-sizing:border-box;line-height:1.75}.v[data-class=v] .vinput,.v[data-class=v] .veditor,.v[data-class=v] p,.v[data-class=v] pre code,.v[data-class=v] .status-bar{color:#555}.v[data-class=v] .vtime,.v[data-class=v] .vsys{color:#b3b3b3}.v[data-class=v] .text-right{text-align:right}.v[data-class=v] .text-center{text-align:center}.v[data-class=v] img{max-width:100%;border:none}.v[data-class=v] hr{margin:.825em 0;border-color:#f6f6f6;border-style:dashed}.v[data-class=v].hide-avatar .vimg{display:none}.v[data-class=v] a{position:relative;cursor:pointer;color:#1abc9c;text-decoration:none;display:inline-block}.v[data-class=v] a:hover{color:#d7191a}.v[data-class=v] pre,.v[data-class=v] code{background-color:#f8f8f8;padding:.2em .4em;border-radius:3px;font-size:85%;margin:0}.v[data-class=v] pre{padding:10px;overflow:auto;line-height:1.45}.v[data-class=v] pre code{padding:0;background:transparent;white-space:pre-wrap;word-break:keep-all}.v[data-class=v] blockquote{color:#666;margin:.5em 0;padding:0 0 0 1em;border-left:8px solid rgba(238,238,238,.5)}.v[data-class=v] .vinput{border:none;resize:none;outline:none;padding:10px 5px;max-width:100%;font-size:.775em;-webkit-box-sizing:border-box;box-sizing:border-box}.v[data-class=v] input[type=checkbox],.v[data-class=v] input[type=radio]{display:inline-block;vertical-align:middle;margin-top:-2px}.v[data-class=v] .vicon{cursor:pointer;display:inline-block;overflow:hidden;fill:#555;vertical-align:middle}.v[data-class=v] .vicon+.vicon{margin-left:10px}.v[data-class=v] .vicon.actived{fill:#66b1ff}.v[data-class=v] .vrow{font-size:0;padding:10px 0}.v[data-class=v] .vrow .vcol{display:inline-block;vertical-align:middle;font-size:14px}.v[data-class=v] .vrow .vcol.vcol-20{width:20%}.v[data-class=v] .vrow .vcol.vcol-30{width:30%}.v[data-class=v] .vrow .vcol.vcol-40{width:40%}.v[data-class=v] .vrow .vcol.vcol-50{width:50%}.v[data-class=v] .vrow .vcol.vcol-60{width:60%}.v[data-class=v] .vrow .vcol.vcol-70{width:70%}.v[data-class=v] .vrow .vcol.vcol-80{width:80%}.v[data-class=v] .vrow .vcol.vctrl{font-size:12px}.v[data-class=v] .vemoji,.v[data-class=v] .emoji{width:26px;height:26px;overflow:hidden;vertical-align:middle;margin:0 1px;display:inline-block}.v[data-class=v] .vwrap{border:1px solid #f0f0f0;border-radius:4px;margin-bottom:10px;overflow:hidden;position:relative;padding:10px}.v[data-class=v] .vwrap input{background:transparent}.v[data-class=v] .vwrap .vedit{position:relative;padding-top:10px}.v[data-class=v] .vwrap .cancel-reply-btn{position:absolute;right:5px;top:5px;cursor:pointer}.v[data-class=v] .vwrap .vemojis{display:none;font-size:18px;max-height:145px;overflow:auto;padding-bottom:10px;-webkit-box-shadow:0px 0 1px #f0f0f0;box-shadow:0px 0 1px #f0f0f0}.v[data-class=v] .vwrap .vemojis i{font-style:normal;padding-top:7px;width:36px;cursor:pointer;text-align:center;display:inline-block;vertical-align:middle}.v[data-class=v] .vwrap .vpreview{padding:7px;-webkit-box-shadow:0px 0 1px #f0f0f0;box-shadow:0px 0 1px #f0f0f0}.v[data-class=v] .vwrap .vheader .vinput{width:33.33%;border-bottom:1px #dedede dashed}.v[data-class=v] .vwrap .vheader.item2 .vinput{width:50%}.v[data-class=v] .vwrap .vheader.item1 .vinput{width:100%}.v[data-class=v] .vwrap .vheader .vinput:focus{border-bottom-color:#eb5055}@media screen and (max-width: 520px){.v[data-class=v] .vwrap .vheader .vinput{width:100%}.v[data-class=v] .vwrap .vheader.item2 .vinput{width:100%}}.v[data-class=v] .vpower{color:#999;font-size:.75em;padding:.5em 0}.v[data-class=v] .vpower a{font-size:.75em}.v[data-class=v] .vcount{padding:5px;font-weight:600;font-size:1.25em}.v[data-class=v] ul,.v[data-class=v] ol{padding:0;margin-left:1.25em}.v[data-class=v] .txt-center{text-align:center}.v[data-class=v] .txt-right{text-align:right}.v[data-class=v] .veditor{width:100%;min-height:8.75em;font-size:.875em;background:transparent;resize:vertical;-webkit-transition:all .25s ease;transition:all .25s ease}.v[data-class=v] .vbtn{-webkit-transition-duration:.4s;transition-duration:.4s;text-align:center;color:#555;border:1px solid #ededed;border-radius:.3em;display:inline-block;background:transparent;margin-bottom:0;font-weight:400;vertical-align:middle;-ms-touch-action:manipulation;touch-action:manipulation;cursor:pointer;white-space:nowrap;padding:.5em 1.25em;font-size:.875em;line-height:1.42857143;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;outline:none}.v[data-class=v] .vbtn+.vbtn{margin-left:1.25em}.v[data-class=v] .vbtn:active,.v[data-class=v] .vbtn:hover{color:#3090e4;border-color:#3090e4}.v[data-class=v] .vbtn:disabled{border-color:#e1e1e1;color:#e1e1e1;background-color:#fdfafa;cursor:not-allowed}.v[data-class=v] .vempty{padding:1.25em;text-align:center;color:#555;overflow:auto}.v[data-class=v] .vsys{display:inline-block;padding:.2em .5em;font-size:.75em;border-radius:.2em;margin-right:.3em}@media screen and (max-width: 520px){.v[data-class=v] .vsys{display:none}}.v[data-class=v] .vcards{width:100%}.v[data-class=v] .vcards .vcard{padding-top:1.25em;position:relative;display:block}.v[data-class=v] .vcards .vcard:after{content:"";clear:both;display:block}.v[data-class=v] .vcards .vcard .vimg{width:3.125em;height:3.125em;float:left;border-radius:50%;margin-right:.7525em;border:1px solid #f5f5f5;padding:.125em}@media screen and (max-width: 720px){.v[data-class=v] .vcards .vcard .vimg{width:2.5em;height:2.5em}}.v[data-class=v] .vcards .vcard .vhead{line-height:1.5;margin-top:0}.v[data-class=v] .vcards .vcard .vhead .vtag{font-size:12px;display:inline-block;line-height:20px;border-radius:2px;color:#fff;padding:0 5px;position:inherit;margin-left:-5px;} .vcards .vcard .vhead .vtag.vmaster{background:#ffa51e} .vcards .vcard .vhead .vtag.vfriend{background:#6cf} .vcards .vcard .vhead .vtag.vvisitor{background:#828282} .vcards .vcard .vhead .browser-icon, .vcards .vcard .vhead .os-icon{margin-right:3px;} .vcards .vcard .vhead .vnick{position:relative;font-size:.875em;font-weight:500;margin-right:.875em;cursor:pointer;text-decoration:none;display:inline-block}.v[data-class=v] .vcards .vcard .vhead .vnick:hover{color:#d7191a}.v[data-class=v] .vcards .vcard .vh{overflow:hidden;padding-bottom:.5em;border-bottom:1px dashed #f5f5f5}.v[data-class=v] .vcards .vcard .vh .vtime{font-size:.75em;margin-right:.875em}.v[data-class=v] .vcards .vcard .vh .vmeta{line-height:1;position:relative}.v[data-class=v] .vcards .vcard .vh .vmeta .vat{font-size:.8125em;color:#ef2f11;cursor:pointer;float:right}.v[data-class=v] .vcards .vcard:last-child .vh{border-bottom:none}.v[data-class=v] .vcards .vcard .vcontent{word-wrap:break-word;word-break:break-all;font-size:.875em;line-height:2;position:relative;margin-bottom:.75em;padding-top:.625em}.v[data-class=v] .vcards .vcard .vcontent.expand{cursor:pointer;max-height:8em;overflow:hidden}.v[data-class=v] .vcards .vcard .vcontent.expand::before{display:block;content:"";position:absolute;width:100%;left:0;top:0;bottom:3.15em;background:-webkit-gradient(linear, left top, left bottom, from(rgba(255, 255, 255, 0)), to(rgba(255, 255, 255, 0.9)));background:linear-gradient(180deg, rgba(255, 255, 255, 0), rgba(255, 255, 255, 0.9));z-index:999}.v[data-class=v] .vcards .vcard .vcontent.expand::after{display:block;content:attr(data-expand);text-align:center;color:#828586;position:absolute;width:100%;height:3.15em;line-height:3.15em;left:0;bottom:0;z-index:999;background:rgba(255,255,255,.9)}.v[data-class=v] .vcards .vcard .vquote{padding-left:1em;border-left:1px dashed rgba(238,238,238,.5)}.v[data-class=v] .vcards .vcard .vquote .vimg{width:2.225em;height:2.225em}.v[data-class=v] .vpage .vmore{margin:1em 0}.v[data-class=v] .clear{content:"";display:block;clear:both}@-webkit-keyframes spin{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes spin{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@-webkit-keyframes pulse{50%{background:#dcdcdc}}@keyframes pulse{50%{background:#dcdcdc}}.v[data-class=v] .vspinner{width:22px;height:22px;display:inline-block;border:6px double #a0a0a0;border-top-color:transparent;border-bottom-color:transparent;border-radius:50%;-webkit-animation:spin 1s infinite linear;animation:spin 1s infinite linear;position:relative;vertical-align:middle;margin:0 5px}[data-theme=dark] .v[data-class=v] .vinput,[data-theme=dark] .v[data-class=v] .veditor,[data-theme=dark] .v[data-class=v] p,[data-theme=dark] .v[data-class=v] pre code,[data-theme=dark] .v[data-class=v] .status-bar,.dark .v[data-class=v] .vinput,.dark .v[data-class=v] .veditor,.dark .v[data-class=v] p,.dark .v[data-class=v] pre code,.dark .v[data-class=v] .status-bar,.theme__dark .v[data-class=v] .vinput,.theme__dark .v[data-class=v] .veditor,.theme__dark .v[data-class=v] p,.theme__dark .v[data-class=v] pre code,.theme__dark .v[data-class=v] .status-bar,.night .v[data-class=v] .vinput,.night .v[data-class=v] .veditor,.night .v[data-class=v] p,.night .v[data-class=v] pre code,.night .v[data-class=v] .status-bar{color:#b2b2b5}[data-theme=dark] .v[data-class=v] .vtime,[data-theme=dark] .v[data-class=v] .vsys,.dark .v[data-class=v] .vtime,.dark .v[data-class=v] .vsys,.theme__dark .v[data-class=v] .vtime,.theme__dark .v[data-class=v] .vsys,.night .v[data-class=v] .vtime,.night .v[data-class=v] .vsys{color:#929298}[data-theme=dark] .v[data-class=v] pre,[data-theme=dark] .v[data-class=v] code,[data-theme=dark] .v[data-class=v] pre code,.dark .v[data-class=v] pre,.dark .v[data-class=v] code,.dark .v[data-class=v] pre code,.theme__dark .v[data-class=v] pre,.theme__dark .v[data-class=v] code,.theme__dark .v[data-class=v] pre code,.night .v[data-class=v] pre,.night .v[data-class=v] code,.night .v[data-class=v] pre code{color:#929298;background-color:#151414}[data-theme=dark] .v[data-class=v] .vwrap,.dark .v[data-class=v] .vwrap,.theme__dark .v[data-class=v] .vwrap,.night .v[data-class=v] .vwrap{border-color:#b2b2b5}[data-theme=dark] .v[data-class=v] .vicon,.dark .v[data-class=v] .vicon,.theme__dark .v[data-class=v] .vicon,.night .v[data-class=v] .vicon{fill:#b2b2b5}[data-theme=dark] .v[data-class=v] .vicon.actived,.dark .v[data-class=v] .vicon.actived,.theme__dark .v[data-class=v] .vicon.actived,.night .v[data-class=v] .vicon.actived{fill:#66b1ff}[data-theme=dark] .v[data-class=v] .vbtn,.dark .v[data-class=v] .vbtn,.theme__dark .v[data-class=v] .vbtn,.night .v[data-class=v] .vbtn{color:#b2b2b5;border-color:#b2b2b5}[data-theme=dark] .v[data-class=v] .vbtn:hover,.dark .v[data-class=v] .vbtn:hover,.theme__dark .v[data-class=v] .vbtn:hover,.night .v[data-class=v] .vbtn:hover{color:#66b1ff;border-color:#66b1ff}[data-theme=dark] .v[data-class=v] a:hover,.dark .v[data-class=v] a:hover,.theme__dark .v[data-class=v] a:hover,.night .v[data-class=v] a:hover{color:#d7191a}[data-theme=dark] .v[data-class=v] .vcards .vcard .vcontent.expand::before,.dark .v[data-class=v] .vcards .vcard .vcontent.expand::before,.theme__dark .v[data-class=v] .vcards .vcard .vcontent.expand::before,.night .v[data-class=v] .vcards .vcard .vcontent.expand::before{background:-webkit-gradient(linear, left top, left bottom, from(rgba(0, 0, 0, 0.3)), to(rgba(0, 0, 0, 0.7)));background:linear-gradient(180deg, rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.7))}[data-theme=dark] .v[data-class=v] .vcards .vcard .vcontent.expand::after,.dark .v[data-class=v] .vcards .vcard .vcontent.expand::after,.theme__dark .v[data-class=v] .vcards .vcard .vcontent.expand::after,.night .v[data-class=v] .vcards .vcard .vcontent.expand::after{background:rgba(0,0,0,.7)}@media(prefers-color-scheme: dark){.v[data-class=v] .vinput,.v[data-class=v] .veditor,.v[data-class=v] p,.v[data-class=v] pre code,.v[data-class=v] .status-bar{color:#b2b2b5}.v[data-class=v] .vtime,.v[data-class=v] .vsys{color:#929298}.v[data-class=v] pre,.v[data-class=v] code,.v[data-class=v] pre code{color:#929298;background-color:#151414}.v[data-class=v] .vwrap{border-color:#b2b2b5}.v[data-class=v] .vicon{fill:#b2b2b5}.v[data-class=v] .vicon.actived{fill:#66b1ff}.v[data-class=v] .vbtn{color:#b2b2b5;border-color:#b2b2b5}.v[data-class=v] .vbtn:hover{color:#66b1ff;border-color:#66b1ff}.v[data-class=v] a:hover{color:#d7191a}.v[data-class=v] .vcards .vcard .vcontent.expand::before{background:-webkit-gradient(linear, left top, left bottom, from(rgba(0, 0, 0, 0.3)), to(rgba(0, 0, 0, 0.7)));background:linear-gradient(180deg, rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.7))}.v[data-class=v] .vcards .vcard .vcontent.expand::after{background:rgba(0,0,0,.7)}}',""]),e.exports=t},function(e,t,n){"use strict";function r(e,t){var n=e[1]||"",r=e[3];return r?t&&"function"==typeof btoa?(e="/*# ".concat("sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(r)))))," */"),[n].concat(r.sources.map(function(e){return"/*# sourceURL=".concat(r.sourceRoot||"").concat(e," */")})).concat([e]).join("\n")):[n].join("\n"):n}e.exports=function(n){var s=[];return s.toString=function(){return this.map(function(e){var t=r(e,n);return e[2]?"@media ".concat(e[2]," {").concat(t,"}"):t}).join("")},s.i=function(e,t,n){"string"==typeof e&&(e=[[null,e,""]]);var r={};if(n)for(var o=0;o<this.length;o++){var i=this[o][0];null!=i&&(r[i]=!0)}for(var a=0;a<e.length;a++){var u=[].concat(e[a]);n&&r[u[0]]||(t&&(u[2]?u[2]="".concat(t," and ").concat(u[2]):u[2]=t),s.push(u))}},s}},function(e,t,n){function s(e,t){for(var n=0;n<e.length;n++){var r=e[n],o=g[r.id];if(o){o.refs++;for(var i=0;i<o.parts.length;i++)o.parts[i](r.parts[i]);for(;i<r.parts.length;i++)o.parts.push(d(r.parts[i],t))}else{for(var a=[],i=0;i<r.parts.length;i++)a.push(d(r.parts[i],t));g[r.id]={id:r.id,refs:1,parts:a}}}}function l(e,t){for(var n=[],r={},o=0;o<e.length;o++){var i=e[o],a=t.base?i[0]+t.base:i[0],i={css:i[1],media:i[2],sourceMap:i[3]};r[a]?r[a].parts.push(i):n.push(r[a]={id:a,parts:[i]})}return n}function u(e,t){var n=a(e.insertInto);if(!n)throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");var r=b[b.length-1];if("top"===e.insertAt)r?r.nextSibling?n.insertBefore(t,r.nextSibling):n.appendChild(t):n.insertBefore(t,n.firstChild),b.push(t);else{if("bottom"!==e.insertAt)throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");n.appendChild(t)}}function c(e){null!==e.parentNode&&(e.parentNode.removeChild(e),0<=(e=b.indexOf(e))&&b.splice(e,1))}function p(e){var t=document.createElement("style");return e.attrs.type="text/css",f(t,e.attrs),u(e,t),t}function f(t,n){Object.keys(n).forEach(function(e){t.setAttribute(e,n[e])})}function d(t,e){var n,r,o,i,a;if(e.transform&&t.css){if(!(i=e.transform(t.css)))return function(){};t.css=i}return o=e.singleton?(i=y++,n=m=m||p(e),r=h.bind(null,n,i,!1),h.bind(null,n,i,!0)):t.sourceMap&&"function"==typeof URL&&"function"==typeof URL.createObjectURL&&"function"==typeof URL.revokeObjectURL&&"function"==typeof Blob&&"function"==typeof btoa?(i=e,a=document.createElement("link"),i.attrs.type="text/css",i.attrs.rel="stylesheet",f(a,i.attrs),u(i,a),n=a,r=function(e,t,n){var r=n.css,n=n.sourceMap,o=void 0===t.convertToAbsoluteUrls&&n,t=((t.convertToAbsoluteUrls||o)&&(r=D(r)),n&&(r+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(n))))+" */"),new Blob([r],{type:"text/css"})),o=e.href;e.href=URL.createObjectURL(t),o&&URL.revokeObjectURL(o)}.bind(null,n,e),function(){c(n),n.href&&URL.revokeObjectURL(n.href)}):(n=p(e),r=function(e,t){var n=t.css,t=t.media;if(t&&e.setAttribute("media",t),e.styleSheet)e.styleSheet.cssText=n;else{for(;e.firstChild;)e.removeChild(e.firstChild);e.appendChild(document.createTextNode(n))}}.bind(null,n),function(){c(n)}),r(t),function(e){e?e.css===t.css&&e.media===t.media&&e.sourceMap===t.sourceMap||r(t=e):o()}}function h(e,t,n,r){var n=n?"":r.css;e.styleSheet?e.styleSheet.cssText=w(t,n):(r=document.createTextNode(n),(n=e.childNodes)[t]&&e.removeChild(n[t]),n.length?e.insertBefore(r,n[t]):e.appendChild(r))}var r,o,i,g={},v=function(){return o=void 0===o?function(){return window&&document&&document.all&&!window.atob}.apply(this,arguments):o},a=(r={},function(e){return void 0===r[e]&&(r[e]=function(e){return document.querySelector(e)}.call(this,e)),r[e]}),m=null,y=0,b=[],D=n(107),w=(e.exports=function(e,a){if("undefined"!=typeof DEBUG&&DEBUG&&"object"!=typeof document)throw new Error("The style-loader cannot be used in a non-browser environment");(a=a||{}).attrs="object"==typeof a.attrs?a.attrs:{},a.singleton||(a.singleton=v()),a.insertInto||(a.insertInto="head"),a.insertAt||(a.insertAt="bottom");var u=l(e,a);return s(u,a),function(e){for(var t=[],n=0;n<u.length;n++){var r=u[n];(o=g[r.id]).refs--,t.push(o)}e&&s(l(e,a),a);for(var o,n=0;n<t.length;n++)if(0===(o=t[n]).refs){for(var i=0;i<o.parts.length;i++)o.parts[i]();delete g[o.id]}}},i=[],function(e,t){return i[e]=t,i.filter(Boolean).join("\n")})},function(e,t){e.exports=function(e){var t="undefined"!=typeof window&&window.location;if(!t)throw new Error("fixUrls requires window.location");if(!e||"string"!=typeof e)return e;var n=t.protocol+"//"+t.host,r=n+t.pathname.replace(/\/[^\/]*$/,"/");return e.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi,function(e,t){t=t.trim().replace(/^"(.*)"$/,function(e,t){return t}).replace(/^'(.*)'$/,function(e,t){return t});return/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(t)?e:(e=0===t.indexOf("//")?t:0===t.indexOf("/")?n+t:r+t.replace(/^\.\//,""),"url("+JSON.stringify(e)+")")})}},function(e,t,n){n(103),e.exports=n(34)}],o={},r.m=n,r.c=o,r.i=function(e){return e},r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:n})},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=108);function r(e){if(o[e])return o[e].exports;var t=o[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,r),t.l=!0,t.exports}var n,o});
]]></content>
  </entry>
</search>
